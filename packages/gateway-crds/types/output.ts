// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import * as utilities from "../utilities";

import {ObjectMeta} from "../meta/v1";

export namespace gateway {
    export namespace v1 {
        /**
         * Spec defines the desired state of GRPCRoute.
         */
        export interface GRPCRouteSpec {
            /**
             * Hostnames defines a set of hostnames to match against the GRPC
             * Host header to select a GRPCRoute to process the request. This matches
             * the RFC 1123 definition of a hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label MUST appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and GRPCRoute, there
             * MUST be at least one intersecting hostname for the GRPCRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches GRPCRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches GRPCRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `test.example.com` and `*.example.com` would both match. On the other
             *   hand, `example.com` and `test.example.net` would not match.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * If both the Listener and GRPCRoute have specified hostnames, any
             * GRPCRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * GRPCRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` MUST NOT be considered for a match.
             *
             *
             * If both the Listener and GRPCRoute have specified hostnames, and none
             * match with the criteria above, then the GRPCRoute MUST NOT be accepted by
             * the implementation. The implementation MUST raise an 'Accepted' Condition
             * with a status of `False` in the corresponding RouteParentStatus.
             *
             *
             * If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
             * Listener and that listener already has another Route (B) of the other
             * type attached and the intersection of the hostnames of A and B is
             * non-empty, then the implementation MUST accept exactly one of these two
             * routes, determined by the following criteria, in order:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * The rejected Route MUST raise an 'Accepted' condition with a status of
             * 'False' in the corresponding RouteParentStatus.
             *
             *
             * Support: Core
             */
            hostnames?: string[];
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: outputs.gateway.v1.GRPCRouteSpecParentRefs[];
            /**
             * Rules are a list of GRPC matchers, filters and actions.
             */
            rules?: outputs.gateway.v1.GRPCRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface GRPCRouteSpecParentRefs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * grpcrouteSpecParentRefsProvideDefaults sets the appropriate defaults for GRPCRouteSpecParentRefs
         */
        export function grpcrouteSpecParentRefsProvideDefaults(val: GRPCRouteSpecParentRefs): GRPCRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * GRPCRouteRule defines the semantics for matching a gRPC request based on
         * conditions (matches), processing it (filters), and forwarding the request to
         * an API object (backendRefs).
         */
        export interface GRPCRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent.
             *
             *
             * Failure behavior here depends on how many BackendRefs are specified and
             * how many are invalid.
             *
             *
             * If *all* entries in BackendRefs are invalid, and there are also no filters
             * specified in this route rule, *all* traffic which matches this rule MUST
             * receive an `UNAVAILABLE` status.
             *
             *
             * See the GRPCBackendRef definition for the rules about what makes a single
             * GRPCBackendRef invalid.
             *
             *
             * When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
             * requests that would have otherwise been routed to an invalid backend. If
             * multiple backends are specified, and some are invalid, the proportion of
             * requests that would otherwise have been routed to an invalid backend
             * MUST receive an `UNAVAILABLE` status.
             *
             *
             * For example, if two backends are specified with equal weights, and one is
             * invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
             * Implementations may choose how that 50 percent is determined.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Core
             */
            backendRefs?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefs[];
            /**
             * Filters define the filters that are applied to requests that match
             * this rule.
             *
             *
             * The effects of ordering of multiple behaviors are currently unspecified.
             * This can change in the future based on feedback during the alpha stage.
             *
             *
             * Conformance-levels at this level are defined based on the type of filter:
             *
             *
             * - ALL core filters MUST be supported by all implementations that support
             *   GRPCRoute.
             * - Implementers are encouraged to support extended filters.
             * - Implementation-specific custom filters have no API guarantees across
             *   implementations.
             *
             *
             * Specifying the same filter multiple times is not supported unless explicitly
             * indicated in the filter.
             *
             *
             * If an implementation can not support a combination of filters, it must clearly
             * document that limitation. In cases where incompatible or unsupported
             * filters are specified and cause the `Accepted` condition to be set to status
             * `False`, implementations may use the `IncompatibleFilters` reason to specify
             * this configuration error.
             *
             *
             * Support: Core
             */
            filters?: outputs.gateway.v1.GRPCRouteSpecRulesFilters[];
            /**
             * Matches define conditions used for matching the rule against incoming
             * gRPC requests. Each match is independent, i.e. this rule will be matched
             * if **any** one of the matches is satisfied.
             *
             *
             * For example, take the following matches configuration:
             *
             *
             * ```
             * matches:
             * - method:
             *     service: foo.bar
             *   headers:
             *     values:
             *       version: 2
             * - method:
             *     service: foo.bar.v2
             * ```
             *
             *
             * For a request to match against this rule, it MUST satisfy
             * EITHER of the two conditions:
             *
             *
             * - service of foo.bar AND contains the header `version: 2`
             * - service of foo.bar.v2
             *
             *
             * See the documentation for GRPCRouteMatch on how to specify multiple
             * match conditions to be ANDed together.
             *
             *
             * If no matches are specified, the implementation MUST match every gRPC request.
             *
             *
             * Proxy or Load Balancer routing configuration generated from GRPCRoutes
             * MUST prioritize rules based on the following criteria, continuing on
             * ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
             * Precedence MUST be given to the rule with the largest number of:
             *
             *
             * * Characters in a matching non-wildcard hostname.
             * * Characters in a matching hostname.
             * * Characters in a matching service.
             * * Characters in a matching method.
             * * Header matches.
             *
             *
             * If ties still exist across multiple Routes, matching precedence MUST be
             * determined in order of the following criteria, continuing on ties:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * If ties still exist within the Route that has been given precedence,
             * matching precedence MUST be granted to the first matching rule meeting
             * the above criteria.
             */
            matches?: outputs.gateway.v1.GRPCRouteSpecRulesMatches[];
            /**
             * SessionPersistence defines and configures session persistence
             * for the route rule.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: outputs.gateway.v1.GRPCRouteSpecRulesSessionPersistence;
        }
        /**
         * grpcrouteSpecRulesProvideDefaults sets the appropriate defaults for GRPCRouteSpecRules
         */
        export function grpcrouteSpecRulesProvideDefaults(val: GRPCRouteSpecRules): GRPCRouteSpecRules {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? outputs.gateway.v1.grpcrouteSpecRulesSessionPersistenceProvideDefaults(val.sessionPersistence) : undefined),
            };
        }

        /**
         * GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         */
        export interface GRPCRouteSpecRulesBackendRefs {
            /**
             * Filters defined at this level MUST be executed if and only if the
             * request is being forwarded to the backend defined here.
             *
             *
             * Support: Implementation-specific (For broader support of filters, use the
             * Filters field in GRPCRouteRule.)
             */
            filters?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFilters[];
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * grpcrouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefs
         */
        export function grpcrouteSpecRulesBackendRefsProvideDefaults(val: GRPCRouteSpecRulesBackendRefs): GRPCRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. GRPCRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesBackendRefsFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * Support: Implementation-specific
             *
             *
             * This filter can be used multiple times within the same rule.
             */
            extensionRef?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestMirror;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations supporting GRPCRoute MUST support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` MUST be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             */
            type: string;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFilters
         */
        export function grpcrouteSpecRulesBackendRefsFiltersProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFilters): GRPCRouteSpecRulesBackendRefsFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * Support: Implementation-specific
         *
         *
         * This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirror
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirror): GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef): GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. GRPCRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * Support: Implementation-specific
             *
             *
             * This filter can be used multiple times within the same rule.
             */
            extensionRef?: outputs.gateway.v1.GRPCRouteSpecRulesFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: outputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestMirror;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1.GRPCRouteSpecRulesFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations supporting GRPCRoute MUST support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` MUST be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             */
            type: string;
        }
        /**
         * grpcrouteSpecRulesFiltersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFilters
         */
        export function grpcrouteSpecRulesFiltersProvideDefaults(val: GRPCRouteSpecRulesFilters): GRPCRouteSpecRulesFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1.grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * Support: Implementation-specific
         *
         *
         * This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestMirrorBackendRef;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirror
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirror): GRPCRouteSpecRulesFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1.grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRef
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirrorBackendRef): GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1.GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1.GRPCRouteSpecRulesFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * GRPCRouteMatch defines the predicate used to match requests to a given
         * action. Multiple match types are ANDed together, i.e. the match will
         * evaluate to true only if all conditions are satisfied.
         *
         *
         * For example, the match below will match a gRPC request only if its service
         * is `foo` AND it contains the `version: v1` header:
         *
         *
         * ```
         * matches:
         *   - method:
         *     type: Exact
         *     service: "foo"
         *     headers:
         *   - name: "version"
         *     value "v1"
         *
         *
         * ```
         */
        export interface GRPCRouteSpecRulesMatches {
            /**
             * Headers specifies gRPC request header matchers. Multiple match values are
             * ANDed together, meaning, a request MUST match all the specified headers
             * to select the route.
             */
            headers?: outputs.gateway.v1.GRPCRouteSpecRulesMatchesHeaders[];
            /**
             * Method specifies a gRPC request service/method matcher. If this field is
             * not specified, all services and methods will match.
             */
            method?: outputs.gateway.v1.GRPCRouteSpecRulesMatchesMethod;
        }
        /**
         * grpcrouteSpecRulesMatchesProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatches
         */
        export function grpcrouteSpecRulesMatchesProvideDefaults(val: GRPCRouteSpecRulesMatches): GRPCRouteSpecRulesMatches {
            return {
                ...val,
                method: (val.method ? outputs.gateway.v1.grpcrouteSpecRulesMatchesMethodProvideDefaults(val.method) : undefined),
            };
        }

        /**
         * GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
         * headers.
         */
        export interface GRPCRouteSpecRulesMatchesHeaders {
            /**
             * Name is the name of the gRPC Header to be matched.
             *
             *
             * If multiple entries specify equivalent header names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: string;
            /**
             * Value is the value of the gRPC Header to be matched.
             */
            value: string;
        }
        /**
         * grpcrouteSpecRulesMatchesHeadersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeaders
         */
        export function grpcrouteSpecRulesMatchesHeadersProvideDefaults(val: GRPCRouteSpecRulesMatchesHeaders): GRPCRouteSpecRulesMatchesHeaders {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Method specifies a gRPC request service/method matcher. If this field is
         * not specified, all services and methods will match.
         */
        export interface GRPCRouteSpecRulesMatchesMethod {
            /**
             * Value of the method to match against. If left empty or omitted, will
             * match all services.
             *
             *
             * At least one of Service and Method MUST be a non-empty string.
             */
            method?: string;
            /**
             * Value of the service to match against. If left empty or omitted, will
             * match any service.
             *
             *
             * At least one of Service and Method MUST be a non-empty string.
             */
            service?: string;
            /**
             * Type specifies how to match against the service and/or method.
             * Support: Core (Exact with service and method specified)
             *
             *
             * Support: Implementation-specific (Exact with method specified but no service specified)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             */
            type?: string;
        }
        /**
         * grpcrouteSpecRulesMatchesMethodProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethod
         */
        export function grpcrouteSpecRulesMatchesMethodProvideDefaults(val: GRPCRouteSpecRulesMatchesMethod): GRPCRouteSpecRulesMatchesMethod {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the route rule.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesSessionPersistence {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: string;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: outputs.gateway.v1.GRPCRouteSpecRulesSessionPersistenceCookieConfig;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: string;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: string;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: string;
        }
        /**
         * grpcrouteSpecRulesSessionPersistenceProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesSessionPersistence
         */
        export function grpcrouteSpecRulesSessionPersistenceProvideDefaults(val: GRPCRouteSpecRulesSessionPersistence): GRPCRouteSpecRulesSessionPersistence {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? outputs.gateway.v1.grpcrouteSpecRulesSessionPersistenceCookieConfigProvideDefaults(val.cookieConfig) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesSessionPersistenceCookieConfig {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: string;
        }
        /**
         * grpcrouteSpecRulesSessionPersistenceCookieConfigProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesSessionPersistenceCookieConfig
         */
        export function grpcrouteSpecRulesSessionPersistenceCookieConfigProvideDefaults(val: GRPCRouteSpecRulesSessionPersistenceCookieConfig): GRPCRouteSpecRulesSessionPersistenceCookieConfig {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * Status defines the current state of GRPCRoute.
         */
        export interface GRPCRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1.GRPCRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface GRPCRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1.GRPCRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1.GRPCRouteStatusParentsParentRef;
        }
        /**
         * grpcrouteStatusParentsProvideDefaults sets the appropriate defaults for GRPCRouteStatusParents
         */
        export function grpcrouteStatusParentsProvideDefaults(val: GRPCRouteStatusParents): GRPCRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1.grpcrouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GRPCRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface GRPCRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * grpcrouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for GRPCRouteStatusParentsParentRef
         */
        export function grpcrouteStatusParentsParentRefProvideDefaults(val: GRPCRouteStatusParentsParentRef): GRPCRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of GatewayClass.
         */
        export interface GatewayClassSpec {
            /**
             * ControllerName is the name of the controller that is managing Gateways of
             * this class. The value of this field MUST be a domain prefixed path.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * This field is not mutable and cannot be empty.
             *
             *
             * Support: Core
             */
            controllerName: string;
            /**
             * Description helps describe a GatewayClass with more details.
             */
            description?: string;
            /**
             * ParametersRef is a reference to a resource that contains the configuration
             * parameters corresponding to the GatewayClass. This is optional if the
             * controller does not require any additional configuration.
             *
             *
             * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
             * or an implementation-specific custom resource. The resource can be
             * cluster-scoped or namespace-scoped.
             *
             *
             * If the referent cannot be found, the GatewayClass's "InvalidParameters"
             * status condition will be true.
             *
             *
             * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
             * the merging behavior is implementation specific.
             * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
             *
             *
             * Support: Implementation-specific
             */
            parametersRef?: outputs.gateway.v1.GatewayClassSpecParametersRef;
        }

        /**
         * ParametersRef is a reference to a resource that contains the configuration
         * parameters corresponding to the GatewayClass. This is optional if the
         * controller does not require any additional configuration.
         *
         *
         * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
         * or an implementation-specific custom resource. The resource can be
         * cluster-scoped or namespace-scoped.
         *
         *
         * If the referent cannot be found, the GatewayClass's "InvalidParameters"
         * status condition will be true.
         *
         *
         * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
         * the merging behavior is implementation specific.
         * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
         *
         *
         * Support: Implementation-specific
         */
        export interface GatewayClassSpecParametersRef {
            /**
             * Group is the group of the referent.
             */
            group: string;
            /**
             * Kind is kind of the referent.
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the referent.
             * This field is required when referring to a Namespace-scoped resource and
             * MUST be unset when referring to a Cluster-scoped resource.
             */
            namespace?: string;
        }

        /**
         * Status defines the current state of GatewayClass.
         *
         *
         * Implementations MUST populate status on all GatewayClass resources which
         * specify their controller name.
         */
        export interface GatewayClassStatus {
            /**
             * Conditions is the current status from the controller for
             * this GatewayClass.
             *
             *
             * Controllers should prefer to publish conditions using values
             * of GatewayClassConditionType for the type of each Condition.
             */
            conditions?: outputs.gateway.v1.GatewayClassStatusConditions[];
            /**
             * SupportedFeatures is the set of features the GatewayClass support.
             * It MUST be sorted in ascending alphabetical order.
             */
            supportedFeatures?: string[];
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayClassStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * Spec defines the desired state of Gateway.
         */
        export interface GatewaySpec {
            /**
             * Addresses requested for this Gateway. This is optional and behavior can
             * depend on the implementation. If a value is set in the spec and the
             * requested address is invalid or unavailable, the implementation MUST
             * indicate this in the associated entry in GatewayStatus.Addresses.
             *
             *
             * The Addresses field represents a request for the address(es) on the
             * "outside of the Gateway", that traffic bound for this Gateway will use.
             * This could be the IP address or hostname of an external load balancer or
             * other networking infrastructure, or some other address that traffic will
             * be sent to.
             *
             *
             * If no Addresses are specified, the implementation MAY schedule the
             * Gateway in an implementation-specific manner, assigning an appropriate
             * set of Addresses.
             *
             *
             * The implementation MUST bind all Listeners to every GatewayAddress that
             * it assigns to the Gateway and add a corresponding entry in
             * GatewayStatus.Addresses.
             *
             *
             * Support: Extended
             */
            addresses?: any[];
            /**
             * GatewayClassName used for this Gateway. This is the name of a
             * GatewayClass resource.
             */
            gatewayClassName: string;
            /**
             * Infrastructure defines infrastructure level attributes about this Gateway instance.
             *
             *
             * Support: Core
             */
            infrastructure?: outputs.gateway.v1.GatewaySpecInfrastructure;
            /**
             * Listeners associated with this Gateway. Listeners define
             * logical endpoints that are bound on this Gateway's addresses.
             * At least one Listener MUST be specified.
             *
             *
             * Each Listener in a set of Listeners (for example, in a single Gateway)
             * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
             * exactly one listener. (This section uses "set of Listeners" rather than
             * "Listeners in a single Gateway" because implementations MAY merge configuration
             * from multiple Gateways onto a single data plane, and these rules _also_
             * apply in that case).
             *
             *
             * Practically, this means that each listener in a set MUST have a unique
             * combination of Port, Protocol, and, if supported by the protocol, Hostname.
             *
             *
             * Some combinations of port, protocol, and TLS settings are considered
             * Core support and MUST be supported by implementations based on their
             * targeted conformance profile:
             *
             *
             * HTTP Profile
             *
             *
             * 1. HTTPRoute, Port: 80, Protocol: HTTP
             * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
             *
             *
             * TLS Profile
             *
             *
             * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
             *
             *
             * "Distinct" Listeners have the following property:
             *
             *
             * The implementation can match inbound requests to a single distinct
             * Listener. When multiple Listeners share values for fields (for
             * example, two Listeners with the same Port value), the implementation
             * can match requests to only one of the Listeners using other
             * Listener fields.
             *
             *
             * For example, the following Listener scenarios are distinct:
             *
             *
             * 1. Multiple Listeners with the same Port that all use the "HTTP"
             *    Protocol that all have unique Hostname values.
             * 2. Multiple Listeners with the same Port that use either the "HTTPS" or
             *    "TLS" Protocol that all have unique Hostname values.
             * 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
             *    with the same Protocol has the same Port value.
             *
             *
             * Some fields in the Listener struct have possible values that affect
             * whether the Listener is distinct. Hostname is particularly relevant
             * for HTTP or HTTPS protocols.
             *
             *
             * When using the Hostname value to select between same-Port, same-Protocol
             * Listeners, the Hostname value must be different on each Listener for the
             * Listener to be distinct.
             *
             *
             * When the Listeners are distinct based on Hostname, inbound request
             * hostnames MUST match from the most specific to least specific Hostname
             * values to choose the correct Listener and its associated set of Routes.
             *
             *
             * Exact matches must be processed before wildcard matches, and wildcard
             * matches must be processed before fallback (empty Hostname value)
             * matches. For example, `"foo.example.com"` takes precedence over
             * `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
             *
             *
             * Additionally, if there are multiple wildcard entries, more specific
             * wildcard entries must be processed before less specific wildcard entries.
             * For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
             * The precise definition here is that the higher the number of dots in the
             * hostname to the right of the wildcard character, the higher the precedence.
             *
             *
             * The wildcard character will match any number of characters _and dots_ to
             * the left, however, so `"*.example.com"` will match both
             * `"foo.bar.example.com"` _and_ `"bar.example.com"`.
             *
             *
             * If a set of Listeners contains Listeners that are not distinct, then those
             * Listeners are Conflicted, and the implementation MUST set the "Conflicted"
             * condition in the Listener Status to "True".
             *
             *
             * Implementations MAY choose to accept a Gateway with some Conflicted
             * Listeners only if they only accept the partial Listener set that contains
             * no Conflicted Listeners. To put this another way, implementations may
             * accept a partial Listener set only if they throw out *all* the conflicting
             * Listeners. No picking one of the conflicting listeners as the winner.
             * This also means that the Gateway must have at least one non-conflicting
             * Listener in this case, otherwise it violates the requirement that at
             * least one Listener must be present.
             *
             *
             * The implementation MUST set a "ListenersNotValid" condition on the
             * Gateway Status when the Gateway contains Conflicted Listeners whether or
             * not they accept the Gateway. That Condition SHOULD clearly
             * indicate in the Message which Listeners are conflicted, and which are
             * Accepted. Additionally, the Listener status for those listeners SHOULD
             * indicate which Listeners are conflicted and not Accepted.
             *
             *
             * A Gateway's Listeners are considered "compatible" if:
             *
             *
             * 1. They are distinct.
             * 2. The implementation can serve them in compliance with the Addresses
             *    requirement that all Listeners are available on all assigned
             *    addresses.
             *
             *
             * Compatible combinations in Extended support are expected to vary across
             * implementations. A combination that is compatible for one implementation
             * may not be compatible for another.
             *
             *
             * For example, an implementation that cannot serve both TCP and UDP listeners
             * on the same address, or cannot mix HTTPS and generic TLS listens on the same port
             * would not consider those cases compatible, even though they are distinct.
             *
             *
             * Note that requests SHOULD match at most one Listener. For example, if
             * Listeners are defined for "foo.example.com" and "*.example.com", a
             * request to "foo.example.com" SHOULD only be routed using routes attached
             * to the "foo.example.com" Listener (and not the "*.example.com" Listener).
             * This concept is known as "Listener Isolation". Implementations that do
             * not support Listener Isolation MUST clearly document this.
             *
             *
             * Implementations MAY merge separate Gateways onto a single set of
             * Addresses if all Listeners across all Gateways are compatible.
             *
             *
             * Support: Core
             */
            listeners: outputs.gateway.v1.GatewaySpecListeners[];
        }

        /**
         * Infrastructure defines infrastructure level attributes about this Gateway instance.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecInfrastructure {
            /**
             * Annotations that SHOULD be applied to any resources created in response to this Gateway.
             *
             *
             * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
             * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
             *
             *
             * An implementation may chose to add additional implementation-specific annotations as they see fit.
             *
             *
             * Support: Extended
             */
            annotations?: {[key: string]: string};
            /**
             * Labels that SHOULD be applied to any resources created in response to this Gateway.
             *
             *
             * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
             * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
             *
             *
             * An implementation may chose to add additional implementation-specific labels as they see fit.
             *
             *
             * Support: Extended
             */
            labels?: {[key: string]: string};
            /**
             * ParametersRef is a reference to a resource that contains the configuration
             * parameters corresponding to the Gateway. This is optional if the
             * controller does not require any additional configuration.
             *
             *
             * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
             *
             *
             * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
             * the merging behavior is implementation specific.
             * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
             *
             *
             * Support: Implementation-specific
             */
            parametersRef?: outputs.gateway.v1.GatewaySpecInfrastructureParametersRef;
        }

        /**
         * ParametersRef is a reference to a resource that contains the configuration
         * parameters corresponding to the Gateway. This is optional if the
         * controller does not require any additional configuration.
         *
         *
         * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
         *
         *
         * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
         * the merging behavior is implementation specific.
         * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
         *
         *
         * Support: Implementation-specific
         */
        export interface GatewaySpecInfrastructureParametersRef {
            /**
             * Group is the group of the referent.
             */
            group: string;
            /**
             * Kind is kind of the referent.
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * Listener embodies the concept of a logical endpoint where a Gateway accepts
         * network connections.
         */
        export interface GatewaySpecListeners {
            /**
             * AllowedRoutes defines the types of routes that MAY be attached to a
             * Listener and the trusted namespaces where those Route resources MAY be
             * present.
             *
             *
             * Although a client request may match multiple route rules, only one rule
             * may ultimately receive the request. Matching precedence MUST be
             * determined in order of the following criteria:
             *
             *
             * * The most specific match as defined by the Route type.
             * * The oldest Route based on creation timestamp. For example, a Route with
             *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
             *   a Route with a creation timestamp of "2020-09-08 01:02:04".
             * * If everything else is equivalent, the Route appearing first in
             *   alphabetical order (namespace/name) should be given precedence. For
             *   example, foo/bar is given precedence over foo/baz.
             *
             *
             * All valid rules within a Route attached to this Listener should be
             * implemented. Invalid Route rules can be ignored (sometimes that will mean
             * the full Route). If a Route rule transitions from valid to invalid,
             * support for that Route rule should be dropped to ensure consistency. For
             * example, even if a filter specified by a Route rule is invalid, the rest
             * of the rules within that Route should still be supported.
             *
             *
             * Support: Core
             */
            allowedRoutes?: outputs.gateway.v1.GatewaySpecListenersAllowedRoutes;
            /**
             * Hostname specifies the virtual hostname to match for protocol types that
             * define this concept. When unspecified, all hostnames are matched. This
             * field is ignored for protocols that don't require hostname based
             * matching.
             *
             *
             * Implementations MUST apply Hostname matching appropriately for each of
             * the following protocols:
             *
             *
             * * TLS: The Listener Hostname MUST match the SNI.
             * * HTTP: The Listener Hostname MUST match the Host header of the request.
             * * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
             *   protocol layers as described above. If an implementation does not
             *   ensure that both the SNI and Host header match the Listener hostname,
             *   it MUST clearly document that.
             *
             *
             * For HTTPRoute and TLSRoute resources, there is an interaction with the
             * `spec.hostnames` array. When both listener and route specify hostnames,
             * there MUST be an intersection between the values for a Route to be
             * accepted. For more information, refer to the Route specific Hostnames
             * documentation.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * Support: Core
             */
            hostname?: string;
            /**
             * Name is the name of the Listener. This name MUST be unique within a
             * Gateway.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Port is the network port. Multiple listeners may use the
             * same port, subject to the Listener compatibility rules.
             *
             *
             * Support: Core
             */
            port: number;
            /**
             * Protocol specifies the network protocol this listener expects to receive.
             *
             *
             * Support: Core
             */
            protocol: string;
            /**
             * TLS is the TLS configuration for the Listener. This field is required if
             * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
             * if the Protocol field is "HTTP", "TCP", or "UDP".
             *
             *
             * The association of SNIs to Certificate defined in GatewayTLSConfig is
             * defined based on the Hostname field for this listener.
             *
             *
             * The GatewayClass MUST use the longest matching SNI out of all
             * available certificates for any TLS handshake.
             *
             *
             * Support: Core
             */
            tls?: outputs.gateway.v1.GatewaySpecListenersTls;
        }
        /**
         * gatewaySpecListenersProvideDefaults sets the appropriate defaults for GatewaySpecListeners
         */
        export function gatewaySpecListenersProvideDefaults(val: GatewaySpecListeners): GatewaySpecListeners {
            return {
                ...val,
                allowedRoutes: (val.allowedRoutes ? outputs.gateway.v1.gatewaySpecListenersAllowedRoutesProvideDefaults(val.allowedRoutes) : undefined),
                tls: (val.tls ? outputs.gateway.v1.gatewaySpecListenersTlsProvideDefaults(val.tls) : undefined),
            };
        }

        /**
         * AllowedRoutes defines the types of routes that MAY be attached to a
         * Listener and the trusted namespaces where those Route resources MAY be
         * present.
         *
         *
         * Although a client request may match multiple route rules, only one rule
         * may ultimately receive the request. Matching precedence MUST be
         * determined in order of the following criteria:
         *
         *
         * * The most specific match as defined by the Route type.
         * * The oldest Route based on creation timestamp. For example, a Route with
         *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
         *   a Route with a creation timestamp of "2020-09-08 01:02:04".
         * * If everything else is equivalent, the Route appearing first in
         *   alphabetical order (namespace/name) should be given precedence. For
         *   example, foo/bar is given precedence over foo/baz.
         *
         *
         * All valid rules within a Route attached to this Listener should be
         * implemented. Invalid Route rules can be ignored (sometimes that will mean
         * the full Route). If a Route rule transitions from valid to invalid,
         * support for that Route rule should be dropped to ensure consistency. For
         * example, even if a filter specified by a Route rule is invalid, the rest
         * of the rules within that Route should still be supported.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutes {
            /**
             * Kinds specifies the groups and kinds of Routes that are allowed to bind
             * to this Gateway Listener. When unspecified or empty, the kinds of Routes
             * selected are determined using the Listener protocol.
             *
             *
             * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
             * with the application protocol specified in the Listener's Protocol field.
             * If an implementation does not support or recognize this resource type, it
             * MUST set the "ResolvedRefs" condition to False for this Listener with the
             * "InvalidRouteKinds" reason.
             *
             *
             * Support: Core
             */
            kinds?: outputs.gateway.v1.GatewaySpecListenersAllowedRoutesKinds[];
            /**
             * Namespaces indicates namespaces from which Routes may be attached to this
             * Listener. This is restricted to the namespace of this Gateway by default.
             *
             *
             * Support: Core
             */
            namespaces?: outputs.gateway.v1.GatewaySpecListenersAllowedRoutesNamespaces;
        }
        /**
         * gatewaySpecListenersAllowedRoutesProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutes
         */
        export function gatewaySpecListenersAllowedRoutesProvideDefaults(val: GatewaySpecListenersAllowedRoutes): GatewaySpecListenersAllowedRoutes {
            return {
                ...val,
                namespaces: (val.namespaces ? outputs.gateway.v1.gatewaySpecListenersAllowedRoutesNamespacesProvideDefaults(val.namespaces) : undefined),
            };
        }

        /**
         * RouteGroupKind indicates the group and kind of a Route resource.
         */
        export interface GatewaySpecListenersAllowedRoutesKinds {
            /**
             * Group is the group of the Route.
             */
            group?: string;
            /**
             * Kind is the kind of the Route.
             */
            kind: string;
        }
        /**
         * gatewaySpecListenersAllowedRoutesKindsProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesKinds
         */
        export function gatewaySpecListenersAllowedRoutesKindsProvideDefaults(val: GatewaySpecListenersAllowedRoutesKinds): GatewaySpecListenersAllowedRoutesKinds {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
            };
        }

        /**
         * Namespaces indicates namespaces from which Routes may be attached to this
         * Listener. This is restricted to the namespace of this Gateway by default.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesNamespaces {
            /**
             * From indicates where Routes will be selected for this Gateway. Possible
             * values are:
             *
             *
             * * All: Routes in all namespaces may be used by this Gateway.
             * * Selector: Routes in namespaces selected by the selector may be used by
             *   this Gateway.
             * * Same: Only Routes in the same namespace may be used by this Gateway.
             *
             *
             * Support: Core
             */
            from?: string;
            /**
             * Selector must be specified when From is set to "Selector". In that case,
             * only Routes in Namespaces matching this Selector will be selected by this
             * Gateway. This field is ignored for other values of "From".
             *
             *
             * Support: Core
             */
            selector?: outputs.gateway.v1.GatewaySpecListenersAllowedRoutesNamespacesSelector;
        }
        /**
         * gatewaySpecListenersAllowedRoutesNamespacesProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesNamespaces
         */
        export function gatewaySpecListenersAllowedRoutesNamespacesProvideDefaults(val: GatewaySpecListenersAllowedRoutesNamespaces): GatewaySpecListenersAllowedRoutesNamespaces {
            return {
                ...val,
                from: (val.from) ?? "Same",
            };
        }

        /**
         * Selector must be specified when From is set to "Selector". In that case,
         * only Routes in Namespaces matching this Selector will be selected by this
         * Gateway. This field is ignored for other values of "From".
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.gateway.v1.GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[];
        }

        /**
         * TLS is the TLS configuration for the Listener. This field is required if
         * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
         * if the Protocol field is "HTTP", "TCP", or "UDP".
         *
         *
         * The association of SNIs to Certificate defined in GatewayTLSConfig is
         * defined based on the Hostname field for this listener.
         *
         *
         * The GatewayClass MUST use the longest matching SNI out of all
         * available certificates for any TLS handshake.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersTls {
            /**
             * CertificateRefs contains a series of references to Kubernetes objects that
             * contains TLS certificates and private keys. These certificates are used to
             * establish a TLS handshake for requests that match the hostname of the
             * associated listener.
             *
             *
             * A single CertificateRef to a Kubernetes Secret has "Core" support.
             * Implementations MAY choose to support attaching multiple certificates to
             * a Listener, but this behavior is implementation-specific.
             *
             *
             * References to a resource in different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached. If a ReferenceGrant does not allow this reference, the
             * "ResolvedRefs" condition MUST be set to False for this listener with the
             * "RefNotPermitted" reason.
             *
             *
             * This field is required to have at least one element when the mode is set
             * to "Terminate" (default) and is optional otherwise.
             *
             *
             * CertificateRefs can reference to standard Kubernetes resources, i.e.
             * Secret, or implementation-specific custom resources.
             *
             *
             * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
             *
             *
             * Support: Implementation-specific (More than one reference or other resource types)
             */
            certificateRefs?: outputs.gateway.v1.GatewaySpecListenersTlsCertificateRefs[];
            /**
             * FrontendValidation holds configuration information for validating the frontend (client).
             * Setting this field will require clients to send a client certificate
             * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
             * that requests a user to specify the client certificate.
             * The maximum depth of a certificate chain accepted in verification is Implementation specific.
             *
             *
             * Support: Extended
             */
            frontendValidation?: outputs.gateway.v1.GatewaySpecListenersTlsFrontendValidation;
            /**
             * Mode defines the TLS behavior for the TLS session initiated by the client.
             * There are two possible modes:
             *
             *
             * - Terminate: The TLS session between the downstream client and the
             *   Gateway is terminated at the Gateway. This mode requires certificates
             *   to be specified in some way, such as populating the certificateRefs
             *   field.
             * - Passthrough: The TLS session is NOT terminated by the Gateway. This
             *   implies that the Gateway can't decipher the TLS stream except for
             *   the ClientHello message of the TLS protocol. The certificateRefs field
             *   is ignored in this mode.
             *
             *
             * Support: Core
             */
            mode?: string;
            /**
             * Options are a list of key/value pairs to enable extended TLS
             * configuration for each implementation. For example, configuring the
             * minimum TLS version or supported cipher suites.
             *
             *
             * A set of common keys MAY be defined by the API in the future. To avoid
             * any ambiguity, implementation-specific definitions MUST use
             * domain-prefixed names, such as `example.com/my-custom-option`.
             * Un-prefixed names are reserved for key names defined by Gateway API.
             *
             *
             * Support: Implementation-specific
             */
            options?: {[key: string]: string};
        }
        /**
         * gatewaySpecListenersTlsProvideDefaults sets the appropriate defaults for GatewaySpecListenersTls
         */
        export function gatewaySpecListenersTlsProvideDefaults(val: GatewaySpecListenersTls): GatewaySpecListenersTls {
            return {
                ...val,
                mode: (val.mode) ?? "Terminate",
            };
        }

        /**
         * SecretObjectReference identifies an API object including its namespace,
         * defaulting to Secret.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface GatewaySpecListenersTlsCertificateRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
        }
        /**
         * gatewaySpecListenersTlsCertificateRefsProvideDefaults sets the appropriate defaults for GatewaySpecListenersTlsCertificateRefs
         */
        export function gatewaySpecListenersTlsCertificateRefsProvideDefaults(val: GatewaySpecListenersTlsCertificateRefs): GatewaySpecListenersTlsCertificateRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Secret",
            };
        }

        /**
         * FrontendValidation holds configuration information for validating the frontend (client).
         * Setting this field will require clients to send a client certificate
         * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
         * that requests a user to specify the client certificate.
         * The maximum depth of a certificate chain accepted in verification is Implementation specific.
         *
         *
         * Support: Extended
         */
        export interface GatewaySpecListenersTlsFrontendValidation {
            /**
             * CACertificateRefs contains one or more references to
             * Kubernetes objects that contain TLS certificates of
             * the Certificate Authorities that can be used
             * as a trust anchor to validate the certificates presented by the client.
             *
             *
             * A single CA certificate reference to a Kubernetes ConfigMap
             * has "Core" support.
             * Implementations MAY choose to support attaching multiple CA certificates to
             * a Listener, but this behavior is implementation-specific.
             *
             *
             * Support: Core - A single reference to a Kubernetes ConfigMap
             * with the CA certificate in a key named `ca.crt`.
             *
             *
             * Support: Implementation-specific (More than one reference, or other kinds
             * of resources).
             *
             *
             * References to a resource in a different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached. If a ReferenceGrant does not allow this reference, the
             * "ResolvedRefs" condition MUST be set to False for this listener with the
             * "RefNotPermitted" reason.
             */
            caCertificateRefs?: outputs.gateway.v1.GatewaySpecListenersTlsFrontendValidationCaCertificateRefs[];
        }

        /**
         * ObjectReference identifies an API object including its namespace.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface GatewaySpecListenersTlsFrontendValidationCaCertificateRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "ConfigMap" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
        }

        /**
         * Status defines the current state of Gateway.
         */
        export interface GatewayStatus {
            /**
             * Addresses lists the network addresses that have been bound to the
             * Gateway.
             *
             *
             * This list may differ from the addresses provided in the spec under some
             * conditions:
             *
             *
             *   * no addresses are specified, all addresses are dynamically assigned
             *   * a combination of specified and dynamic addresses are assigned
             *   * a specified address was unusable (e.g. already in use)
             */
            addresses?: any[];
            /**
             * Conditions describe the current conditions of the Gateway.
             *
             *
             * Implementations should prefer to express Gateway conditions
             * using the `GatewayConditionType` and `GatewayConditionReason`
             * constants so that operators and tools can converge on a common
             * vocabulary to describe Gateway state.
             *
             *
             * Known condition types are:
             *
             *
             * * "Accepted"
             * * "Programmed"
             * * "Ready"
             */
            conditions?: outputs.gateway.v1.GatewayStatusConditions[];
            /**
             * Listeners provide status for each unique listener port defined in the Spec.
             */
            listeners?: outputs.gateway.v1.GatewayStatusListeners[];
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ListenerStatus is the status associated with a Listener.
         */
        export interface GatewayStatusListeners {
            /**
             * AttachedRoutes represents the total number of Routes that have been
             * successfully attached to this Listener.
             *
             *
             * Successful attachment of a Route to a Listener is based solely on the
             * combination of the AllowedRoutes field on the corresponding Listener
             * and the Route's ParentRefs field. A Route is successfully attached to
             * a Listener when it is selected by the Listener's AllowedRoutes field
             * AND the Route has a valid ParentRef selecting the whole Gateway
             * resource or a specific Listener as a parent resource (more detail on
             * attachment semantics can be found in the documentation on the various
             * Route kinds ParentRefs fields). Listener or Route status does not impact
             * successful attachment, i.e. the AttachedRoutes field count MUST be set
             * for Listeners with condition Accepted: false and MUST count successfully
             * attached Routes that may themselves have Accepted: false conditions.
             *
             *
             * Uses for this field include troubleshooting Route attachment and
             * measuring blast radius/impact of changes to a Listener.
             */
            attachedRoutes: number;
            /**
             * Conditions describe the current condition of this listener.
             */
            conditions: outputs.gateway.v1.GatewayStatusListenersConditions[];
            /**
             * Name is the name of the Listener that this status corresponds to.
             */
            name: string;
            /**
             * SupportedKinds is the list indicating the Kinds supported by this
             * listener. This MUST represent the kinds an implementation supports for
             * that Listener configuration.
             *
             *
             * If kinds are specified in Spec that are not supported, they MUST NOT
             * appear in this list and an implementation MUST set the "ResolvedRefs"
             * condition to "False" with the "InvalidRouteKinds" reason. If both valid
             * and invalid Route kinds are specified, the implementation MUST
             * reference the valid Route kinds that have been specified.
             */
            supportedKinds: outputs.gateway.v1.GatewayStatusListenersSupportedKinds[];
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayStatusListenersConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * RouteGroupKind indicates the group and kind of a Route resource.
         */
        export interface GatewayStatusListenersSupportedKinds {
            /**
             * Group is the group of the Route.
             */
            group?: string;
            /**
             * Kind is the kind of the Route.
             */
            kind: string;
        }
        /**
         * gatewayStatusListenersSupportedKindsProvideDefaults sets the appropriate defaults for GatewayStatusListenersSupportedKinds
         */
        export function gatewayStatusListenersSupportedKindsProvideDefaults(val: GatewayStatusListenersSupportedKinds): GatewayStatusListenersSupportedKinds {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
            };
        }

        /**
         * Spec defines the desired state of HTTPRoute.
         */
        export interface HTTPRouteSpec {
            /**
             * Hostnames defines a set of hostnames that should match against the HTTP Host
             * header to select a HTTPRoute used to process the request. Implementations
             * MUST ignore any port value specified in the HTTP Host header while
             * performing a match and (absent of any applicable header modification
             * configuration) MUST forward this header unmodified to the backend.
             *
             *
             * Valid values for Hostnames are determined by RFC 1123 definition of a
             * hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label must appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and HTTPRoute, there
             * must be at least one intersecting hostname for the HTTPRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches HTTPRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches HTTPRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
             *   all match. On the other hand, `example.com` and `test.example.net` would
             *   not match.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * If both the Listener and HTTPRoute have specified hostnames, any
             * HTTPRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * HTTPRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` must not be considered for a match.
             *
             *
             * If both the Listener and HTTPRoute have specified hostnames, and none
             * match with the criteria above, then the HTTPRoute is not accepted. The
             * implementation must raise an 'Accepted' Condition with a status of
             * `False` in the corresponding RouteParentStatus.
             *
             *
             * In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
             * overlapping wildcard matching and exact matching hostnames), precedence must
             * be given to rules from the HTTPRoute with the largest number of:
             *
             *
             * * Characters in a matching non-wildcard hostname.
             * * Characters in a matching hostname.
             *
             *
             * If ties exist across multiple Routes, the matching precedence rules for
             * HTTPRouteMatches takes over.
             *
             *
             * Support: Core
             */
            hostnames?: string[];
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: outputs.gateway.v1.HTTPRouteSpecParentRefs[];
            /**
             * Rules are a list of HTTP matchers, filters and actions.
             */
            rules?: outputs.gateway.v1.HTTPRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface HTTPRouteSpecParentRefs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * httprouteSpecParentRefsProvideDefaults sets the appropriate defaults for HTTPRouteSpecParentRefs
         */
        export function httprouteSpecParentRefsProvideDefaults(val: HTTPRouteSpecParentRefs): HTTPRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * HTTPRouteRule defines semantics for matching an HTTP request based on
         * conditions (matches), processing it (filters), and forwarding the request to
         * an API object (backendRefs).
         */
        export interface HTTPRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent.
             *
             *
             * Failure behavior here depends on how many BackendRefs are specified and
             * how many are invalid.
             *
             *
             * If *all* entries in BackendRefs are invalid, and there are also no filters
             * specified in this route rule, *all* traffic which matches this rule MUST
             * receive a 500 status code.
             *
             *
             * See the HTTPBackendRef definition for the rules about what makes a single
             * HTTPBackendRef invalid.
             *
             *
             * When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
             * requests that would have otherwise been routed to an invalid backend. If
             * multiple backends are specified, and some are invalid, the proportion of
             * requests that would otherwise have been routed to an invalid backend
             * MUST receive a 500 status code.
             *
             *
             * For example, if two backends are specified with equal weights, and one is
             * invalid, 50 percent of traffic must receive a 500. Implementations may
             * choose how that 50 percent is determined.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Core
             */
            backendRefs?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefs[];
            /**
             * Filters define the filters that are applied to requests that match
             * this rule.
             *
             *
             * Wherever possible, implementations SHOULD implement filters in the order
             * they are specified.
             *
             *
             * Implementations MAY choose to implement this ordering strictly, rejecting
             * any combination or order of filters that can not be supported. If implementations
             * choose a strict interpretation of filter ordering, they MUST clearly document
             * that behavior.
             *
             *
             * To reject an invalid combination or order of filters, implementations SHOULD
             * consider the Route Rules with this configuration invalid. If all Route Rules
             * in a Route are invalid, the entire Route would be considered invalid. If only
             * a portion of Route Rules are invalid, implementations MUST set the
             * "PartiallyInvalid" condition for the Route.
             *
             *
             * Conformance-levels at this level are defined based on the type of filter:
             *
             *
             * - ALL core filters MUST be supported by all implementations.
             * - Implementers are encouraged to support extended filters.
             * - Implementation-specific custom filters have no API guarantees across
             *   implementations.
             *
             *
             * Specifying the same filter multiple times is not supported unless explicitly
             * indicated in the filter.
             *
             *
             * All filters are expected to be compatible with each other except for the
             * URLRewrite and RequestRedirect filters, which may not be combined. If an
             * implementation can not support other combinations of filters, they must clearly
             * document that limitation. In cases where incompatible or unsupported
             * filters are specified and cause the `Accepted` condition to be set to status
             * `False`, implementations may use the `IncompatibleFilters` reason to specify
             * this configuration error.
             *
             *
             * Support: Core
             */
            filters?: outputs.gateway.v1.HTTPRouteSpecRulesFilters[];
            /**
             * Matches define conditions used for matching the rule against incoming
             * HTTP requests. Each match is independent, i.e. this rule will be matched
             * if **any** one of the matches is satisfied.
             *
             *
             * For example, take the following matches configuration:
             *
             *
             * ```
             * matches:
             * - path:
             *     value: "/foo"
             *   headers:
             *   - name: "version"
             *     value: "v2"
             * - path:
             *     value: "/v2/foo"
             * ```
             *
             *
             * For a request to match against this rule, a request must satisfy
             * EITHER of the two conditions:
             *
             *
             * - path prefixed with `/foo` AND contains the header `version: v2`
             * - path prefix of `/v2/foo`
             *
             *
             * See the documentation for HTTPRouteMatch on how to specify multiple
             * match conditions that should be ANDed together.
             *
             *
             * If no matches are specified, the default is a prefix
             * path match on "/", which has the effect of matching every
             * HTTP request.
             *
             *
             * Proxy or Load Balancer routing configuration generated from HTTPRoutes
             * MUST prioritize matches based on the following criteria, continuing on
             * ties. Across all rules specified on applicable Routes, precedence must be
             * given to the match having:
             *
             *
             * * "Exact" path match.
             * * "Prefix" path match with largest number of characters.
             * * Method match.
             * * Largest number of header matches.
             * * Largest number of query param matches.
             *
             *
             * Note: The precedence of RegularExpression path matches are implementation-specific.
             *
             *
             * If ties still exist across multiple Routes, matching precedence MUST be
             * determined in order of the following criteria, continuing on ties:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * If ties still exist within an HTTPRoute, matching precedence MUST be granted
             * to the FIRST matching rule (in list order) with a match meeting the above
             * criteria.
             *
             *
             * When no rules matching a request have been successfully attached to the
             * parent a request is coming from, a HTTP 404 status code MUST be returned.
             */
            matches?: outputs.gateway.v1.HTTPRouteSpecRulesMatches[];
            /**
             * SessionPersistence defines and configures session persistence
             * for the route rule.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: outputs.gateway.v1.HTTPRouteSpecRulesSessionPersistence;
            /**
             * Timeouts defines the timeouts that can be configured for an HTTP request.
             *
             *
             * Support: Extended
             */
            timeouts?: outputs.gateway.v1.HTTPRouteSpecRulesTimeouts;
        }
        /**
         * httprouteSpecRulesProvideDefaults sets the appropriate defaults for HTTPRouteSpecRules
         */
        export function httprouteSpecRulesProvideDefaults(val: HTTPRouteSpecRules): HTTPRouteSpecRules {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? outputs.gateway.v1.httprouteSpecRulesSessionPersistenceProvideDefaults(val.sessionPersistence) : undefined),
            };
        }

        /**
         * HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         */
        export interface HTTPRouteSpecRulesBackendRefs {
            /**
             * Filters defined at this level should be executed if and only if the
             * request is being forwarded to the backend defined here.
             *
             *
             * Support: Implementation-specific (For broader support of filters, use the
             * Filters field in HTTPRouteRule.)
             */
            filters?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFilters[];
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * httprouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefs
         */
        export function httprouteSpecRulesBackendRefsProvideDefaults(val: HTTPRouteSpecRulesBackendRefs): HTTPRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * HTTPRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. HTTPRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface HTTPRouteSpecRulesBackendRefsFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * This filter can be used multiple times within the same rule.
             *
             *
             * Support: Implementation-specific
             */
            extensionRef?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestMirror;
            /**
             * RequestRedirect defines a schema for a filter that responds to the
             * request with an HTTP redirection.
             *
             *
             * Support: Core
             */
            requestRedirect?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations must support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by
             *   specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` should be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
            /**
             * URLRewrite defines a schema for a filter that modifies a request during forwarding.
             *
             *
             * Support: Extended
             */
            urlRewrite?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFilters
         */
        export function httprouteSpecRulesBackendRefsFiltersProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFilters): HTTPRouteSpecRulesBackendRefsFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1.httprouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
                requestRedirect: (val.requestRedirect ? outputs.gateway.v1.httprouteSpecRulesBackendRefsFiltersRequestRedirectProvideDefaults(val.requestRedirect) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * This filter can be used multiple times within the same rule.
         *
         *
         * Support: Implementation-specific
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirror
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestMirror): HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1.httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef): HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * RequestRedirect defines a schema for a filter that responds to the
         * request with an HTTP redirection.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             *
             *
             * Support: Core
             */
            hostname?: string;
            /**
             * Path defines parameters used to modify the path of the incoming request.
             * The modified path is then used to construct the `Location` header. When
             * empty, the request path is used as-is.
             *
             *
             * Support: Extended
             */
            path?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             *
             * If no port is specified, the redirect port MUST be derived using the
             * following rules:
             *
             *
             * * If redirect scheme is not-empty, the redirect port MUST be the well-known
             *   port associated with the redirect scheme. Specifically "http" to port 80
             *   and "https" to port 443. If the redirect scheme does not have a
             *   well-known port, the listener port of the Gateway SHOULD be used.
             * * If redirect scheme is empty, the redirect port MUST be the Gateway
             *   Listener port.
             *
             *
             * Implementations SHOULD NOT add the port number in the 'Location'
             * header in the following cases:
             *
             *
             * * A Location header that will use HTTP (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 80.
             * * A Location header that will use HTTPS (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 443.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             *
             *
             * Scheme redirects can affect the port of the redirect, for more information,
             * refer to the documentation for the port field of this filter.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Extended
             */
            scheme?: string;
            /**
             * StatusCode is the HTTP status code to be used in response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Core
             */
            statusCode?: number;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestRedirectProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestRedirectProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect): HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
            return {
                ...val,
                statusCode: (val.statusCode) ?? 302,
            };
        }

        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: string;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: string;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * URLRewrite defines a schema for a filter that modifies a request during forwarding.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
            /**
             * Hostname is the value to be used to replace the Host header value during
             * forwarding.
             *
             *
             * Support: Extended
             */
            hostname?: string;
            /**
             * Path defines a path rewrite.
             *
             *
             * Support: Extended
             */
            path?: outputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath;
        }

        /**
         * Path defines a path rewrite.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: string;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: string;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
        }

        /**
         * HTTPRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. HTTPRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface HTTPRouteSpecRulesFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * This filter can be used multiple times within the same rule.
             *
             *
             * Support: Implementation-specific
             */
            extensionRef?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestMirror;
            /**
             * RequestRedirect defines a schema for a filter that responds to the
             * request with an HTTP redirection.
             *
             *
             * Support: Core
             */
            requestRedirect?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestRedirect;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations must support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by
             *   specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` should be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
            /**
             * URLRewrite defines a schema for a filter that modifies a request during forwarding.
             *
             *
             * Support: Extended
             */
            urlRewrite?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersUrlRewrite;
        }
        /**
         * httprouteSpecRulesFiltersProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFilters
         */
        export function httprouteSpecRulesFiltersProvideDefaults(val: HTTPRouteSpecRulesFilters): HTTPRouteSpecRulesFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1.httprouteSpecRulesFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
                requestRedirect: (val.requestRedirect ? outputs.gateway.v1.httprouteSpecRulesFiltersRequestRedirectProvideDefaults(val.requestRedirect) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * This filter can be used multiple times within the same rule.
         *
         *
         * Support: Implementation-specific
         */
        export interface HTTPRouteSpecRulesFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestMirrorBackendRef;
        }
        /**
         * httprouteSpecRulesFiltersRequestMirrorProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirror
         */
        export function httprouteSpecRulesFiltersRequestMirrorProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestMirror): HTTPRouteSpecRulesFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1.httprouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
        }
        /**
         * httprouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorBackendRef
         */
        export function httprouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestMirrorBackendRef): HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * RequestRedirect defines a schema for a filter that responds to the
         * request with an HTTP redirection.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesFiltersRequestRedirect {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             *
             *
             * Support: Core
             */
            hostname?: string;
            /**
             * Path defines parameters used to modify the path of the incoming request.
             * The modified path is then used to construct the `Location` header. When
             * empty, the request path is used as-is.
             *
             *
             * Support: Extended
             */
            path?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestRedirectPath;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             *
             * If no port is specified, the redirect port MUST be derived using the
             * following rules:
             *
             *
             * * If redirect scheme is not-empty, the redirect port MUST be the well-known
             *   port associated with the redirect scheme. Specifically "http" to port 80
             *   and "https" to port 443. If the redirect scheme does not have a
             *   well-known port, the listener port of the Gateway SHOULD be used.
             * * If redirect scheme is empty, the redirect port MUST be the Gateway
             *   Listener port.
             *
             *
             * Implementations SHOULD NOT add the port number in the 'Location'
             * header in the following cases:
             *
             *
             * * A Location header that will use HTTP (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 80.
             * * A Location header that will use HTTPS (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 443.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             *
             *
             * Scheme redirects can affect the port of the redirect, for more information,
             * refer to the documentation for the port field of this filter.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Extended
             */
            scheme?: string;
            /**
             * StatusCode is the HTTP status code to be used in response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Core
             */
            statusCode?: number;
        }
        /**
         * httprouteSpecRulesFiltersRequestRedirectProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestRedirect
         */
        export function httprouteSpecRulesFiltersRequestRedirectProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestRedirect): HTTPRouteSpecRulesFiltersRequestRedirect {
            return {
                ...val,
                statusCode: (val.statusCode) ?? 302,
            };
        }

        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersRequestRedirectPath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: string;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: string;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * URLRewrite defines a schema for a filter that modifies a request during forwarding.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersUrlRewrite {
            /**
             * Hostname is the value to be used to replace the Host header value during
             * forwarding.
             *
             *
             * Support: Extended
             */
            hostname?: string;
            /**
             * Path defines a path rewrite.
             *
             *
             * Support: Extended
             */
            path?: outputs.gateway.v1.HTTPRouteSpecRulesFiltersUrlRewritePath;
        }

        /**
         * Path defines a path rewrite.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersUrlRewritePath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: string;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: string;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
        }

        /**
         * HTTPRouteMatch defines the predicate used to match requests to a given
         * action. Multiple match types are ANDed together, i.e. the match will
         * evaluate to true only if all conditions are satisfied.
         *
         *
         * For example, the match below will match a HTTP request only if its path
         * starts with `/foo` AND it contains the `version: v1` header:
         *
         *
         * ```
         * match:
         *
         *
         * 	path:
         * 	  value: "/foo"
         * 	headers:
         * 	- name: "version"
         * 	  value "v1"
         *
         *
         * ```
         */
        export interface HTTPRouteSpecRulesMatches {
            /**
             * Headers specifies HTTP request header matchers. Multiple match values are
             * ANDed together, meaning, a request must match all the specified headers
             * to select the route.
             */
            headers?: outputs.gateway.v1.HTTPRouteSpecRulesMatchesHeaders[];
            /**
             * Method specifies HTTP method matcher.
             * When specified, this route will be matched only if the request has the
             * specified method.
             *
             *
             * Support: Extended
             */
            method?: string;
            /**
             * Path specifies a HTTP request path matcher. If this field is not
             * specified, a default prefix match on the "/" path is provided.
             */
            path?: outputs.gateway.v1.HTTPRouteSpecRulesMatchesPath;
            /**
             * QueryParams specifies HTTP query parameter matchers. Multiple match
             * values are ANDed together, meaning, a request must match all the
             * specified query parameters to select the route.
             *
             *
             * Support: Extended
             */
            queryParams?: outputs.gateway.v1.HTTPRouteSpecRulesMatchesQueryParams[];
        }
        /**
         * httprouteSpecRulesMatchesProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatches
         */
        export function httprouteSpecRulesMatchesProvideDefaults(val: HTTPRouteSpecRulesMatches): HTTPRouteSpecRulesMatches {
            return {
                ...val,
                path: (val.path ? outputs.gateway.v1.httprouteSpecRulesMatchesPathProvideDefaults(val.path) : undefined),
            };
        }

        /**
         * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
         * headers.
         */
        export interface HTTPRouteSpecRulesMatchesHeaders {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             *
             *
             * When a header is repeated in an HTTP request, it is
             * implementation-specific behavior as to how this is represented.
             * Generally, proxies should follow the guidance from the RFC:
             * https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
             * processing a repeated header, with special handling for "Set-Cookie".
             */
            name: string;
            /**
             * Type specifies how to match against the value of the header.
             *
             *
             * Support: Core (Exact)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             *
             *
             * Since RegularExpression HeaderMatchType has implementation-specific
             * conformance, implementations can support POSIX, PCRE or any other dialects
             * of regular expressions. Please read the implementation's documentation to
             * determine the supported dialect.
             */
            type?: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }
        /**
         * httprouteSpecRulesMatchesHeadersProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesHeaders
         */
        export function httprouteSpecRulesMatchesHeadersProvideDefaults(val: HTTPRouteSpecRulesMatchesHeaders): HTTPRouteSpecRulesMatchesHeaders {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Path specifies a HTTP request path matcher. If this field is not
         * specified, a default prefix match on the "/" path is provided.
         */
        export interface HTTPRouteSpecRulesMatchesPath {
            /**
             * Type specifies how to match against the path Value.
             *
             *
             * Support: Core (Exact, PathPrefix)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             */
            type?: string;
            /**
             * Value of the HTTP path to match against.
             */
            value?: string;
        }
        /**
         * httprouteSpecRulesMatchesPathProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesPath
         */
        export function httprouteSpecRulesMatchesPathProvideDefaults(val: HTTPRouteSpecRulesMatchesPath): HTTPRouteSpecRulesMatchesPath {
            return {
                ...val,
                type: (val.type) ?? "PathPrefix",
                value: (val.value) ?? "/",
            };
        }

        /**
         * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
         * query parameters.
         */
        export interface HTTPRouteSpecRulesMatchesQueryParams {
            /**
             * Name is the name of the HTTP query param to be matched. This must be an
             * exact string match. (See
             * https://tools.ietf.org/html/rfc7230#section-2.7.3).
             *
             *
             * If multiple entries specify equivalent query param names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent query param name MUST be ignored.
             *
             *
             * If a query param is repeated in an HTTP request, the behavior is
             * purposely left undefined, since different data planes have different
             * capabilities. However, it is *recommended* that implementations should
             * match against the first value of the param if the data plane supports it,
             * as this behavior is expected in other load balancing contexts outside of
             * the Gateway API.
             *
             *
             * Users SHOULD NOT route traffic based on repeated query params to guard
             * themselves against potential differences in the implementations.
             */
            name: string;
            /**
             * Type specifies how to match against the value of the query parameter.
             *
             *
             * Support: Extended (Exact)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             *
             *
             * Since RegularExpression QueryParamMatchType has Implementation-specific
             * conformance, implementations can support POSIX, PCRE or any other
             * dialects of regular expressions. Please read the implementation's
             * documentation to determine the supported dialect.
             */
            type?: string;
            /**
             * Value is the value of HTTP query param to be matched.
             */
            value: string;
        }
        /**
         * httprouteSpecRulesMatchesQueryParamsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesQueryParams
         */
        export function httprouteSpecRulesMatchesQueryParamsProvideDefaults(val: HTTPRouteSpecRulesMatchesQueryParams): HTTPRouteSpecRulesMatchesQueryParams {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the route rule.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesSessionPersistence {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: string;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: outputs.gateway.v1.HTTPRouteSpecRulesSessionPersistenceCookieConfig;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: string;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: string;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: string;
        }
        /**
         * httprouteSpecRulesSessionPersistenceProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesSessionPersistence
         */
        export function httprouteSpecRulesSessionPersistenceProvideDefaults(val: HTTPRouteSpecRulesSessionPersistence): HTTPRouteSpecRulesSessionPersistence {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? outputs.gateway.v1.httprouteSpecRulesSessionPersistenceCookieConfigProvideDefaults(val.cookieConfig) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesSessionPersistenceCookieConfig {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: string;
        }
        /**
         * httprouteSpecRulesSessionPersistenceCookieConfigProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesSessionPersistenceCookieConfig
         */
        export function httprouteSpecRulesSessionPersistenceCookieConfigProvideDefaults(val: HTTPRouteSpecRulesSessionPersistenceCookieConfig): HTTPRouteSpecRulesSessionPersistenceCookieConfig {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * Timeouts defines the timeouts that can be configured for an HTTP request.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesTimeouts {
            /**
             * BackendRequest specifies a timeout for an individual request from the gateway
             * to a backend. This covers the time from when the request first starts being
             * sent from the gateway to when the full response has been received from the backend.
             *
             *
             * Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
             * completely. Implementations that cannot completely disable the timeout MUST
             * instead interpret the zero duration as the longest possible value to which
             * the timeout can be set.
             *
             *
             * An entire client HTTP transaction with a gateway, covered by the Request timeout,
             * may result in more than one call from the gateway to the destination backend,
             * for example, if automatic retries are supported.
             *
             *
             * Because the Request timeout encompasses the BackendRequest timeout, the value of
             * BackendRequest must be <= the value of Request timeout.
             *
             *
             * Support: Extended
             */
            backendRequest?: string;
            /**
             * Request specifies the maximum duration for a gateway to respond to an HTTP request.
             * If the gateway has not been able to respond before this deadline is met, the gateway
             * MUST return a timeout error.
             *
             *
             * For example, setting the `rules.timeouts.request` field to the value `10s` in an
             * `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
             * to complete.
             *
             *
             * Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
             * completely. Implementations that cannot completely disable the timeout MUST
             * instead interpret the zero duration as the longest possible value to which
             * the timeout can be set.
             *
             *
             * This timeout is intended to cover as close to the whole request-response transaction
             * as possible although an implementation MAY choose to start the timeout after the entire
             * request stream has been received instead of immediately after the transaction is
             * initiated by the client.
             *
             *
             * When this field is unspecified, request timeout behavior is implementation-specific.
             *
             *
             * Support: Extended
             */
            request?: string;
        }

        /**
         * Status defines the current state of HTTPRoute.
         */
        export interface HTTPRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1.HTTPRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface HTTPRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1.HTTPRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1.HTTPRouteStatusParentsParentRef;
        }
        /**
         * httprouteStatusParentsProvideDefaults sets the appropriate defaults for HTTPRouteStatusParents
         */
        export function httprouteStatusParentsProvideDefaults(val: HTTPRouteStatusParents): HTTPRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1.httprouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface HTTPRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface HTTPRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * httprouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for HTTPRouteStatusParentsParentRef
         */
        export function httprouteStatusParentsParentRefProvideDefaults(val: HTTPRouteStatusParentsParentRef): HTTPRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

    }

    export namespace v1alpha2 {
        /**
         * Spec defines the desired state of BackendLBPolicy.
         */
        export interface BackendLBPolicySpec {
            /**
             * SessionPersistence defines and configures session persistence
             * for the backend.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: outputs.gateway.v1alpha2.BackendLBPolicySpecSessionPersistence;
            /**
             * TargetRef identifies an API object to apply policy to.
             * Currently, Backends (i.e. Service, ServiceImport, or any
             * implementation-specific backendRef) are the only valid API
             * target references.
             */
            targetRefs: outputs.gateway.v1alpha2.BackendLBPolicySpecTargetRefs[];
        }
        /**
         * backendLBPolicySpecProvideDefaults sets the appropriate defaults for BackendLBPolicySpec
         */
        export function backendLBPolicySpecProvideDefaults(val: BackendLBPolicySpec): BackendLBPolicySpec {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? outputs.gateway.v1alpha2.backendLBPolicySpecSessionPersistenceProvideDefaults(val.sessionPersistence) : undefined),
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the backend.
         *
         *
         * Support: Extended
         */
        export interface BackendLBPolicySpecSessionPersistence {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: string;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: outputs.gateway.v1alpha2.BackendLBPolicySpecSessionPersistenceCookieConfig;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: string;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: string;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: string;
        }
        /**
         * backendLBPolicySpecSessionPersistenceProvideDefaults sets the appropriate defaults for BackendLBPolicySpecSessionPersistence
         */
        export function backendLBPolicySpecSessionPersistenceProvideDefaults(val: BackendLBPolicySpecSessionPersistence): BackendLBPolicySpecSessionPersistence {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? outputs.gateway.v1alpha2.backendLBPolicySpecSessionPersistenceCookieConfigProvideDefaults(val.cookieConfig) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface BackendLBPolicySpecSessionPersistenceCookieConfig {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: string;
        }
        /**
         * backendLBPolicySpecSessionPersistenceCookieConfigProvideDefaults sets the appropriate defaults for BackendLBPolicySpecSessionPersistenceCookieConfig
         */
        export function backendLBPolicySpecSessionPersistenceCookieConfigProvideDefaults(val: BackendLBPolicySpecSessionPersistenceCookieConfig): BackendLBPolicySpecSessionPersistenceCookieConfig {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * LocalPolicyTargetReference identifies an API object to apply a direct or
         * inherited policy to. This should be used as part of Policy resources
         * that can target Gateway API resources. For more information on how this
         * policy attachment model works, and a sample Policy resource, refer to
         * the policy attachment documentation for Gateway API.
         */
        export interface BackendLBPolicySpecTargetRefs {
            /**
             * Group is the group of the target resource.
             */
            group: string;
            /**
             * Kind is kind of the target resource.
             */
            kind: string;
            /**
             * Name is the name of the target resource.
             */
            name: string;
        }

        /**
         * Status defines the current state of BackendLBPolicy.
         */
        export interface BackendLBPolicyStatus {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors: outputs.gateway.v1alpha2.BackendLBPolicyStatusAncestors[];
        }

        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        export interface BackendLBPolicyStatusAncestors {
            /**
             * AncestorRef corresponds with a ParentRef in the spec that this
             * PolicyAncestorStatus struct describes the status of.
             */
            ancestorRef: outputs.gateway.v1alpha2.BackendLBPolicyStatusAncestorsAncestorRef;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: outputs.gateway.v1alpha2.BackendLBPolicyStatusAncestorsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
        }
        /**
         * backendLBPolicyStatusAncestorsProvideDefaults sets the appropriate defaults for BackendLBPolicyStatusAncestors
         */
        export function backendLBPolicyStatusAncestorsProvideDefaults(val: BackendLBPolicyStatusAncestors): BackendLBPolicyStatusAncestors {
            return {
                ...val,
                ancestorRef: outputs.gateway.v1alpha2.backendLBPolicyStatusAncestorsAncestorRefProvideDefaults(val.ancestorRef),
            };
        }

        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        export interface BackendLBPolicyStatusAncestorsAncestorRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * backendLBPolicyStatusAncestorsAncestorRefProvideDefaults sets the appropriate defaults for BackendLBPolicyStatusAncestorsAncestorRef
         */
        export function backendLBPolicyStatusAncestorsAncestorRefProvideDefaults(val: BackendLBPolicyStatusAncestorsAncestorRef): BackendLBPolicyStatusAncestorsAncestorRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface BackendLBPolicyStatusAncestorsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * Spec defines the desired state of GRPCRoute.
         */
        export interface GRPCRouteSpec {
            /**
             * Hostnames defines a set of hostnames to match against the GRPC
             * Host header to select a GRPCRoute to process the request. This matches
             * the RFC 1123 definition of a hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label MUST appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and GRPCRoute, there
             * MUST be at least one intersecting hostname for the GRPCRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches GRPCRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches GRPCRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `test.example.com` and `*.example.com` would both match. On the other
             *   hand, `example.com` and `test.example.net` would not match.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * If both the Listener and GRPCRoute have specified hostnames, any
             * GRPCRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * GRPCRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` MUST NOT be considered for a match.
             *
             *
             * If both the Listener and GRPCRoute have specified hostnames, and none
             * match with the criteria above, then the GRPCRoute MUST NOT be accepted by
             * the implementation. The implementation MUST raise an 'Accepted' Condition
             * with a status of `False` in the corresponding RouteParentStatus.
             *
             *
             * If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
             * Listener and that listener already has another Route (B) of the other
             * type attached and the intersection of the hostnames of A and B is
             * non-empty, then the implementation MUST accept exactly one of these two
             * routes, determined by the following criteria, in order:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * The rejected Route MUST raise an 'Accepted' condition with a status of
             * 'False' in the corresponding RouteParentStatus.
             *
             *
             * Support: Core
             */
            hostnames?: string[];
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: outputs.gateway.v1alpha2.GRPCRouteSpecParentRefs[];
            /**
             * Rules are a list of GRPC matchers, filters and actions.
             */
            rules?: outputs.gateway.v1alpha2.GRPCRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface GRPCRouteSpecParentRefs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * grpcrouteSpecParentRefsProvideDefaults sets the appropriate defaults for GRPCRouteSpecParentRefs
         */
        export function grpcrouteSpecParentRefsProvideDefaults(val: GRPCRouteSpecParentRefs): GRPCRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * GRPCRouteRule defines the semantics for matching a gRPC request based on
         * conditions (matches), processing it (filters), and forwarding the request to
         * an API object (backendRefs).
         */
        export interface GRPCRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent.
             *
             *
             * Failure behavior here depends on how many BackendRefs are specified and
             * how many are invalid.
             *
             *
             * If *all* entries in BackendRefs are invalid, and there are also no filters
             * specified in this route rule, *all* traffic which matches this rule MUST
             * receive an `UNAVAILABLE` status.
             *
             *
             * See the GRPCBackendRef definition for the rules about what makes a single
             * GRPCBackendRef invalid.
             *
             *
             * When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
             * requests that would have otherwise been routed to an invalid backend. If
             * multiple backends are specified, and some are invalid, the proportion of
             * requests that would otherwise have been routed to an invalid backend
             * MUST receive an `UNAVAILABLE` status.
             *
             *
             * For example, if two backends are specified with equal weights, and one is
             * invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
             * Implementations may choose how that 50 percent is determined.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Core
             */
            backendRefs?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefs[];
            /**
             * Filters define the filters that are applied to requests that match
             * this rule.
             *
             *
             * The effects of ordering of multiple behaviors are currently unspecified.
             * This can change in the future based on feedback during the alpha stage.
             *
             *
             * Conformance-levels at this level are defined based on the type of filter:
             *
             *
             * - ALL core filters MUST be supported by all implementations that support
             *   GRPCRoute.
             * - Implementers are encouraged to support extended filters.
             * - Implementation-specific custom filters have no API guarantees across
             *   implementations.
             *
             *
             * Specifying the same filter multiple times is not supported unless explicitly
             * indicated in the filter.
             *
             *
             * If an implementation can not support a combination of filters, it must clearly
             * document that limitation. In cases where incompatible or unsupported
             * filters are specified and cause the `Accepted` condition to be set to status
             * `False`, implementations may use the `IncompatibleFilters` reason to specify
             * this configuration error.
             *
             *
             * Support: Core
             */
            filters?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFilters[];
            /**
             * Matches define conditions used for matching the rule against incoming
             * gRPC requests. Each match is independent, i.e. this rule will be matched
             * if **any** one of the matches is satisfied.
             *
             *
             * For example, take the following matches configuration:
             *
             *
             * ```
             * matches:
             * - method:
             *     service: foo.bar
             *   headers:
             *     values:
             *       version: 2
             * - method:
             *     service: foo.bar.v2
             * ```
             *
             *
             * For a request to match against this rule, it MUST satisfy
             * EITHER of the two conditions:
             *
             *
             * - service of foo.bar AND contains the header `version: 2`
             * - service of foo.bar.v2
             *
             *
             * See the documentation for GRPCRouteMatch on how to specify multiple
             * match conditions to be ANDed together.
             *
             *
             * If no matches are specified, the implementation MUST match every gRPC request.
             *
             *
             * Proxy or Load Balancer routing configuration generated from GRPCRoutes
             * MUST prioritize rules based on the following criteria, continuing on
             * ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
             * Precedence MUST be given to the rule with the largest number of:
             *
             *
             * * Characters in a matching non-wildcard hostname.
             * * Characters in a matching hostname.
             * * Characters in a matching service.
             * * Characters in a matching method.
             * * Header matches.
             *
             *
             * If ties still exist across multiple Routes, matching precedence MUST be
             * determined in order of the following criteria, continuing on ties:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * If ties still exist within the Route that has been given precedence,
             * matching precedence MUST be granted to the first matching rule meeting
             * the above criteria.
             */
            matches?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesMatches[];
            /**
             * SessionPersistence defines and configures session persistence
             * for the route rule.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesSessionPersistence;
        }
        /**
         * grpcrouteSpecRulesProvideDefaults sets the appropriate defaults for GRPCRouteSpecRules
         */
        export function grpcrouteSpecRulesProvideDefaults(val: GRPCRouteSpecRules): GRPCRouteSpecRules {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? outputs.gateway.v1alpha2.grpcrouteSpecRulesSessionPersistenceProvideDefaults(val.sessionPersistence) : undefined),
            };
        }

        /**
         * GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         */
        export interface GRPCRouteSpecRulesBackendRefs {
            /**
             * Filters defined at this level MUST be executed if and only if the
             * request is being forwarded to the backend defined here.
             *
             *
             * Support: Implementation-specific (For broader support of filters, use the
             * Filters field in GRPCRouteRule.)
             */
            filters?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFilters[];
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * grpcrouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefs
         */
        export function grpcrouteSpecRulesBackendRefsProvideDefaults(val: GRPCRouteSpecRulesBackendRefs): GRPCRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. GRPCRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesBackendRefsFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * Support: Implementation-specific
             *
             *
             * This filter can be used multiple times within the same rule.
             */
            extensionRef?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestMirror;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations supporting GRPCRoute MUST support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` MUST be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             */
            type: string;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFilters
         */
        export function grpcrouteSpecRulesBackendRefsFiltersProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFilters): GRPCRouteSpecRulesBackendRefsFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1alpha2.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * Support: Implementation-specific
         *
         *
         * This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirror
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirror): GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1alpha2.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef): GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. GRPCRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * Support: Implementation-specific
             *
             *
             * This filter can be used multiple times within the same rule.
             */
            extensionRef?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestMirror;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations supporting GRPCRoute MUST support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` MUST be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             */
            type: string;
        }
        /**
         * grpcrouteSpecRulesFiltersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFilters
         */
        export function grpcrouteSpecRulesFiltersProvideDefaults(val: GRPCRouteSpecRulesFilters): GRPCRouteSpecRulesFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1alpha2.grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * Support: Implementation-specific
         *
         *
         * This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestMirrorBackendRef;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirror
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirror): GRPCRouteSpecRulesFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1alpha2.grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRef
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirrorBackendRef): GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * GRPCRouteMatch defines the predicate used to match requests to a given
         * action. Multiple match types are ANDed together, i.e. the match will
         * evaluate to true only if all conditions are satisfied.
         *
         *
         * For example, the match below will match a gRPC request only if its service
         * is `foo` AND it contains the `version: v1` header:
         *
         *
         * ```
         * matches:
         *   - method:
         *     type: Exact
         *     service: "foo"
         *     headers:
         *   - name: "version"
         *     value "v1"
         *
         *
         * ```
         */
        export interface GRPCRouteSpecRulesMatches {
            /**
             * Headers specifies gRPC request header matchers. Multiple match values are
             * ANDed together, meaning, a request MUST match all the specified headers
             * to select the route.
             */
            headers?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesMatchesHeaders[];
            /**
             * Method specifies a gRPC request service/method matcher. If this field is
             * not specified, all services and methods will match.
             */
            method?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesMatchesMethod;
        }
        /**
         * grpcrouteSpecRulesMatchesProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatches
         */
        export function grpcrouteSpecRulesMatchesProvideDefaults(val: GRPCRouteSpecRulesMatches): GRPCRouteSpecRulesMatches {
            return {
                ...val,
                method: (val.method ? outputs.gateway.v1alpha2.grpcrouteSpecRulesMatchesMethodProvideDefaults(val.method) : undefined),
            };
        }

        /**
         * GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
         * headers.
         */
        export interface GRPCRouteSpecRulesMatchesHeaders {
            /**
             * Name is the name of the gRPC Header to be matched.
             *
             *
             * If multiple entries specify equivalent header names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: string;
            /**
             * Value is the value of the gRPC Header to be matched.
             */
            value: string;
        }
        /**
         * grpcrouteSpecRulesMatchesHeadersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeaders
         */
        export function grpcrouteSpecRulesMatchesHeadersProvideDefaults(val: GRPCRouteSpecRulesMatchesHeaders): GRPCRouteSpecRulesMatchesHeaders {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Method specifies a gRPC request service/method matcher. If this field is
         * not specified, all services and methods will match.
         */
        export interface GRPCRouteSpecRulesMatchesMethod {
            /**
             * Value of the method to match against. If left empty or omitted, will
             * match all services.
             *
             *
             * At least one of Service and Method MUST be a non-empty string.
             */
            method?: string;
            /**
             * Value of the service to match against. If left empty or omitted, will
             * match any service.
             *
             *
             * At least one of Service and Method MUST be a non-empty string.
             */
            service?: string;
            /**
             * Type specifies how to match against the service and/or method.
             * Support: Core (Exact with service and method specified)
             *
             *
             * Support: Implementation-specific (Exact with method specified but no service specified)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             */
            type?: string;
        }
        /**
         * grpcrouteSpecRulesMatchesMethodProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethod
         */
        export function grpcrouteSpecRulesMatchesMethodProvideDefaults(val: GRPCRouteSpecRulesMatchesMethod): GRPCRouteSpecRulesMatchesMethod {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the route rule.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesSessionPersistence {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: string;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesSessionPersistenceCookieConfig;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: string;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: string;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: string;
        }
        /**
         * grpcrouteSpecRulesSessionPersistenceProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesSessionPersistence
         */
        export function grpcrouteSpecRulesSessionPersistenceProvideDefaults(val: GRPCRouteSpecRulesSessionPersistence): GRPCRouteSpecRulesSessionPersistence {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? outputs.gateway.v1alpha2.grpcrouteSpecRulesSessionPersistenceCookieConfigProvideDefaults(val.cookieConfig) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesSessionPersistenceCookieConfig {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: string;
        }
        /**
         * grpcrouteSpecRulesSessionPersistenceCookieConfigProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesSessionPersistenceCookieConfig
         */
        export function grpcrouteSpecRulesSessionPersistenceCookieConfigProvideDefaults(val: GRPCRouteSpecRulesSessionPersistenceCookieConfig): GRPCRouteSpecRulesSessionPersistenceCookieConfig {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * Status defines the current state of GRPCRoute.
         */
        export interface GRPCRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1alpha2.GRPCRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface GRPCRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1alpha2.GRPCRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1alpha2.GRPCRouteStatusParentsParentRef;
        }
        /**
         * grpcrouteStatusParentsProvideDefaults sets the appropriate defaults for GRPCRouteStatusParents
         */
        export function grpcrouteStatusParentsProvideDefaults(val: GRPCRouteStatusParents): GRPCRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1alpha2.grpcrouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GRPCRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface GRPCRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * grpcrouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for GRPCRouteStatusParentsParentRef
         */
        export function grpcrouteStatusParentsParentRefProvideDefaults(val: GRPCRouteStatusParentsParentRef): GRPCRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of ReferenceGrant.
         */
        export interface ReferenceGrantSpec {
            /**
             * From describes the trusted namespaces and kinds that can reference the
             * resources described in "To". Each entry in this list MUST be considered
             * to be an additional place that references can be valid from, or to put
             * this another way, entries MUST be combined using OR.
             *
             *
             * Support: Core
             */
            from: outputs.gateway.v1alpha2.ReferenceGrantSpecFrom[];
            /**
             * To describes the resources that may be referenced by the resources
             * described in "From". Each entry in this list MUST be considered to be an
             * additional place that references can be valid to, or to put this another
             * way, entries MUST be combined using OR.
             *
             *
             * Support: Core
             */
            to: outputs.gateway.v1alpha2.ReferenceGrantSpecTo[];
        }

        /**
         * ReferenceGrantFrom describes trusted namespaces and kinds.
         */
        export interface ReferenceGrantSpecFrom {
            /**
             * Group is the group of the referent.
             * When empty, the Kubernetes core API group is inferred.
             *
             *
             * Support: Core
             */
            group: string;
            /**
             * Kind is the kind of the referent. Although implementations may support
             * additional resources, the following types are part of the "Core"
             * support level for this field.
             *
             *
             * When used to permit a SecretObjectReference:
             *
             *
             * * Gateway
             *
             *
             * When used to permit a BackendObjectReference:
             *
             *
             * * GRPCRoute
             * * HTTPRoute
             * * TCPRoute
             * * TLSRoute
             * * UDPRoute
             */
            kind: string;
            /**
             * Namespace is the namespace of the referent.
             *
             *
             * Support: Core
             */
            namespace: string;
        }

        /**
         * ReferenceGrantTo describes what Kinds are allowed as targets of the
         * references.
         */
        export interface ReferenceGrantSpecTo {
            /**
             * Group is the group of the referent.
             * When empty, the Kubernetes core API group is inferred.
             *
             *
             * Support: Core
             */
            group: string;
            /**
             * Kind is the kind of the referent. Although implementations may support
             * additional resources, the following types are part of the "Core"
             * support level for this field:
             *
             *
             * * Secret when used to permit a SecretObjectReference
             * * Service when used to permit a BackendObjectReference
             */
            kind: string;
            /**
             * Name is the name of the referent. When unspecified, this policy
             * refers to all resources of the specified Group and Kind in the local
             * namespace.
             */
            name?: string;
        }

        /**
         * Spec defines the desired state of TCPRoute.
         */
        export interface TCPRouteSpec {
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: outputs.gateway.v1alpha2.TCPRouteSpecParentRefs[];
            /**
             * Rules are a list of TCP matchers and actions.
             */
            rules: outputs.gateway.v1alpha2.TCPRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface TCPRouteSpecParentRefs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * tcprouteSpecParentRefsProvideDefaults sets the appropriate defaults for TCPRouteSpecParentRefs
         */
        export function tcprouteSpecParentRefsProvideDefaults(val: TCPRouteSpecParentRefs): TCPRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * TCPRouteRule is the configuration for a given rule.
         */
        export interface TCPRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent. If unspecified or invalid (refers to a non-existent resource or a
             * Service with no endpoints), the underlying implementation MUST actively
             * reject connection attempts to this backend. Connection rejections must
             * respect weight; if an invalid backend is requested to have 80% of
             * connections, then 80% of connections must be rejected instead.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Extended
             */
            backendRefs?: outputs.gateway.v1alpha2.TCPRouteSpecRulesBackendRefs[];
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes
         * resource.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         *
         *
         * Note that when the BackendTLSPolicy object is enabled by the implementation,
         * there are some extra rules about validity to consider here. See the fields
         * where this struct is used for more information about the exact behavior.
         */
        export interface TCPRouteSpecRulesBackendRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * tcprouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for TCPRouteSpecRulesBackendRefs
         */
        export function tcprouteSpecRulesBackendRefsProvideDefaults(val: TCPRouteSpecRulesBackendRefs): TCPRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of TCPRoute.
         */
        export interface TCPRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1alpha2.TCPRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface TCPRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1alpha2.TCPRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1alpha2.TCPRouteStatusParentsParentRef;
        }
        /**
         * tcprouteStatusParentsProvideDefaults sets the appropriate defaults for TCPRouteStatusParents
         */
        export function tcprouteStatusParentsProvideDefaults(val: TCPRouteStatusParents): TCPRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1alpha2.tcprouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface TCPRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface TCPRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * tcprouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for TCPRouteStatusParentsParentRef
         */
        export function tcprouteStatusParentsParentRefProvideDefaults(val: TCPRouteStatusParentsParentRef): TCPRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of TLSRoute.
         */
        export interface TLSRouteSpec {
            /**
             * Hostnames defines a set of SNI names that should match against the
             * SNI attribute of TLS ClientHello message in TLS handshake. This matches
             * the RFC 1123 definition of a hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed in SNI names per RFC 6066.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label must appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and TLSRoute, there
             * must be at least one intersecting hostname for the TLSRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches TLSRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches TLSRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `test.example.com` and `*.example.com` would both match. On the other
             *   hand, `example.com` and `test.example.net` would not match.
             *
             *
             * If both the Listener and TLSRoute have specified hostnames, any
             * TLSRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * TLSRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` must not be considered for a match.
             *
             *
             * If both the Listener and TLSRoute have specified hostnames, and none
             * match with the criteria above, then the TLSRoute is not accepted. The
             * implementation must raise an 'Accepted' Condition with a status of
             * `False` in the corresponding RouteParentStatus.
             *
             *
             * Support: Core
             */
            hostnames?: string[];
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: outputs.gateway.v1alpha2.TLSRouteSpecParentRefs[];
            /**
             * Rules are a list of TLS matchers and actions.
             */
            rules: outputs.gateway.v1alpha2.TLSRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface TLSRouteSpecParentRefs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * tlsrouteSpecParentRefsProvideDefaults sets the appropriate defaults for TLSRouteSpecParentRefs
         */
        export function tlsrouteSpecParentRefsProvideDefaults(val: TLSRouteSpecParentRefs): TLSRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * TLSRouteRule is the configuration for a given rule.
         */
        export interface TLSRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent. If unspecified or invalid (refers to a non-existent resource or
             * a Service with no endpoints), the rule performs no forwarding; if no
             * filters are specified that would result in a response being sent, the
             * underlying implementation must actively reject request attempts to this
             * backend, by rejecting the connection or returning a 500 status code.
             * Request rejections must respect weight; if an invalid backend is
             * requested to have 80% of requests, then 80% of requests must be rejected
             * instead.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Extended
             */
            backendRefs?: outputs.gateway.v1alpha2.TLSRouteSpecRulesBackendRefs[];
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes
         * resource.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         *
         *
         * Note that when the BackendTLSPolicy object is enabled by the implementation,
         * there are some extra rules about validity to consider here. See the fields
         * where this struct is used for more information about the exact behavior.
         */
        export interface TLSRouteSpecRulesBackendRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * tlsrouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for TLSRouteSpecRulesBackendRefs
         */
        export function tlsrouteSpecRulesBackendRefsProvideDefaults(val: TLSRouteSpecRulesBackendRefs): TLSRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of TLSRoute.
         */
        export interface TLSRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1alpha2.TLSRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface TLSRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1alpha2.TLSRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1alpha2.TLSRouteStatusParentsParentRef;
        }
        /**
         * tlsrouteStatusParentsProvideDefaults sets the appropriate defaults for TLSRouteStatusParents
         */
        export function tlsrouteStatusParentsProvideDefaults(val: TLSRouteStatusParents): TLSRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1alpha2.tlsrouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface TLSRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface TLSRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * tlsrouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for TLSRouteStatusParentsParentRef
         */
        export function tlsrouteStatusParentsParentRefProvideDefaults(val: TLSRouteStatusParentsParentRef): TLSRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of UDPRoute.
         */
        export interface UDPRouteSpec {
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: outputs.gateway.v1alpha2.UDPRouteSpecParentRefs[];
            /**
             * Rules are a list of UDP matchers and actions.
             */
            rules: outputs.gateway.v1alpha2.UDPRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface UDPRouteSpecParentRefs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * udprouteSpecParentRefsProvideDefaults sets the appropriate defaults for UDPRouteSpecParentRefs
         */
        export function udprouteSpecParentRefsProvideDefaults(val: UDPRouteSpecParentRefs): UDPRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * UDPRouteRule is the configuration for a given rule.
         */
        export interface UDPRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent. If unspecified or invalid (refers to a non-existent resource or a
             * Service with no endpoints), the underlying implementation MUST actively
             * reject connection attempts to this backend. Packet drops must
             * respect weight; if an invalid backend is requested to have 80% of
             * the packets, then 80% of packets must be dropped instead.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Extended
             */
            backendRefs?: outputs.gateway.v1alpha2.UDPRouteSpecRulesBackendRefs[];
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes
         * resource.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         *
         *
         * Note that when the BackendTLSPolicy object is enabled by the implementation,
         * there are some extra rules about validity to consider here. See the fields
         * where this struct is used for more information about the exact behavior.
         */
        export interface UDPRouteSpecRulesBackendRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * udprouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for UDPRouteSpecRulesBackendRefs
         */
        export function udprouteSpecRulesBackendRefsProvideDefaults(val: UDPRouteSpecRulesBackendRefs): UDPRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of UDPRoute.
         */
        export interface UDPRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1alpha2.UDPRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface UDPRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1alpha2.UDPRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1alpha2.UDPRouteStatusParentsParentRef;
        }
        /**
         * udprouteStatusParentsProvideDefaults sets the appropriate defaults for UDPRouteStatusParents
         */
        export function udprouteStatusParentsProvideDefaults(val: UDPRouteStatusParents): UDPRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1alpha2.udprouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface UDPRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface UDPRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * udprouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for UDPRouteStatusParentsParentRef
         */
        export function udprouteStatusParentsParentRefProvideDefaults(val: UDPRouteStatusParentsParentRef): UDPRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

    }

    export namespace v1alpha3 {
        /**
         * Spec defines the desired state of BackendTLSPolicy.
         */
        export interface BackendTLSPolicySpec {
            /**
             * TargetRefs identifies an API object to apply the policy to.
             * Only Services have Extended support. Implementations MAY support
             * additional objects, with Implementation Specific support.
             * Note that this config applies to the entire referenced resource
             * by default, but this default may change in the future to provide
             * a more granular application of the policy.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            targetRefs: outputs.gateway.v1alpha3.BackendTLSPolicySpecTargetRefs[];
            /**
             * Validation contains backend TLS validation configuration.
             */
            validation: outputs.gateway.v1alpha3.BackendTLSPolicySpecValidation;
        }

        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        export interface BackendTLSPolicySpecTargetRefs {
            /**
             * Group is the group of the target resource.
             */
            group: string;
            /**
             * Kind is kind of the target resource.
             */
            kind: string;
            /**
             * Name is the name of the target resource.
             */
            name: string;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: string;
        }

        /**
         * Validation contains backend TLS validation configuration.
         */
        export interface BackendTLSPolicySpecValidation {
            /**
             * CACertificateRefs contains one or more references to Kubernetes objects that
             * contain a PEM-encoded TLS CA certificate bundle, which is used to
             * validate a TLS handshake between the Gateway and backend Pod.
             *
             *
             * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
             * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
             * not both. If CACertifcateRefs is empty or unspecified, the configuration for
             * WellKnownCACertificates MUST be honored instead if supported by the implementation.
             *
             *
             * References to a resource in a different namespace are invalid for the
             * moment, although we will revisit this in the future.
             *
             *
             * A single CACertificateRef to a Kubernetes ConfigMap kind has "Core" support.
             * Implementations MAY choose to support attaching multiple certificates to
             * a backend, but this behavior is implementation-specific.
             *
             *
             * Support: Core - An optional single reference to a Kubernetes ConfigMap,
             * with the CA certificate in a key named `ca.crt`.
             *
             *
             * Support: Implementation-specific (More than one reference, or other kinds
             * of resources).
             */
            caCertificateRefs?: outputs.gateway.v1alpha3.BackendTLSPolicySpecValidationCaCertificateRefs[];
            /**
             * Hostname is used for two purposes in the connection between Gateways and
             * backends:
             *
             *
             * 1. Hostname MUST be used as the SNI to connect to the backend (RFC 6066).
             * 2. Hostname MUST be used for authentication and MUST match the certificate
             *    served by the matching backend.
             *
             *
             * Support: Core
             */
            hostname: string;
            /**
             * WellKnownCACertificates specifies whether system CA certificates may be used in
             * the TLS handshake between the gateway and backend pod.
             *
             *
             * If WellKnownCACertificates is unspecified or empty (""), then CACertificateRefs
             * must be specified with at least one entry for a valid configuration. Only one of
             * CACertificateRefs or WellKnownCACertificates may be specified, not both. If an
             * implementation does not support the WellKnownCACertificates field or the value
             * supplied is not supported, the Status Conditions on the Policy MUST be
             * updated to include an Accepted: False Condition with Reason: Invalid.
             *
             *
             * Support: Implementation-specific
             */
            wellKnownCACertificates?: string;
        }

        /**
         * LocalObjectReference identifies an API object within the namespace of the
         * referrer.
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface BackendTLSPolicySpecValidationCaCertificateRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * Status defines the current state of BackendTLSPolicy.
         */
        export interface BackendTLSPolicyStatus {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors: outputs.gateway.v1alpha3.BackendTLSPolicyStatusAncestors[];
        }

        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        export interface BackendTLSPolicyStatusAncestors {
            /**
             * AncestorRef corresponds with a ParentRef in the spec that this
             * PolicyAncestorStatus struct describes the status of.
             */
            ancestorRef: outputs.gateway.v1alpha3.BackendTLSPolicyStatusAncestorsAncestorRef;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: outputs.gateway.v1alpha3.BackendTLSPolicyStatusAncestorsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
        }
        /**
         * backendTLSPolicyStatusAncestorsProvideDefaults sets the appropriate defaults for BackendTLSPolicyStatusAncestors
         */
        export function backendTLSPolicyStatusAncestorsProvideDefaults(val: BackendTLSPolicyStatusAncestors): BackendTLSPolicyStatusAncestors {
            return {
                ...val,
                ancestorRef: outputs.gateway.v1alpha3.backendTLSPolicyStatusAncestorsAncestorRefProvideDefaults(val.ancestorRef),
            };
        }

        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        export interface BackendTLSPolicyStatusAncestorsAncestorRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * backendTLSPolicyStatusAncestorsAncestorRefProvideDefaults sets the appropriate defaults for BackendTLSPolicyStatusAncestorsAncestorRef
         */
        export function backendTLSPolicyStatusAncestorsAncestorRefProvideDefaults(val: BackendTLSPolicyStatusAncestorsAncestorRef): BackendTLSPolicyStatusAncestorsAncestorRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface BackendTLSPolicyStatusAncestorsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

    }

    export namespace v1beta1 {
        /**
         * Spec defines the desired state of GatewayClass.
         */
        export interface GatewayClassSpec {
            /**
             * ControllerName is the name of the controller that is managing Gateways of
             * this class. The value of this field MUST be a domain prefixed path.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * This field is not mutable and cannot be empty.
             *
             *
             * Support: Core
             */
            controllerName: string;
            /**
             * Description helps describe a GatewayClass with more details.
             */
            description?: string;
            /**
             * ParametersRef is a reference to a resource that contains the configuration
             * parameters corresponding to the GatewayClass. This is optional if the
             * controller does not require any additional configuration.
             *
             *
             * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
             * or an implementation-specific custom resource. The resource can be
             * cluster-scoped or namespace-scoped.
             *
             *
             * If the referent cannot be found, the GatewayClass's "InvalidParameters"
             * status condition will be true.
             *
             *
             * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
             * the merging behavior is implementation specific.
             * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
             *
             *
             * Support: Implementation-specific
             */
            parametersRef?: outputs.gateway.v1beta1.GatewayClassSpecParametersRef;
        }

        /**
         * ParametersRef is a reference to a resource that contains the configuration
         * parameters corresponding to the GatewayClass. This is optional if the
         * controller does not require any additional configuration.
         *
         *
         * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
         * or an implementation-specific custom resource. The resource can be
         * cluster-scoped or namespace-scoped.
         *
         *
         * If the referent cannot be found, the GatewayClass's "InvalidParameters"
         * status condition will be true.
         *
         *
         * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
         * the merging behavior is implementation specific.
         * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
         *
         *
         * Support: Implementation-specific
         */
        export interface GatewayClassSpecParametersRef {
            /**
             * Group is the group of the referent.
             */
            group: string;
            /**
             * Kind is kind of the referent.
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the referent.
             * This field is required when referring to a Namespace-scoped resource and
             * MUST be unset when referring to a Cluster-scoped resource.
             */
            namespace?: string;
        }

        /**
         * Status defines the current state of GatewayClass.
         *
         *
         * Implementations MUST populate status on all GatewayClass resources which
         * specify their controller name.
         */
        export interface GatewayClassStatus {
            /**
             * Conditions is the current status from the controller for
             * this GatewayClass.
             *
             *
             * Controllers should prefer to publish conditions using values
             * of GatewayClassConditionType for the type of each Condition.
             */
            conditions?: outputs.gateway.v1beta1.GatewayClassStatusConditions[];
            /**
             * SupportedFeatures is the set of features the GatewayClass support.
             * It MUST be sorted in ascending alphabetical order.
             */
            supportedFeatures?: string[];
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayClassStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * Spec defines the desired state of Gateway.
         */
        export interface GatewaySpec {
            /**
             * Addresses requested for this Gateway. This is optional and behavior can
             * depend on the implementation. If a value is set in the spec and the
             * requested address is invalid or unavailable, the implementation MUST
             * indicate this in the associated entry in GatewayStatus.Addresses.
             *
             *
             * The Addresses field represents a request for the address(es) on the
             * "outside of the Gateway", that traffic bound for this Gateway will use.
             * This could be the IP address or hostname of an external load balancer or
             * other networking infrastructure, or some other address that traffic will
             * be sent to.
             *
             *
             * If no Addresses are specified, the implementation MAY schedule the
             * Gateway in an implementation-specific manner, assigning an appropriate
             * set of Addresses.
             *
             *
             * The implementation MUST bind all Listeners to every GatewayAddress that
             * it assigns to the Gateway and add a corresponding entry in
             * GatewayStatus.Addresses.
             *
             *
             * Support: Extended
             */
            addresses?: any[];
            /**
             * GatewayClassName used for this Gateway. This is the name of a
             * GatewayClass resource.
             */
            gatewayClassName: string;
            /**
             * Infrastructure defines infrastructure level attributes about this Gateway instance.
             *
             *
             * Support: Core
             */
            infrastructure?: outputs.gateway.v1beta1.GatewaySpecInfrastructure;
            /**
             * Listeners associated with this Gateway. Listeners define
             * logical endpoints that are bound on this Gateway's addresses.
             * At least one Listener MUST be specified.
             *
             *
             * Each Listener in a set of Listeners (for example, in a single Gateway)
             * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
             * exactly one listener. (This section uses "set of Listeners" rather than
             * "Listeners in a single Gateway" because implementations MAY merge configuration
             * from multiple Gateways onto a single data plane, and these rules _also_
             * apply in that case).
             *
             *
             * Practically, this means that each listener in a set MUST have a unique
             * combination of Port, Protocol, and, if supported by the protocol, Hostname.
             *
             *
             * Some combinations of port, protocol, and TLS settings are considered
             * Core support and MUST be supported by implementations based on their
             * targeted conformance profile:
             *
             *
             * HTTP Profile
             *
             *
             * 1. HTTPRoute, Port: 80, Protocol: HTTP
             * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
             *
             *
             * TLS Profile
             *
             *
             * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
             *
             *
             * "Distinct" Listeners have the following property:
             *
             *
             * The implementation can match inbound requests to a single distinct
             * Listener. When multiple Listeners share values for fields (for
             * example, two Listeners with the same Port value), the implementation
             * can match requests to only one of the Listeners using other
             * Listener fields.
             *
             *
             * For example, the following Listener scenarios are distinct:
             *
             *
             * 1. Multiple Listeners with the same Port that all use the "HTTP"
             *    Protocol that all have unique Hostname values.
             * 2. Multiple Listeners with the same Port that use either the "HTTPS" or
             *    "TLS" Protocol that all have unique Hostname values.
             * 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
             *    with the same Protocol has the same Port value.
             *
             *
             * Some fields in the Listener struct have possible values that affect
             * whether the Listener is distinct. Hostname is particularly relevant
             * for HTTP or HTTPS protocols.
             *
             *
             * When using the Hostname value to select between same-Port, same-Protocol
             * Listeners, the Hostname value must be different on each Listener for the
             * Listener to be distinct.
             *
             *
             * When the Listeners are distinct based on Hostname, inbound request
             * hostnames MUST match from the most specific to least specific Hostname
             * values to choose the correct Listener and its associated set of Routes.
             *
             *
             * Exact matches must be processed before wildcard matches, and wildcard
             * matches must be processed before fallback (empty Hostname value)
             * matches. For example, `"foo.example.com"` takes precedence over
             * `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
             *
             *
             * Additionally, if there are multiple wildcard entries, more specific
             * wildcard entries must be processed before less specific wildcard entries.
             * For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
             * The precise definition here is that the higher the number of dots in the
             * hostname to the right of the wildcard character, the higher the precedence.
             *
             *
             * The wildcard character will match any number of characters _and dots_ to
             * the left, however, so `"*.example.com"` will match both
             * `"foo.bar.example.com"` _and_ `"bar.example.com"`.
             *
             *
             * If a set of Listeners contains Listeners that are not distinct, then those
             * Listeners are Conflicted, and the implementation MUST set the "Conflicted"
             * condition in the Listener Status to "True".
             *
             *
             * Implementations MAY choose to accept a Gateway with some Conflicted
             * Listeners only if they only accept the partial Listener set that contains
             * no Conflicted Listeners. To put this another way, implementations may
             * accept a partial Listener set only if they throw out *all* the conflicting
             * Listeners. No picking one of the conflicting listeners as the winner.
             * This also means that the Gateway must have at least one non-conflicting
             * Listener in this case, otherwise it violates the requirement that at
             * least one Listener must be present.
             *
             *
             * The implementation MUST set a "ListenersNotValid" condition on the
             * Gateway Status when the Gateway contains Conflicted Listeners whether or
             * not they accept the Gateway. That Condition SHOULD clearly
             * indicate in the Message which Listeners are conflicted, and which are
             * Accepted. Additionally, the Listener status for those listeners SHOULD
             * indicate which Listeners are conflicted and not Accepted.
             *
             *
             * A Gateway's Listeners are considered "compatible" if:
             *
             *
             * 1. They are distinct.
             * 2. The implementation can serve them in compliance with the Addresses
             *    requirement that all Listeners are available on all assigned
             *    addresses.
             *
             *
             * Compatible combinations in Extended support are expected to vary across
             * implementations. A combination that is compatible for one implementation
             * may not be compatible for another.
             *
             *
             * For example, an implementation that cannot serve both TCP and UDP listeners
             * on the same address, or cannot mix HTTPS and generic TLS listens on the same port
             * would not consider those cases compatible, even though they are distinct.
             *
             *
             * Note that requests SHOULD match at most one Listener. For example, if
             * Listeners are defined for "foo.example.com" and "*.example.com", a
             * request to "foo.example.com" SHOULD only be routed using routes attached
             * to the "foo.example.com" Listener (and not the "*.example.com" Listener).
             * This concept is known as "Listener Isolation". Implementations that do
             * not support Listener Isolation MUST clearly document this.
             *
             *
             * Implementations MAY merge separate Gateways onto a single set of
             * Addresses if all Listeners across all Gateways are compatible.
             *
             *
             * Support: Core
             */
            listeners: outputs.gateway.v1beta1.GatewaySpecListeners[];
        }

        /**
         * Infrastructure defines infrastructure level attributes about this Gateway instance.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecInfrastructure {
            /**
             * Annotations that SHOULD be applied to any resources created in response to this Gateway.
             *
             *
             * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
             * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
             *
             *
             * An implementation may chose to add additional implementation-specific annotations as they see fit.
             *
             *
             * Support: Extended
             */
            annotations?: {[key: string]: string};
            /**
             * Labels that SHOULD be applied to any resources created in response to this Gateway.
             *
             *
             * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
             * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
             *
             *
             * An implementation may chose to add additional implementation-specific labels as they see fit.
             *
             *
             * Support: Extended
             */
            labels?: {[key: string]: string};
            /**
             * ParametersRef is a reference to a resource that contains the configuration
             * parameters corresponding to the Gateway. This is optional if the
             * controller does not require any additional configuration.
             *
             *
             * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
             *
             *
             * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
             * the merging behavior is implementation specific.
             * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
             *
             *
             * Support: Implementation-specific
             */
            parametersRef?: outputs.gateway.v1beta1.GatewaySpecInfrastructureParametersRef;
        }

        /**
         * ParametersRef is a reference to a resource that contains the configuration
         * parameters corresponding to the Gateway. This is optional if the
         * controller does not require any additional configuration.
         *
         *
         * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
         *
         *
         * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
         * the merging behavior is implementation specific.
         * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
         *
         *
         * Support: Implementation-specific
         */
        export interface GatewaySpecInfrastructureParametersRef {
            /**
             * Group is the group of the referent.
             */
            group: string;
            /**
             * Kind is kind of the referent.
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * Listener embodies the concept of a logical endpoint where a Gateway accepts
         * network connections.
         */
        export interface GatewaySpecListeners {
            /**
             * AllowedRoutes defines the types of routes that MAY be attached to a
             * Listener and the trusted namespaces where those Route resources MAY be
             * present.
             *
             *
             * Although a client request may match multiple route rules, only one rule
             * may ultimately receive the request. Matching precedence MUST be
             * determined in order of the following criteria:
             *
             *
             * * The most specific match as defined by the Route type.
             * * The oldest Route based on creation timestamp. For example, a Route with
             *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
             *   a Route with a creation timestamp of "2020-09-08 01:02:04".
             * * If everything else is equivalent, the Route appearing first in
             *   alphabetical order (namespace/name) should be given precedence. For
             *   example, foo/bar is given precedence over foo/baz.
             *
             *
             * All valid rules within a Route attached to this Listener should be
             * implemented. Invalid Route rules can be ignored (sometimes that will mean
             * the full Route). If a Route rule transitions from valid to invalid,
             * support for that Route rule should be dropped to ensure consistency. For
             * example, even if a filter specified by a Route rule is invalid, the rest
             * of the rules within that Route should still be supported.
             *
             *
             * Support: Core
             */
            allowedRoutes?: outputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutes;
            /**
             * Hostname specifies the virtual hostname to match for protocol types that
             * define this concept. When unspecified, all hostnames are matched. This
             * field is ignored for protocols that don't require hostname based
             * matching.
             *
             *
             * Implementations MUST apply Hostname matching appropriately for each of
             * the following protocols:
             *
             *
             * * TLS: The Listener Hostname MUST match the SNI.
             * * HTTP: The Listener Hostname MUST match the Host header of the request.
             * * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
             *   protocol layers as described above. If an implementation does not
             *   ensure that both the SNI and Host header match the Listener hostname,
             *   it MUST clearly document that.
             *
             *
             * For HTTPRoute and TLSRoute resources, there is an interaction with the
             * `spec.hostnames` array. When both listener and route specify hostnames,
             * there MUST be an intersection between the values for a Route to be
             * accepted. For more information, refer to the Route specific Hostnames
             * documentation.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * Support: Core
             */
            hostname?: string;
            /**
             * Name is the name of the Listener. This name MUST be unique within a
             * Gateway.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Port is the network port. Multiple listeners may use the
             * same port, subject to the Listener compatibility rules.
             *
             *
             * Support: Core
             */
            port: number;
            /**
             * Protocol specifies the network protocol this listener expects to receive.
             *
             *
             * Support: Core
             */
            protocol: string;
            /**
             * TLS is the TLS configuration for the Listener. This field is required if
             * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
             * if the Protocol field is "HTTP", "TCP", or "UDP".
             *
             *
             * The association of SNIs to Certificate defined in GatewayTLSConfig is
             * defined based on the Hostname field for this listener.
             *
             *
             * The GatewayClass MUST use the longest matching SNI out of all
             * available certificates for any TLS handshake.
             *
             *
             * Support: Core
             */
            tls?: outputs.gateway.v1beta1.GatewaySpecListenersTls;
        }
        /**
         * gatewaySpecListenersProvideDefaults sets the appropriate defaults for GatewaySpecListeners
         */
        export function gatewaySpecListenersProvideDefaults(val: GatewaySpecListeners): GatewaySpecListeners {
            return {
                ...val,
                allowedRoutes: (val.allowedRoutes ? outputs.gateway.v1beta1.gatewaySpecListenersAllowedRoutesProvideDefaults(val.allowedRoutes) : undefined),
                tls: (val.tls ? outputs.gateway.v1beta1.gatewaySpecListenersTlsProvideDefaults(val.tls) : undefined),
            };
        }

        /**
         * AllowedRoutes defines the types of routes that MAY be attached to a
         * Listener and the trusted namespaces where those Route resources MAY be
         * present.
         *
         *
         * Although a client request may match multiple route rules, only one rule
         * may ultimately receive the request. Matching precedence MUST be
         * determined in order of the following criteria:
         *
         *
         * * The most specific match as defined by the Route type.
         * * The oldest Route based on creation timestamp. For example, a Route with
         *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
         *   a Route with a creation timestamp of "2020-09-08 01:02:04".
         * * If everything else is equivalent, the Route appearing first in
         *   alphabetical order (namespace/name) should be given precedence. For
         *   example, foo/bar is given precedence over foo/baz.
         *
         *
         * All valid rules within a Route attached to this Listener should be
         * implemented. Invalid Route rules can be ignored (sometimes that will mean
         * the full Route). If a Route rule transitions from valid to invalid,
         * support for that Route rule should be dropped to ensure consistency. For
         * example, even if a filter specified by a Route rule is invalid, the rest
         * of the rules within that Route should still be supported.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutes {
            /**
             * Kinds specifies the groups and kinds of Routes that are allowed to bind
             * to this Gateway Listener. When unspecified or empty, the kinds of Routes
             * selected are determined using the Listener protocol.
             *
             *
             * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
             * with the application protocol specified in the Listener's Protocol field.
             * If an implementation does not support or recognize this resource type, it
             * MUST set the "ResolvedRefs" condition to False for this Listener with the
             * "InvalidRouteKinds" reason.
             *
             *
             * Support: Core
             */
            kinds?: outputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesKinds[];
            /**
             * Namespaces indicates namespaces from which Routes may be attached to this
             * Listener. This is restricted to the namespace of this Gateway by default.
             *
             *
             * Support: Core
             */
            namespaces?: outputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesNamespaces;
        }
        /**
         * gatewaySpecListenersAllowedRoutesProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutes
         */
        export function gatewaySpecListenersAllowedRoutesProvideDefaults(val: GatewaySpecListenersAllowedRoutes): GatewaySpecListenersAllowedRoutes {
            return {
                ...val,
                namespaces: (val.namespaces ? outputs.gateway.v1beta1.gatewaySpecListenersAllowedRoutesNamespacesProvideDefaults(val.namespaces) : undefined),
            };
        }

        /**
         * RouteGroupKind indicates the group and kind of a Route resource.
         */
        export interface GatewaySpecListenersAllowedRoutesKinds {
            /**
             * Group is the group of the Route.
             */
            group?: string;
            /**
             * Kind is the kind of the Route.
             */
            kind: string;
        }
        /**
         * gatewaySpecListenersAllowedRoutesKindsProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesKinds
         */
        export function gatewaySpecListenersAllowedRoutesKindsProvideDefaults(val: GatewaySpecListenersAllowedRoutesKinds): GatewaySpecListenersAllowedRoutesKinds {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
            };
        }

        /**
         * Namespaces indicates namespaces from which Routes may be attached to this
         * Listener. This is restricted to the namespace of this Gateway by default.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesNamespaces {
            /**
             * From indicates where Routes will be selected for this Gateway. Possible
             * values are:
             *
             *
             * * All: Routes in all namespaces may be used by this Gateway.
             * * Selector: Routes in namespaces selected by the selector may be used by
             *   this Gateway.
             * * Same: Only Routes in the same namespace may be used by this Gateway.
             *
             *
             * Support: Core
             */
            from?: string;
            /**
             * Selector must be specified when From is set to "Selector". In that case,
             * only Routes in Namespaces matching this Selector will be selected by this
             * Gateway. This field is ignored for other values of "From".
             *
             *
             * Support: Core
             */
            selector?: outputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesNamespacesSelector;
        }
        /**
         * gatewaySpecListenersAllowedRoutesNamespacesProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesNamespaces
         */
        export function gatewaySpecListenersAllowedRoutesNamespacesProvideDefaults(val: GatewaySpecListenersAllowedRoutesNamespaces): GatewaySpecListenersAllowedRoutesNamespaces {
            return {
                ...val,
                from: (val.from) ?? "Same",
            };
        }

        /**
         * Selector must be specified when From is set to "Selector". In that case,
         * only Routes in Namespaces matching this Selector will be selected by this
         * Gateway. This field is ignored for other values of "From".
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[];
        }

        /**
         * TLS is the TLS configuration for the Listener. This field is required if
         * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
         * if the Protocol field is "HTTP", "TCP", or "UDP".
         *
         *
         * The association of SNIs to Certificate defined in GatewayTLSConfig is
         * defined based on the Hostname field for this listener.
         *
         *
         * The GatewayClass MUST use the longest matching SNI out of all
         * available certificates for any TLS handshake.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersTls {
            /**
             * CertificateRefs contains a series of references to Kubernetes objects that
             * contains TLS certificates and private keys. These certificates are used to
             * establish a TLS handshake for requests that match the hostname of the
             * associated listener.
             *
             *
             * A single CertificateRef to a Kubernetes Secret has "Core" support.
             * Implementations MAY choose to support attaching multiple certificates to
             * a Listener, but this behavior is implementation-specific.
             *
             *
             * References to a resource in different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached. If a ReferenceGrant does not allow this reference, the
             * "ResolvedRefs" condition MUST be set to False for this listener with the
             * "RefNotPermitted" reason.
             *
             *
             * This field is required to have at least one element when the mode is set
             * to "Terminate" (default) and is optional otherwise.
             *
             *
             * CertificateRefs can reference to standard Kubernetes resources, i.e.
             * Secret, or implementation-specific custom resources.
             *
             *
             * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
             *
             *
             * Support: Implementation-specific (More than one reference or other resource types)
             */
            certificateRefs?: outputs.gateway.v1beta1.GatewaySpecListenersTlsCertificateRefs[];
            /**
             * FrontendValidation holds configuration information for validating the frontend (client).
             * Setting this field will require clients to send a client certificate
             * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
             * that requests a user to specify the client certificate.
             * The maximum depth of a certificate chain accepted in verification is Implementation specific.
             *
             *
             * Support: Extended
             */
            frontendValidation?: outputs.gateway.v1beta1.GatewaySpecListenersTlsFrontendValidation;
            /**
             * Mode defines the TLS behavior for the TLS session initiated by the client.
             * There are two possible modes:
             *
             *
             * - Terminate: The TLS session between the downstream client and the
             *   Gateway is terminated at the Gateway. This mode requires certificates
             *   to be specified in some way, such as populating the certificateRefs
             *   field.
             * - Passthrough: The TLS session is NOT terminated by the Gateway. This
             *   implies that the Gateway can't decipher the TLS stream except for
             *   the ClientHello message of the TLS protocol. The certificateRefs field
             *   is ignored in this mode.
             *
             *
             * Support: Core
             */
            mode?: string;
            /**
             * Options are a list of key/value pairs to enable extended TLS
             * configuration for each implementation. For example, configuring the
             * minimum TLS version or supported cipher suites.
             *
             *
             * A set of common keys MAY be defined by the API in the future. To avoid
             * any ambiguity, implementation-specific definitions MUST use
             * domain-prefixed names, such as `example.com/my-custom-option`.
             * Un-prefixed names are reserved for key names defined by Gateway API.
             *
             *
             * Support: Implementation-specific
             */
            options?: {[key: string]: string};
        }
        /**
         * gatewaySpecListenersTlsProvideDefaults sets the appropriate defaults for GatewaySpecListenersTls
         */
        export function gatewaySpecListenersTlsProvideDefaults(val: GatewaySpecListenersTls): GatewaySpecListenersTls {
            return {
                ...val,
                mode: (val.mode) ?? "Terminate",
            };
        }

        /**
         * SecretObjectReference identifies an API object including its namespace,
         * defaulting to Secret.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface GatewaySpecListenersTlsCertificateRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
        }
        /**
         * gatewaySpecListenersTlsCertificateRefsProvideDefaults sets the appropriate defaults for GatewaySpecListenersTlsCertificateRefs
         */
        export function gatewaySpecListenersTlsCertificateRefsProvideDefaults(val: GatewaySpecListenersTlsCertificateRefs): GatewaySpecListenersTlsCertificateRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Secret",
            };
        }

        /**
         * FrontendValidation holds configuration information for validating the frontend (client).
         * Setting this field will require clients to send a client certificate
         * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
         * that requests a user to specify the client certificate.
         * The maximum depth of a certificate chain accepted in verification is Implementation specific.
         *
         *
         * Support: Extended
         */
        export interface GatewaySpecListenersTlsFrontendValidation {
            /**
             * CACertificateRefs contains one or more references to
             * Kubernetes objects that contain TLS certificates of
             * the Certificate Authorities that can be used
             * as a trust anchor to validate the certificates presented by the client.
             *
             *
             * A single CA certificate reference to a Kubernetes ConfigMap
             * has "Core" support.
             * Implementations MAY choose to support attaching multiple CA certificates to
             * a Listener, but this behavior is implementation-specific.
             *
             *
             * Support: Core - A single reference to a Kubernetes ConfigMap
             * with the CA certificate in a key named `ca.crt`.
             *
             *
             * Support: Implementation-specific (More than one reference, or other kinds
             * of resources).
             *
             *
             * References to a resource in a different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached. If a ReferenceGrant does not allow this reference, the
             * "ResolvedRefs" condition MUST be set to False for this listener with the
             * "RefNotPermitted" reason.
             */
            caCertificateRefs?: outputs.gateway.v1beta1.GatewaySpecListenersTlsFrontendValidationCaCertificateRefs[];
        }

        /**
         * ObjectReference identifies an API object including its namespace.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface GatewaySpecListenersTlsFrontendValidationCaCertificateRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "ConfigMap" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
        }

        /**
         * Status defines the current state of Gateway.
         */
        export interface GatewayStatus {
            /**
             * Addresses lists the network addresses that have been bound to the
             * Gateway.
             *
             *
             * This list may differ from the addresses provided in the spec under some
             * conditions:
             *
             *
             *   * no addresses are specified, all addresses are dynamically assigned
             *   * a combination of specified and dynamic addresses are assigned
             *   * a specified address was unusable (e.g. already in use)
             */
            addresses?: any[];
            /**
             * Conditions describe the current conditions of the Gateway.
             *
             *
             * Implementations should prefer to express Gateway conditions
             * using the `GatewayConditionType` and `GatewayConditionReason`
             * constants so that operators and tools can converge on a common
             * vocabulary to describe Gateway state.
             *
             *
             * Known condition types are:
             *
             *
             * * "Accepted"
             * * "Programmed"
             * * "Ready"
             */
            conditions?: outputs.gateway.v1beta1.GatewayStatusConditions[];
            /**
             * Listeners provide status for each unique listener port defined in the Spec.
             */
            listeners?: outputs.gateway.v1beta1.GatewayStatusListeners[];
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ListenerStatus is the status associated with a Listener.
         */
        export interface GatewayStatusListeners {
            /**
             * AttachedRoutes represents the total number of Routes that have been
             * successfully attached to this Listener.
             *
             *
             * Successful attachment of a Route to a Listener is based solely on the
             * combination of the AllowedRoutes field on the corresponding Listener
             * and the Route's ParentRefs field. A Route is successfully attached to
             * a Listener when it is selected by the Listener's AllowedRoutes field
             * AND the Route has a valid ParentRef selecting the whole Gateway
             * resource or a specific Listener as a parent resource (more detail on
             * attachment semantics can be found in the documentation on the various
             * Route kinds ParentRefs fields). Listener or Route status does not impact
             * successful attachment, i.e. the AttachedRoutes field count MUST be set
             * for Listeners with condition Accepted: false and MUST count successfully
             * attached Routes that may themselves have Accepted: false conditions.
             *
             *
             * Uses for this field include troubleshooting Route attachment and
             * measuring blast radius/impact of changes to a Listener.
             */
            attachedRoutes: number;
            /**
             * Conditions describe the current condition of this listener.
             */
            conditions: outputs.gateway.v1beta1.GatewayStatusListenersConditions[];
            /**
             * Name is the name of the Listener that this status corresponds to.
             */
            name: string;
            /**
             * SupportedKinds is the list indicating the Kinds supported by this
             * listener. This MUST represent the kinds an implementation supports for
             * that Listener configuration.
             *
             *
             * If kinds are specified in Spec that are not supported, they MUST NOT
             * appear in this list and an implementation MUST set the "ResolvedRefs"
             * condition to "False" with the "InvalidRouteKinds" reason. If both valid
             * and invalid Route kinds are specified, the implementation MUST
             * reference the valid Route kinds that have been specified.
             */
            supportedKinds: outputs.gateway.v1beta1.GatewayStatusListenersSupportedKinds[];
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayStatusListenersConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * RouteGroupKind indicates the group and kind of a Route resource.
         */
        export interface GatewayStatusListenersSupportedKinds {
            /**
             * Group is the group of the Route.
             */
            group?: string;
            /**
             * Kind is the kind of the Route.
             */
            kind: string;
        }
        /**
         * gatewayStatusListenersSupportedKindsProvideDefaults sets the appropriate defaults for GatewayStatusListenersSupportedKinds
         */
        export function gatewayStatusListenersSupportedKindsProvideDefaults(val: GatewayStatusListenersSupportedKinds): GatewayStatusListenersSupportedKinds {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
            };
        }

        /**
         * Spec defines the desired state of HTTPRoute.
         */
        export interface HTTPRouteSpec {
            /**
             * Hostnames defines a set of hostnames that should match against the HTTP Host
             * header to select a HTTPRoute used to process the request. Implementations
             * MUST ignore any port value specified in the HTTP Host header while
             * performing a match and (absent of any applicable header modification
             * configuration) MUST forward this header unmodified to the backend.
             *
             *
             * Valid values for Hostnames are determined by RFC 1123 definition of a
             * hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label must appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and HTTPRoute, there
             * must be at least one intersecting hostname for the HTTPRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches HTTPRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches HTTPRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
             *   all match. On the other hand, `example.com` and `test.example.net` would
             *   not match.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * If both the Listener and HTTPRoute have specified hostnames, any
             * HTTPRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * HTTPRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` must not be considered for a match.
             *
             *
             * If both the Listener and HTTPRoute have specified hostnames, and none
             * match with the criteria above, then the HTTPRoute is not accepted. The
             * implementation must raise an 'Accepted' Condition with a status of
             * `False` in the corresponding RouteParentStatus.
             *
             *
             * In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
             * overlapping wildcard matching and exact matching hostnames), precedence must
             * be given to rules from the HTTPRoute with the largest number of:
             *
             *
             * * Characters in a matching non-wildcard hostname.
             * * Characters in a matching hostname.
             *
             *
             * If ties exist across multiple Routes, the matching precedence rules for
             * HTTPRouteMatches takes over.
             *
             *
             * Support: Core
             */
            hostnames?: string[];
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: outputs.gateway.v1beta1.HTTPRouteSpecParentRefs[];
            /**
             * Rules are a list of HTTP matchers, filters and actions.
             */
            rules?: outputs.gateway.v1beta1.HTTPRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface HTTPRouteSpecParentRefs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * httprouteSpecParentRefsProvideDefaults sets the appropriate defaults for HTTPRouteSpecParentRefs
         */
        export function httprouteSpecParentRefsProvideDefaults(val: HTTPRouteSpecParentRefs): HTTPRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * HTTPRouteRule defines semantics for matching an HTTP request based on
         * conditions (matches), processing it (filters), and forwarding the request to
         * an API object (backendRefs).
         */
        export interface HTTPRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent.
             *
             *
             * Failure behavior here depends on how many BackendRefs are specified and
             * how many are invalid.
             *
             *
             * If *all* entries in BackendRefs are invalid, and there are also no filters
             * specified in this route rule, *all* traffic which matches this rule MUST
             * receive a 500 status code.
             *
             *
             * See the HTTPBackendRef definition for the rules about what makes a single
             * HTTPBackendRef invalid.
             *
             *
             * When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
             * requests that would have otherwise been routed to an invalid backend. If
             * multiple backends are specified, and some are invalid, the proportion of
             * requests that would otherwise have been routed to an invalid backend
             * MUST receive a 500 status code.
             *
             *
             * For example, if two backends are specified with equal weights, and one is
             * invalid, 50 percent of traffic must receive a 500. Implementations may
             * choose how that 50 percent is determined.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Core
             */
            backendRefs?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefs[];
            /**
             * Filters define the filters that are applied to requests that match
             * this rule.
             *
             *
             * Wherever possible, implementations SHOULD implement filters in the order
             * they are specified.
             *
             *
             * Implementations MAY choose to implement this ordering strictly, rejecting
             * any combination or order of filters that can not be supported. If implementations
             * choose a strict interpretation of filter ordering, they MUST clearly document
             * that behavior.
             *
             *
             * To reject an invalid combination or order of filters, implementations SHOULD
             * consider the Route Rules with this configuration invalid. If all Route Rules
             * in a Route are invalid, the entire Route would be considered invalid. If only
             * a portion of Route Rules are invalid, implementations MUST set the
             * "PartiallyInvalid" condition for the Route.
             *
             *
             * Conformance-levels at this level are defined based on the type of filter:
             *
             *
             * - ALL core filters MUST be supported by all implementations.
             * - Implementers are encouraged to support extended filters.
             * - Implementation-specific custom filters have no API guarantees across
             *   implementations.
             *
             *
             * Specifying the same filter multiple times is not supported unless explicitly
             * indicated in the filter.
             *
             *
             * All filters are expected to be compatible with each other except for the
             * URLRewrite and RequestRedirect filters, which may not be combined. If an
             * implementation can not support other combinations of filters, they must clearly
             * document that limitation. In cases where incompatible or unsupported
             * filters are specified and cause the `Accepted` condition to be set to status
             * `False`, implementations may use the `IncompatibleFilters` reason to specify
             * this configuration error.
             *
             *
             * Support: Core
             */
            filters?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFilters[];
            /**
             * Matches define conditions used for matching the rule against incoming
             * HTTP requests. Each match is independent, i.e. this rule will be matched
             * if **any** one of the matches is satisfied.
             *
             *
             * For example, take the following matches configuration:
             *
             *
             * ```
             * matches:
             * - path:
             *     value: "/foo"
             *   headers:
             *   - name: "version"
             *     value: "v2"
             * - path:
             *     value: "/v2/foo"
             * ```
             *
             *
             * For a request to match against this rule, a request must satisfy
             * EITHER of the two conditions:
             *
             *
             * - path prefixed with `/foo` AND contains the header `version: v2`
             * - path prefix of `/v2/foo`
             *
             *
             * See the documentation for HTTPRouteMatch on how to specify multiple
             * match conditions that should be ANDed together.
             *
             *
             * If no matches are specified, the default is a prefix
             * path match on "/", which has the effect of matching every
             * HTTP request.
             *
             *
             * Proxy or Load Balancer routing configuration generated from HTTPRoutes
             * MUST prioritize matches based on the following criteria, continuing on
             * ties. Across all rules specified on applicable Routes, precedence must be
             * given to the match having:
             *
             *
             * * "Exact" path match.
             * * "Prefix" path match with largest number of characters.
             * * Method match.
             * * Largest number of header matches.
             * * Largest number of query param matches.
             *
             *
             * Note: The precedence of RegularExpression path matches are implementation-specific.
             *
             *
             * If ties still exist across multiple Routes, matching precedence MUST be
             * determined in order of the following criteria, continuing on ties:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * If ties still exist within an HTTPRoute, matching precedence MUST be granted
             * to the FIRST matching rule (in list order) with a match meeting the above
             * criteria.
             *
             *
             * When no rules matching a request have been successfully attached to the
             * parent a request is coming from, a HTTP 404 status code MUST be returned.
             */
            matches?: outputs.gateway.v1beta1.HTTPRouteSpecRulesMatches[];
            /**
             * SessionPersistence defines and configures session persistence
             * for the route rule.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: outputs.gateway.v1beta1.HTTPRouteSpecRulesSessionPersistence;
            /**
             * Timeouts defines the timeouts that can be configured for an HTTP request.
             *
             *
             * Support: Extended
             */
            timeouts?: outputs.gateway.v1beta1.HTTPRouteSpecRulesTimeouts;
        }
        /**
         * httprouteSpecRulesProvideDefaults sets the appropriate defaults for HTTPRouteSpecRules
         */
        export function httprouteSpecRulesProvideDefaults(val: HTTPRouteSpecRules): HTTPRouteSpecRules {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? outputs.gateway.v1beta1.httprouteSpecRulesSessionPersistenceProvideDefaults(val.sessionPersistence) : undefined),
            };
        }

        /**
         * HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         */
        export interface HTTPRouteSpecRulesBackendRefs {
            /**
             * Filters defined at this level should be executed if and only if the
             * request is being forwarded to the backend defined here.
             *
             *
             * Support: Implementation-specific (For broader support of filters, use the
             * Filters field in HTTPRouteRule.)
             */
            filters?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFilters[];
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * httprouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefs
         */
        export function httprouteSpecRulesBackendRefsProvideDefaults(val: HTTPRouteSpecRulesBackendRefs): HTTPRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * HTTPRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. HTTPRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface HTTPRouteSpecRulesBackendRefsFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * This filter can be used multiple times within the same rule.
             *
             *
             * Support: Implementation-specific
             */
            extensionRef?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestMirror;
            /**
             * RequestRedirect defines a schema for a filter that responds to the
             * request with an HTTP redirection.
             *
             *
             * Support: Core
             */
            requestRedirect?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations must support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by
             *   specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` should be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
            /**
             * URLRewrite defines a schema for a filter that modifies a request during forwarding.
             *
             *
             * Support: Extended
             */
            urlRewrite?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFilters
         */
        export function httprouteSpecRulesBackendRefsFiltersProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFilters): HTTPRouteSpecRulesBackendRefsFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1beta1.httprouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
                requestRedirect: (val.requestRedirect ? outputs.gateway.v1beta1.httprouteSpecRulesBackendRefsFiltersRequestRedirectProvideDefaults(val.requestRedirect) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * This filter can be used multiple times within the same rule.
         *
         *
         * Support: Implementation-specific
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirror
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestMirror): HTTPRouteSpecRulesBackendRefsFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1beta1.httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef): HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * RequestRedirect defines a schema for a filter that responds to the
         * request with an HTTP redirection.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             *
             *
             * Support: Core
             */
            hostname?: string;
            /**
             * Path defines parameters used to modify the path of the incoming request.
             * The modified path is then used to construct the `Location` header. When
             * empty, the request path is used as-is.
             *
             *
             * Support: Extended
             */
            path?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             *
             * If no port is specified, the redirect port MUST be derived using the
             * following rules:
             *
             *
             * * If redirect scheme is not-empty, the redirect port MUST be the well-known
             *   port associated with the redirect scheme. Specifically "http" to port 80
             *   and "https" to port 443. If the redirect scheme does not have a
             *   well-known port, the listener port of the Gateway SHOULD be used.
             * * If redirect scheme is empty, the redirect port MUST be the Gateway
             *   Listener port.
             *
             *
             * Implementations SHOULD NOT add the port number in the 'Location'
             * header in the following cases:
             *
             *
             * * A Location header that will use HTTP (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 80.
             * * A Location header that will use HTTPS (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 443.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             *
             *
             * Scheme redirects can affect the port of the redirect, for more information,
             * refer to the documentation for the port field of this filter.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Extended
             */
            scheme?: string;
            /**
             * StatusCode is the HTTP status code to be used in response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Core
             */
            statusCode?: number;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestRedirectProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestRedirectProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect): HTTPRouteSpecRulesBackendRefsFiltersRequestRedirect {
            return {
                ...val,
                statusCode: (val.statusCode) ?? 302,
            };
        }

        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: string;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: string;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * URLRewrite defines a schema for a filter that modifies a request during forwarding.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersUrlRewrite {
            /**
             * Hostname is the value to be used to replace the Host header value during
             * forwarding.
             *
             *
             * Support: Extended
             */
            hostname?: string;
            /**
             * Path defines a path rewrite.
             *
             *
             * Support: Extended
             */
            path?: outputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath;
        }

        /**
         * Path defines a path rewrite.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: string;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: string;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
        }

        /**
         * HTTPRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. HTTPRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface HTTPRouteSpecRulesFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * This filter can be used multiple times within the same rule.
             *
             *
             * Support: Implementation-specific
             */
            extensionRef?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestMirror;
            /**
             * RequestRedirect defines a schema for a filter that responds to the
             * request with an HTTP redirection.
             *
             *
             * Support: Core
             */
            requestRedirect?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestRedirect;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations must support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by
             *   specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` should be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
            /**
             * URLRewrite defines a schema for a filter that modifies a request during forwarding.
             *
             *
             * Support: Extended
             */
            urlRewrite?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersUrlRewrite;
        }
        /**
         * httprouteSpecRulesFiltersProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFilters
         */
        export function httprouteSpecRulesFiltersProvideDefaults(val: HTTPRouteSpecRulesFilters): HTTPRouteSpecRulesFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1beta1.httprouteSpecRulesFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
                requestRedirect: (val.requestRedirect ? outputs.gateway.v1beta1.httprouteSpecRulesFiltersRequestRedirectProvideDefaults(val.requestRedirect) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * This filter can be used multiple times within the same rule.
         *
         *
         * Support: Implementation-specific
         */
        export interface HTTPRouteSpecRulesFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestMirrorBackendRef;
        }
        /**
         * httprouteSpecRulesFiltersRequestMirrorProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirror
         */
        export function httprouteSpecRulesFiltersRequestMirrorProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestMirror): HTTPRouteSpecRulesFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1beta1.httprouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: number;
        }
        /**
         * httprouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorBackendRef
         */
        export function httprouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestMirrorBackendRef): HTTPRouteSpecRulesFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * RequestRedirect defines a schema for a filter that responds to the
         * request with an HTTP redirection.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesFiltersRequestRedirect {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             *
             *
             * Support: Core
             */
            hostname?: string;
            /**
             * Path defines parameters used to modify the path of the incoming request.
             * The modified path is then used to construct the `Location` header. When
             * empty, the request path is used as-is.
             *
             *
             * Support: Extended
             */
            path?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestRedirectPath;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             *
             * If no port is specified, the redirect port MUST be derived using the
             * following rules:
             *
             *
             * * If redirect scheme is not-empty, the redirect port MUST be the well-known
             *   port associated with the redirect scheme. Specifically "http" to port 80
             *   and "https" to port 443. If the redirect scheme does not have a
             *   well-known port, the listener port of the Gateway SHOULD be used.
             * * If redirect scheme is empty, the redirect port MUST be the Gateway
             *   Listener port.
             *
             *
             * Implementations SHOULD NOT add the port number in the 'Location'
             * header in the following cases:
             *
             *
             * * A Location header that will use HTTP (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 80.
             * * A Location header that will use HTTPS (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 443.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             *
             *
             * Scheme redirects can affect the port of the redirect, for more information,
             * refer to the documentation for the port field of this filter.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Extended
             */
            scheme?: string;
            /**
             * StatusCode is the HTTP status code to be used in response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Core
             */
            statusCode?: number;
        }
        /**
         * httprouteSpecRulesFiltersRequestRedirectProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestRedirect
         */
        export function httprouteSpecRulesFiltersRequestRedirectProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestRedirect): HTTPRouteSpecRulesFiltersRequestRedirect {
            return {
                ...val,
                statusCode: (val.statusCode) ?? 302,
            };
        }

        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersRequestRedirectPath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: string;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: string;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * URLRewrite defines a schema for a filter that modifies a request during forwarding.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersUrlRewrite {
            /**
             * Hostname is the value to be used to replace the Host header value during
             * forwarding.
             *
             *
             * Support: Extended
             */
            hostname?: string;
            /**
             * Path defines a path rewrite.
             *
             *
             * Support: Extended
             */
            path?: outputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersUrlRewritePath;
        }

        /**
         * Path defines a path rewrite.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersUrlRewritePath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: string;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: string;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: string;
        }

        /**
         * HTTPRouteMatch defines the predicate used to match requests to a given
         * action. Multiple match types are ANDed together, i.e. the match will
         * evaluate to true only if all conditions are satisfied.
         *
         *
         * For example, the match below will match a HTTP request only if its path
         * starts with `/foo` AND it contains the `version: v1` header:
         *
         *
         * ```
         * match:
         *
         *
         * 	path:
         * 	  value: "/foo"
         * 	headers:
         * 	- name: "version"
         * 	  value "v1"
         *
         *
         * ```
         */
        export interface HTTPRouteSpecRulesMatches {
            /**
             * Headers specifies HTTP request header matchers. Multiple match values are
             * ANDed together, meaning, a request must match all the specified headers
             * to select the route.
             */
            headers?: outputs.gateway.v1beta1.HTTPRouteSpecRulesMatchesHeaders[];
            /**
             * Method specifies HTTP method matcher.
             * When specified, this route will be matched only if the request has the
             * specified method.
             *
             *
             * Support: Extended
             */
            method?: string;
            /**
             * Path specifies a HTTP request path matcher. If this field is not
             * specified, a default prefix match on the "/" path is provided.
             */
            path?: outputs.gateway.v1beta1.HTTPRouteSpecRulesMatchesPath;
            /**
             * QueryParams specifies HTTP query parameter matchers. Multiple match
             * values are ANDed together, meaning, a request must match all the
             * specified query parameters to select the route.
             *
             *
             * Support: Extended
             */
            queryParams?: outputs.gateway.v1beta1.HTTPRouteSpecRulesMatchesQueryParams[];
        }
        /**
         * httprouteSpecRulesMatchesProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatches
         */
        export function httprouteSpecRulesMatchesProvideDefaults(val: HTTPRouteSpecRulesMatches): HTTPRouteSpecRulesMatches {
            return {
                ...val,
                path: (val.path ? outputs.gateway.v1beta1.httprouteSpecRulesMatchesPathProvideDefaults(val.path) : undefined),
            };
        }

        /**
         * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
         * headers.
         */
        export interface HTTPRouteSpecRulesMatchesHeaders {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             *
             *
             * When a header is repeated in an HTTP request, it is
             * implementation-specific behavior as to how this is represented.
             * Generally, proxies should follow the guidance from the RFC:
             * https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
             * processing a repeated header, with special handling for "Set-Cookie".
             */
            name: string;
            /**
             * Type specifies how to match against the value of the header.
             *
             *
             * Support: Core (Exact)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             *
             *
             * Since RegularExpression HeaderMatchType has implementation-specific
             * conformance, implementations can support POSIX, PCRE or any other dialects
             * of regular expressions. Please read the implementation's documentation to
             * determine the supported dialect.
             */
            type?: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }
        /**
         * httprouteSpecRulesMatchesHeadersProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesHeaders
         */
        export function httprouteSpecRulesMatchesHeadersProvideDefaults(val: HTTPRouteSpecRulesMatchesHeaders): HTTPRouteSpecRulesMatchesHeaders {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Path specifies a HTTP request path matcher. If this field is not
         * specified, a default prefix match on the "/" path is provided.
         */
        export interface HTTPRouteSpecRulesMatchesPath {
            /**
             * Type specifies how to match against the path Value.
             *
             *
             * Support: Core (Exact, PathPrefix)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             */
            type?: string;
            /**
             * Value of the HTTP path to match against.
             */
            value?: string;
        }
        /**
         * httprouteSpecRulesMatchesPathProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesPath
         */
        export function httprouteSpecRulesMatchesPathProvideDefaults(val: HTTPRouteSpecRulesMatchesPath): HTTPRouteSpecRulesMatchesPath {
            return {
                ...val,
                type: (val.type) ?? "PathPrefix",
                value: (val.value) ?? "/",
            };
        }

        /**
         * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
         * query parameters.
         */
        export interface HTTPRouteSpecRulesMatchesQueryParams {
            /**
             * Name is the name of the HTTP query param to be matched. This must be an
             * exact string match. (See
             * https://tools.ietf.org/html/rfc7230#section-2.7.3).
             *
             *
             * If multiple entries specify equivalent query param names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent query param name MUST be ignored.
             *
             *
             * If a query param is repeated in an HTTP request, the behavior is
             * purposely left undefined, since different data planes have different
             * capabilities. However, it is *recommended* that implementations should
             * match against the first value of the param if the data plane supports it,
             * as this behavior is expected in other load balancing contexts outside of
             * the Gateway API.
             *
             *
             * Users SHOULD NOT route traffic based on repeated query params to guard
             * themselves against potential differences in the implementations.
             */
            name: string;
            /**
             * Type specifies how to match against the value of the query parameter.
             *
             *
             * Support: Extended (Exact)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             *
             *
             * Since RegularExpression QueryParamMatchType has Implementation-specific
             * conformance, implementations can support POSIX, PCRE or any other
             * dialects of regular expressions. Please read the implementation's
             * documentation to determine the supported dialect.
             */
            type?: string;
            /**
             * Value is the value of HTTP query param to be matched.
             */
            value: string;
        }
        /**
         * httprouteSpecRulesMatchesQueryParamsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesQueryParams
         */
        export function httprouteSpecRulesMatchesQueryParamsProvideDefaults(val: HTTPRouteSpecRulesMatchesQueryParams): HTTPRouteSpecRulesMatchesQueryParams {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the route rule.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesSessionPersistence {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: string;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: outputs.gateway.v1beta1.HTTPRouteSpecRulesSessionPersistenceCookieConfig;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: string;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: string;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: string;
        }
        /**
         * httprouteSpecRulesSessionPersistenceProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesSessionPersistence
         */
        export function httprouteSpecRulesSessionPersistenceProvideDefaults(val: HTTPRouteSpecRulesSessionPersistence): HTTPRouteSpecRulesSessionPersistence {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? outputs.gateway.v1beta1.httprouteSpecRulesSessionPersistenceCookieConfigProvideDefaults(val.cookieConfig) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesSessionPersistenceCookieConfig {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: string;
        }
        /**
         * httprouteSpecRulesSessionPersistenceCookieConfigProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesSessionPersistenceCookieConfig
         */
        export function httprouteSpecRulesSessionPersistenceCookieConfigProvideDefaults(val: HTTPRouteSpecRulesSessionPersistenceCookieConfig): HTTPRouteSpecRulesSessionPersistenceCookieConfig {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * Timeouts defines the timeouts that can be configured for an HTTP request.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesTimeouts {
            /**
             * BackendRequest specifies a timeout for an individual request from the gateway
             * to a backend. This covers the time from when the request first starts being
             * sent from the gateway to when the full response has been received from the backend.
             *
             *
             * Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
             * completely. Implementations that cannot completely disable the timeout MUST
             * instead interpret the zero duration as the longest possible value to which
             * the timeout can be set.
             *
             *
             * An entire client HTTP transaction with a gateway, covered by the Request timeout,
             * may result in more than one call from the gateway to the destination backend,
             * for example, if automatic retries are supported.
             *
             *
             * Because the Request timeout encompasses the BackendRequest timeout, the value of
             * BackendRequest must be <= the value of Request timeout.
             *
             *
             * Support: Extended
             */
            backendRequest?: string;
            /**
             * Request specifies the maximum duration for a gateway to respond to an HTTP request.
             * If the gateway has not been able to respond before this deadline is met, the gateway
             * MUST return a timeout error.
             *
             *
             * For example, setting the `rules.timeouts.request` field to the value `10s` in an
             * `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
             * to complete.
             *
             *
             * Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
             * completely. Implementations that cannot completely disable the timeout MUST
             * instead interpret the zero duration as the longest possible value to which
             * the timeout can be set.
             *
             *
             * This timeout is intended to cover as close to the whole request-response transaction
             * as possible although an implementation MAY choose to start the timeout after the entire
             * request stream has been received instead of immediately after the transaction is
             * initiated by the client.
             *
             *
             * When this field is unspecified, request timeout behavior is implementation-specific.
             *
             *
             * Support: Extended
             */
            request?: string;
        }

        /**
         * Status defines the current state of HTTPRoute.
         */
        export interface HTTPRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1beta1.HTTPRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface HTTPRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1beta1.HTTPRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1beta1.HTTPRouteStatusParentsParentRef;
        }
        /**
         * httprouteStatusParentsProvideDefaults sets the appropriate defaults for HTTPRouteStatusParents
         */
        export function httprouteStatusParentsProvideDefaults(val: HTTPRouteStatusParents): HTTPRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1beta1.httprouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface HTTPRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface HTTPRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: string;
        }
        /**
         * httprouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for HTTPRouteStatusParentsParentRef
         */
        export function httprouteStatusParentsParentRefProvideDefaults(val: HTTPRouteStatusParentsParentRef): HTTPRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of ReferenceGrant.
         */
        export interface ReferenceGrantSpec {
            /**
             * From describes the trusted namespaces and kinds that can reference the
             * resources described in "To". Each entry in this list MUST be considered
             * to be an additional place that references can be valid from, or to put
             * this another way, entries MUST be combined using OR.
             *
             *
             * Support: Core
             */
            from: outputs.gateway.v1beta1.ReferenceGrantSpecFrom[];
            /**
             * To describes the resources that may be referenced by the resources
             * described in "From". Each entry in this list MUST be considered to be an
             * additional place that references can be valid to, or to put this another
             * way, entries MUST be combined using OR.
             *
             *
             * Support: Core
             */
            to: outputs.gateway.v1beta1.ReferenceGrantSpecTo[];
        }

        /**
         * ReferenceGrantFrom describes trusted namespaces and kinds.
         */
        export interface ReferenceGrantSpecFrom {
            /**
             * Group is the group of the referent.
             * When empty, the Kubernetes core API group is inferred.
             *
             *
             * Support: Core
             */
            group: string;
            /**
             * Kind is the kind of the referent. Although implementations may support
             * additional resources, the following types are part of the "Core"
             * support level for this field.
             *
             *
             * When used to permit a SecretObjectReference:
             *
             *
             * * Gateway
             *
             *
             * When used to permit a BackendObjectReference:
             *
             *
             * * GRPCRoute
             * * HTTPRoute
             * * TCPRoute
             * * TLSRoute
             * * UDPRoute
             */
            kind: string;
            /**
             * Namespace is the namespace of the referent.
             *
             *
             * Support: Core
             */
            namespace: string;
        }

        /**
         * ReferenceGrantTo describes what Kinds are allowed as targets of the
         * references.
         */
        export interface ReferenceGrantSpecTo {
            /**
             * Group is the group of the referent.
             * When empty, the Kubernetes core API group is inferred.
             *
             *
             * Support: Core
             */
            group: string;
            /**
             * Kind is the kind of the referent. Although implementations may support
             * additional resources, the following types are part of the "Core"
             * support level for this field:
             *
             *
             * * Secret when used to permit a SecretObjectReference
             * * Service when used to permit a BackendObjectReference
             */
            kind: string;
            /**
             * Name is the name of the referent. When unspecified, this policy
             * refers to all resources of the specified Group and Kind in the local
             * namespace.
             */
            name?: string;
        }

    }
}
