// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import * as utilities from "../utilities";

import {ObjectMeta} from "../meta/v1";

export namespace gateway {
    export namespace v1 {
        /**
         * Spec defines the desired state of GRPCRoute.
         */
        export interface GRPCRouteSpecArgs {
            /**
             * Hostnames defines a set of hostnames to match against the GRPC
             * Host header to select a GRPCRoute to process the request. This matches
             * the RFC 1123 definition of a hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label MUST appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and GRPCRoute, there
             * MUST be at least one intersecting hostname for the GRPCRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches GRPCRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches GRPCRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `test.example.com` and `*.example.com` would both match. On the other
             *   hand, `example.com` and `test.example.net` would not match.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * If both the Listener and GRPCRoute have specified hostnames, any
             * GRPCRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * GRPCRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` MUST NOT be considered for a match.
             *
             *
             * If both the Listener and GRPCRoute have specified hostnames, and none
             * match with the criteria above, then the GRPCRoute MUST NOT be accepted by
             * the implementation. The implementation MUST raise an 'Accepted' Condition
             * with a status of `False` in the corresponding RouteParentStatus.
             *
             *
             * If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
             * Listener and that listener already has another Route (B) of the other
             * type attached and the intersection of the hostnames of A and B is
             * non-empty, then the implementation MUST accept exactly one of these two
             * routes, determined by the following criteria, in order:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * The rejected Route MUST raise an 'Accepted' condition with a status of
             * 'False' in the corresponding RouteParentStatus.
             *
             *
             * Support: Core
             */
            hostnames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecParentRefsArgs>[]>;
            /**
             * Rules are a list of GRPC matchers, filters and actions.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesArgs>[]>;
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface GRPCRouteSpecParentRefsArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecParentRefsArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecParentRefsArgs
         */
        export function grpcrouteSpecParentRefsArgsProvideDefaults(val: GRPCRouteSpecParentRefsArgs): GRPCRouteSpecParentRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * GRPCRouteRule defines the semantics for matching a gRPC request based on
         * conditions (matches), processing it (filters), and forwarding the request to
         * an API object (backendRefs).
         */
        export interface GRPCRouteSpecRulesArgs {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent.
             *
             *
             * Failure behavior here depends on how many BackendRefs are specified and
             * how many are invalid.
             *
             *
             * If *all* entries in BackendRefs are invalid, and there are also no filters
             * specified in this route rule, *all* traffic which matches this rule MUST
             * receive an `UNAVAILABLE` status.
             *
             *
             * See the GRPCBackendRef definition for the rules about what makes a single
             * GRPCBackendRef invalid.
             *
             *
             * When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
             * requests that would have otherwise been routed to an invalid backend. If
             * multiple backends are specified, and some are invalid, the proportion of
             * requests that would otherwise have been routed to an invalid backend
             * MUST receive an `UNAVAILABLE` status.
             *
             *
             * For example, if two backends are specified with equal weights, and one is
             * invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
             * Implementations may choose how that 50 percent is determined.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Core
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsArgs>[]>;
            /**
             * Filters define the filters that are applied to requests that match
             * this rule.
             *
             *
             * The effects of ordering of multiple behaviors are currently unspecified.
             * This can change in the future based on feedback during the alpha stage.
             *
             *
             * Conformance-levels at this level are defined based on the type of filter:
             *
             *
             * - ALL core filters MUST be supported by all implementations that support
             *   GRPCRoute.
             * - Implementers are encouraged to support extended filters.
             * - Implementation-specific custom filters have no API guarantees across
             *   implementations.
             *
             *
             * Specifying the same filter multiple times is not supported unless explicitly
             * indicated in the filter.
             *
             *
             * If an implementation can not support a combination of filters, it must clearly
             * document that limitation. In cases where incompatible or unsupported
             * filters are specified and cause the `Accepted` condition to be set to status
             * `False`, implementations may use the `IncompatibleFilters` reason to specify
             * this configuration error.
             *
             *
             * Support: Core
             */
            filters?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersArgs>[]>;
            /**
             * Matches define conditions used for matching the rule against incoming
             * gRPC requests. Each match is independent, i.e. this rule will be matched
             * if **any** one of the matches is satisfied.
             *
             *
             * For example, take the following matches configuration:
             *
             *
             * ```
             * matches:
             * - method:
             *     service: foo.bar
             *   headers:
             *     values:
             *       version: 2
             * - method:
             *     service: foo.bar.v2
             * ```
             *
             *
             * For a request to match against this rule, it MUST satisfy
             * EITHER of the two conditions:
             *
             *
             * - service of foo.bar AND contains the header `version: 2`
             * - service of foo.bar.v2
             *
             *
             * See the documentation for GRPCRouteMatch on how to specify multiple
             * match conditions to be ANDed together.
             *
             *
             * If no matches are specified, the implementation MUST match every gRPC request.
             *
             *
             * Proxy or Load Balancer routing configuration generated from GRPCRoutes
             * MUST prioritize rules based on the following criteria, continuing on
             * ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
             * Precedence MUST be given to the rule with the largest number of:
             *
             *
             * * Characters in a matching non-wildcard hostname.
             * * Characters in a matching hostname.
             * * Characters in a matching service.
             * * Characters in a matching method.
             * * Header matches.
             *
             *
             * If ties still exist across multiple Routes, matching precedence MUST be
             * determined in order of the following criteria, continuing on ties:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * If ties still exist within the Route that has been given precedence,
             * matching precedence MUST be granted to the first matching rule meeting
             * the above criteria.
             */
            matches?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesMatchesArgs>[]>;
            /**
             * SessionPersistence defines and configures session persistence
             * for the route rule.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesSessionPersistenceArgs>;
        }
        /**
         * grpcrouteSpecRulesArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesArgs
         */
        export function grpcrouteSpecRulesArgsProvideDefaults(val: GRPCRouteSpecRulesArgs): GRPCRouteSpecRulesArgs {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? pulumi.output(val.sessionPersistence).apply(inputs.gateway.v1.grpcrouteSpecRulesSessionPersistenceArgsProvideDefaults) : undefined),
            };
        }

        /**
         * GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         */
        export interface GRPCRouteSpecRulesBackendRefsArgs {
            /**
             * Filters defined at this level MUST be executed if and only if the
             * request is being forwarded to the backend defined here.
             *
             *
             * Support: Implementation-specific (For broader support of filters, use the
             * Filters field in GRPCRouteRule.)
             */
            filters?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersArgs>[]>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * grpcrouteSpecRulesBackendRefsArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsArgs
         */
        export function grpcrouteSpecRulesBackendRefsArgsProvideDefaults(val: GRPCRouteSpecRulesBackendRefsArgs): GRPCRouteSpecRulesBackendRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. GRPCRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersArgs {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * Support: Implementation-specific
             *
             *
             * This filter can be used multiple times within the same rule.
             */
            extensionRef?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs>;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs>;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs>;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs>;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations supporting GRPCRoute MUST support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` MUST be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             */
            type: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersArgs
         */
        export function grpcrouteSpecRulesBackendRefsFiltersArgsProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersArgs): GRPCRouteSpecRulesBackendRefsFiltersArgs {
            return {
                ...val,
                requestMirror: (val.requestMirror ? pulumi.output(val.requestMirror).apply(inputs.gateway.v1.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * Support: Implementation-specific
         *
         *
         * This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs>;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs): GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
            return {
                ...val,
                backendRef: pulumi.output(val.backendRef).apply(inputs.gateway.v1.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs): GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. GRPCRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesFiltersArgs {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * Support: Implementation-specific
             *
             *
             * This filter can be used multiple times within the same rule.
             */
            extensionRef?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersExtensionRefArgs>;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs>;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestMirrorArgs>;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs>;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations supporting GRPCRoute MUST support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` MUST be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             */
            type: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesFiltersArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersArgs
         */
        export function grpcrouteSpecRulesFiltersArgsProvideDefaults(val: GRPCRouteSpecRulesFiltersArgs): GRPCRouteSpecRulesFiltersArgs {
            return {
                ...val,
                requestMirror: (val.requestMirror ? pulumi.output(val.requestMirror).apply(inputs.gateway.v1.grpcrouteSpecRulesFiltersRequestMirrorArgsProvideDefaults) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * Support: Implementation-specific
         *
         *
         * This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesFiltersExtensionRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirrorArgs {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs>;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorArgs
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorArgsProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirrorArgs): GRPCRouteSpecRulesFiltersRequestMirrorArgs {
            return {
                ...val,
                backendRef: pulumi.output(val.backendRef).apply(inputs.gateway.v1.grpcrouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs): GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * GRPCRouteMatch defines the predicate used to match requests to a given
         * action. Multiple match types are ANDed together, i.e. the match will
         * evaluate to true only if all conditions are satisfied.
         *
         *
         * For example, the match below will match a gRPC request only if its service
         * is `foo` AND it contains the `version: v1` header:
         *
         *
         * ```
         * matches:
         *   - method:
         *     type: Exact
         *     service: "foo"
         *     headers:
         *   - name: "version"
         *     value "v1"
         *
         *
         * ```
         */
        export interface GRPCRouteSpecRulesMatchesArgs {
            /**
             * Headers specifies gRPC request header matchers. Multiple match values are
             * ANDed together, meaning, a request MUST match all the specified headers
             * to select the route.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesMatchesHeadersArgs>[]>;
            /**
             * Method specifies a gRPC request service/method matcher. If this field is
             * not specified, all services and methods will match.
             */
            method?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesMatchesMethodArgs>;
        }
        /**
         * grpcrouteSpecRulesMatchesArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesArgs
         */
        export function grpcrouteSpecRulesMatchesArgsProvideDefaults(val: GRPCRouteSpecRulesMatchesArgs): GRPCRouteSpecRulesMatchesArgs {
            return {
                ...val,
                method: (val.method ? pulumi.output(val.method).apply(inputs.gateway.v1.grpcrouteSpecRulesMatchesMethodArgsProvideDefaults) : undefined),
            };
        }

        /**
         * GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
         * headers.
         */
        export interface GRPCRouteSpecRulesMatchesHeadersArgs {
            /**
             * Name is the name of the gRPC Header to be matched.
             *
             *
             * If multiple entries specify equivalent header names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: pulumi.Input<string>;
            /**
             * Value is the value of the gRPC Header to be matched.
             */
            value: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesMatchesHeadersArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeadersArgs
         */
        export function grpcrouteSpecRulesMatchesHeadersArgsProvideDefaults(val: GRPCRouteSpecRulesMatchesHeadersArgs): GRPCRouteSpecRulesMatchesHeadersArgs {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Method specifies a gRPC request service/method matcher. If this field is
         * not specified, all services and methods will match.
         */
        export interface GRPCRouteSpecRulesMatchesMethodArgs {
            /**
             * Value of the method to match against. If left empty or omitted, will
             * match all services.
             *
             *
             * At least one of Service and Method MUST be a non-empty string.
             */
            method?: pulumi.Input<string>;
            /**
             * Value of the service to match against. If left empty or omitted, will
             * match any service.
             *
             *
             * At least one of Service and Method MUST be a non-empty string.
             */
            service?: pulumi.Input<string>;
            /**
             * Type specifies how to match against the service and/or method.
             * Support: Core (Exact with service and method specified)
             *
             *
             * Support: Implementation-specific (Exact with method specified but no service specified)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             */
            type?: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesMatchesMethodArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethodArgs
         */
        export function grpcrouteSpecRulesMatchesMethodArgsProvideDefaults(val: GRPCRouteSpecRulesMatchesMethodArgs): GRPCRouteSpecRulesMatchesMethodArgs {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the route rule.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesSessionPersistenceArgs {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: pulumi.Input<string>;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: pulumi.Input<inputs.gateway.v1.GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs>;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: pulumi.Input<string>;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesSessionPersistenceArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesSessionPersistenceArgs
         */
        export function grpcrouteSpecRulesSessionPersistenceArgsProvideDefaults(val: GRPCRouteSpecRulesSessionPersistenceArgs): GRPCRouteSpecRulesSessionPersistenceArgs {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? pulumi.output(val.cookieConfig).apply(inputs.gateway.v1.grpcrouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs
         */
        export function grpcrouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults(val: GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs): GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * Status defines the current state of GRPCRoute.
         */
        export interface GRPCRouteStatusArgs {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteStatusParentsArgs>[]>;
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface GRPCRouteStatusParentsArgs {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GRPCRouteStatusParentsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: pulumi.Input<inputs.gateway.v1.GRPCRouteStatusParentsParentRefArgs>;
        }
        /**
         * grpcrouteStatusParentsArgsProvideDefaults sets the appropriate defaults for GRPCRouteStatusParentsArgs
         */
        export function grpcrouteStatusParentsArgsProvideDefaults(val: GRPCRouteStatusParentsArgs): GRPCRouteStatusParentsArgs {
            return {
                ...val,
                parentRef: pulumi.output(val.parentRef).apply(inputs.gateway.v1.grpcrouteStatusParentsParentRefArgsProvideDefaults),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GRPCRouteStatusParentsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface GRPCRouteStatusParentsParentRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * grpcrouteStatusParentsParentRefArgsProvideDefaults sets the appropriate defaults for GRPCRouteStatusParentsParentRefArgs
         */
        export function grpcrouteStatusParentsParentRefArgsProvideDefaults(val: GRPCRouteStatusParentsParentRefArgs): GRPCRouteStatusParentsParentRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of GatewayClass.
         */
        export interface GatewayClassSpecArgs {
            /**
             * ControllerName is the name of the controller that is managing Gateways of
             * this class. The value of this field MUST be a domain prefixed path.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * This field is not mutable and cannot be empty.
             *
             *
             * Support: Core
             */
            controllerName: pulumi.Input<string>;
            /**
             * Description helps describe a GatewayClass with more details.
             */
            description?: pulumi.Input<string>;
            /**
             * ParametersRef is a reference to a resource that contains the configuration
             * parameters corresponding to the GatewayClass. This is optional if the
             * controller does not require any additional configuration.
             *
             *
             * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
             * or an implementation-specific custom resource. The resource can be
             * cluster-scoped or namespace-scoped.
             *
             *
             * If the referent cannot be found, the GatewayClass's "InvalidParameters"
             * status condition will be true.
             *
             *
             * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
             * the merging behavior is implementation specific.
             * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
             *
             *
             * Support: Implementation-specific
             */
            parametersRef?: pulumi.Input<inputs.gateway.v1.GatewayClassSpecParametersRefArgs>;
        }

        /**
         * ParametersRef is a reference to a resource that contains the configuration
         * parameters corresponding to the GatewayClass. This is optional if the
         * controller does not require any additional configuration.
         *
         *
         * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
         * or an implementation-specific custom resource. The resource can be
         * cluster-scoped or namespace-scoped.
         *
         *
         * If the referent cannot be found, the GatewayClass's "InvalidParameters"
         * status condition will be true.
         *
         *
         * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
         * the merging behavior is implementation specific.
         * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
         *
         *
         * Support: Implementation-specific
         */
        export interface GatewayClassSpecParametersRefArgs {
            /**
             * Group is the group of the referent.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent.
             * This field is required when referring to a Namespace-scoped resource and
             * MUST be unset when referring to a Cluster-scoped resource.
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Status defines the current state of GatewayClass.
         *
         *
         * Implementations MUST populate status on all GatewayClass resources which
         * specify their controller name.
         */
        export interface GatewayClassStatusArgs {
            /**
             * Conditions is the current status from the controller for
             * this GatewayClass.
             *
             *
             * Controllers should prefer to publish conditions using values
             * of GatewayClassConditionType for the type of each Condition.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewayClassStatusConditionsArgs>[]>;
            /**
             * SupportedFeatures is the set of features the GatewayClass support.
             * It MUST be sorted in ascending alphabetical order.
             */
            supportedFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayClassStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * Spec defines the desired state of Gateway.
         */
        export interface GatewaySpecArgs {
            /**
             * Addresses requested for this Gateway. This is optional and behavior can
             * depend on the implementation. If a value is set in the spec and the
             * requested address is invalid or unavailable, the implementation MUST
             * indicate this in the associated entry in GatewayStatus.Addresses.
             *
             *
             * The Addresses field represents a request for the address(es) on the
             * "outside of the Gateway", that traffic bound for this Gateway will use.
             * This could be the IP address or hostname of an external load balancer or
             * other networking infrastructure, or some other address that traffic will
             * be sent to.
             *
             *
             * If no Addresses are specified, the implementation MAY schedule the
             * Gateway in an implementation-specific manner, assigning an appropriate
             * set of Addresses.
             *
             *
             * The implementation MUST bind all Listeners to every GatewayAddress that
             * it assigns to the Gateway and add a corresponding entry in
             * GatewayStatus.Addresses.
             *
             *
             * Support: Extended
             */
            addresses?: pulumi.Input<any[]>;
            /**
             * GatewayClassName used for this Gateway. This is the name of a
             * GatewayClass resource.
             */
            gatewayClassName: pulumi.Input<string>;
            /**
             * Infrastructure defines infrastructure level attributes about this Gateway instance.
             *
             *
             * Support: Core
             */
            infrastructure?: pulumi.Input<inputs.gateway.v1.GatewaySpecInfrastructureArgs>;
            /**
             * Listeners associated with this Gateway. Listeners define
             * logical endpoints that are bound on this Gateway's addresses.
             * At least one Listener MUST be specified.
             *
             *
             * Each Listener in a set of Listeners (for example, in a single Gateway)
             * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
             * exactly one listener. (This section uses "set of Listeners" rather than
             * "Listeners in a single Gateway" because implementations MAY merge configuration
             * from multiple Gateways onto a single data plane, and these rules _also_
             * apply in that case).
             *
             *
             * Practically, this means that each listener in a set MUST have a unique
             * combination of Port, Protocol, and, if supported by the protocol, Hostname.
             *
             *
             * Some combinations of port, protocol, and TLS settings are considered
             * Core support and MUST be supported by implementations based on their
             * targeted conformance profile:
             *
             *
             * HTTP Profile
             *
             *
             * 1. HTTPRoute, Port: 80, Protocol: HTTP
             * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
             *
             *
             * TLS Profile
             *
             *
             * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
             *
             *
             * "Distinct" Listeners have the following property:
             *
             *
             * The implementation can match inbound requests to a single distinct
             * Listener. When multiple Listeners share values for fields (for
             * example, two Listeners with the same Port value), the implementation
             * can match requests to only one of the Listeners using other
             * Listener fields.
             *
             *
             * For example, the following Listener scenarios are distinct:
             *
             *
             * 1. Multiple Listeners with the same Port that all use the "HTTP"
             *    Protocol that all have unique Hostname values.
             * 2. Multiple Listeners with the same Port that use either the "HTTPS" or
             *    "TLS" Protocol that all have unique Hostname values.
             * 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
             *    with the same Protocol has the same Port value.
             *
             *
             * Some fields in the Listener struct have possible values that affect
             * whether the Listener is distinct. Hostname is particularly relevant
             * for HTTP or HTTPS protocols.
             *
             *
             * When using the Hostname value to select between same-Port, same-Protocol
             * Listeners, the Hostname value must be different on each Listener for the
             * Listener to be distinct.
             *
             *
             * When the Listeners are distinct based on Hostname, inbound request
             * hostnames MUST match from the most specific to least specific Hostname
             * values to choose the correct Listener and its associated set of Routes.
             *
             *
             * Exact matches must be processed before wildcard matches, and wildcard
             * matches must be processed before fallback (empty Hostname value)
             * matches. For example, `"foo.example.com"` takes precedence over
             * `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
             *
             *
             * Additionally, if there are multiple wildcard entries, more specific
             * wildcard entries must be processed before less specific wildcard entries.
             * For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
             * The precise definition here is that the higher the number of dots in the
             * hostname to the right of the wildcard character, the higher the precedence.
             *
             *
             * The wildcard character will match any number of characters _and dots_ to
             * the left, however, so `"*.example.com"` will match both
             * `"foo.bar.example.com"` _and_ `"bar.example.com"`.
             *
             *
             * If a set of Listeners contains Listeners that are not distinct, then those
             * Listeners are Conflicted, and the implementation MUST set the "Conflicted"
             * condition in the Listener Status to "True".
             *
             *
             * Implementations MAY choose to accept a Gateway with some Conflicted
             * Listeners only if they only accept the partial Listener set that contains
             * no Conflicted Listeners. To put this another way, implementations may
             * accept a partial Listener set only if they throw out *all* the conflicting
             * Listeners. No picking one of the conflicting listeners as the winner.
             * This also means that the Gateway must have at least one non-conflicting
             * Listener in this case, otherwise it violates the requirement that at
             * least one Listener must be present.
             *
             *
             * The implementation MUST set a "ListenersNotValid" condition on the
             * Gateway Status when the Gateway contains Conflicted Listeners whether or
             * not they accept the Gateway. That Condition SHOULD clearly
             * indicate in the Message which Listeners are conflicted, and which are
             * Accepted. Additionally, the Listener status for those listeners SHOULD
             * indicate which Listeners are conflicted and not Accepted.
             *
             *
             * A Gateway's Listeners are considered "compatible" if:
             *
             *
             * 1. They are distinct.
             * 2. The implementation can serve them in compliance with the Addresses
             *    requirement that all Listeners are available on all assigned
             *    addresses.
             *
             *
             * Compatible combinations in Extended support are expected to vary across
             * implementations. A combination that is compatible for one implementation
             * may not be compatible for another.
             *
             *
             * For example, an implementation that cannot serve both TCP and UDP listeners
             * on the same address, or cannot mix HTTPS and generic TLS listens on the same port
             * would not consider those cases compatible, even though they are distinct.
             *
             *
             * Note that requests SHOULD match at most one Listener. For example, if
             * Listeners are defined for "foo.example.com" and "*.example.com", a
             * request to "foo.example.com" SHOULD only be routed using routes attached
             * to the "foo.example.com" Listener (and not the "*.example.com" Listener).
             * This concept is known as "Listener Isolation". Implementations that do
             * not support Listener Isolation MUST clearly document this.
             *
             *
             * Implementations MAY merge separate Gateways onto a single set of
             * Addresses if all Listeners across all Gateways are compatible.
             *
             *
             * Support: Core
             */
            listeners: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewaySpecListenersArgs>[]>;
        }

        /**
         * Infrastructure defines infrastructure level attributes about this Gateway instance.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecInfrastructureArgs {
            /**
             * Annotations that SHOULD be applied to any resources created in response to this Gateway.
             *
             *
             * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
             * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
             *
             *
             * An implementation may chose to add additional implementation-specific annotations as they see fit.
             *
             *
             * Support: Extended
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Labels that SHOULD be applied to any resources created in response to this Gateway.
             *
             *
             * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
             * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
             *
             *
             * An implementation may chose to add additional implementation-specific labels as they see fit.
             *
             *
             * Support: Extended
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * ParametersRef is a reference to a resource that contains the configuration
             * parameters corresponding to the Gateway. This is optional if the
             * controller does not require any additional configuration.
             *
             *
             * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
             *
             *
             * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
             * the merging behavior is implementation specific.
             * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
             *
             *
             * Support: Implementation-specific
             */
            parametersRef?: pulumi.Input<inputs.gateway.v1.GatewaySpecInfrastructureParametersRefArgs>;
        }

        /**
         * ParametersRef is a reference to a resource that contains the configuration
         * parameters corresponding to the Gateway. This is optional if the
         * controller does not require any additional configuration.
         *
         *
         * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
         *
         *
         * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
         * the merging behavior is implementation specific.
         * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
         *
         *
         * Support: Implementation-specific
         */
        export interface GatewaySpecInfrastructureParametersRefArgs {
            /**
             * Group is the group of the referent.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * Listener embodies the concept of a logical endpoint where a Gateway accepts
         * network connections.
         */
        export interface GatewaySpecListenersArgs {
            /**
             * AllowedRoutes defines the types of routes that MAY be attached to a
             * Listener and the trusted namespaces where those Route resources MAY be
             * present.
             *
             *
             * Although a client request may match multiple route rules, only one rule
             * may ultimately receive the request. Matching precedence MUST be
             * determined in order of the following criteria:
             *
             *
             * * The most specific match as defined by the Route type.
             * * The oldest Route based on creation timestamp. For example, a Route with
             *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
             *   a Route with a creation timestamp of "2020-09-08 01:02:04".
             * * If everything else is equivalent, the Route appearing first in
             *   alphabetical order (namespace/name) should be given precedence. For
             *   example, foo/bar is given precedence over foo/baz.
             *
             *
             * All valid rules within a Route attached to this Listener should be
             * implemented. Invalid Route rules can be ignored (sometimes that will mean
             * the full Route). If a Route rule transitions from valid to invalid,
             * support for that Route rule should be dropped to ensure consistency. For
             * example, even if a filter specified by a Route rule is invalid, the rest
             * of the rules within that Route should still be supported.
             *
             *
             * Support: Core
             */
            allowedRoutes?: pulumi.Input<inputs.gateway.v1.GatewaySpecListenersAllowedRoutesArgs>;
            /**
             * Hostname specifies the virtual hostname to match for protocol types that
             * define this concept. When unspecified, all hostnames are matched. This
             * field is ignored for protocols that don't require hostname based
             * matching.
             *
             *
             * Implementations MUST apply Hostname matching appropriately for each of
             * the following protocols:
             *
             *
             * * TLS: The Listener Hostname MUST match the SNI.
             * * HTTP: The Listener Hostname MUST match the Host header of the request.
             * * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
             *   protocol layers as described above. If an implementation does not
             *   ensure that both the SNI and Host header match the Listener hostname,
             *   it MUST clearly document that.
             *
             *
             * For HTTPRoute and TLSRoute resources, there is an interaction with the
             * `spec.hostnames` array. When both listener and route specify hostnames,
             * there MUST be an intersection between the values for a Route to be
             * accepted. For more information, refer to the Route specific Hostnames
             * documentation.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * Support: Core
             */
            hostname?: pulumi.Input<string>;
            /**
             * Name is the name of the Listener. This name MUST be unique within a
             * Gateway.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Port is the network port. Multiple listeners may use the
             * same port, subject to the Listener compatibility rules.
             *
             *
             * Support: Core
             */
            port: pulumi.Input<number>;
            /**
             * Protocol specifies the network protocol this listener expects to receive.
             *
             *
             * Support: Core
             */
            protocol: pulumi.Input<string>;
            /**
             * TLS is the TLS configuration for the Listener. This field is required if
             * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
             * if the Protocol field is "HTTP", "TCP", or "UDP".
             *
             *
             * The association of SNIs to Certificate defined in GatewayTLSConfig is
             * defined based on the Hostname field for this listener.
             *
             *
             * The GatewayClass MUST use the longest matching SNI out of all
             * available certificates for any TLS handshake.
             *
             *
             * Support: Core
             */
            tls?: pulumi.Input<inputs.gateway.v1.GatewaySpecListenersTlsArgs>;
        }
        /**
         * gatewaySpecListenersArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersArgs
         */
        export function gatewaySpecListenersArgsProvideDefaults(val: GatewaySpecListenersArgs): GatewaySpecListenersArgs {
            return {
                ...val,
                allowedRoutes: (val.allowedRoutes ? pulumi.output(val.allowedRoutes).apply(inputs.gateway.v1.gatewaySpecListenersAllowedRoutesArgsProvideDefaults) : undefined),
                tls: (val.tls ? pulumi.output(val.tls).apply(inputs.gateway.v1.gatewaySpecListenersTlsArgsProvideDefaults) : undefined),
            };
        }

        /**
         * AllowedRoutes defines the types of routes that MAY be attached to a
         * Listener and the trusted namespaces where those Route resources MAY be
         * present.
         *
         *
         * Although a client request may match multiple route rules, only one rule
         * may ultimately receive the request. Matching precedence MUST be
         * determined in order of the following criteria:
         *
         *
         * * The most specific match as defined by the Route type.
         * * The oldest Route based on creation timestamp. For example, a Route with
         *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
         *   a Route with a creation timestamp of "2020-09-08 01:02:04".
         * * If everything else is equivalent, the Route appearing first in
         *   alphabetical order (namespace/name) should be given precedence. For
         *   example, foo/bar is given precedence over foo/baz.
         *
         *
         * All valid rules within a Route attached to this Listener should be
         * implemented. Invalid Route rules can be ignored (sometimes that will mean
         * the full Route). If a Route rule transitions from valid to invalid,
         * support for that Route rule should be dropped to ensure consistency. For
         * example, even if a filter specified by a Route rule is invalid, the rest
         * of the rules within that Route should still be supported.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesArgs {
            /**
             * Kinds specifies the groups and kinds of Routes that are allowed to bind
             * to this Gateway Listener. When unspecified or empty, the kinds of Routes
             * selected are determined using the Listener protocol.
             *
             *
             * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
             * with the application protocol specified in the Listener's Protocol field.
             * If an implementation does not support or recognize this resource type, it
             * MUST set the "ResolvedRefs" condition to False for this Listener with the
             * "InvalidRouteKinds" reason.
             *
             *
             * Support: Core
             */
            kinds?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewaySpecListenersAllowedRoutesKindsArgs>[]>;
            /**
             * Namespaces indicates namespaces from which Routes may be attached to this
             * Listener. This is restricted to the namespace of this Gateway by default.
             *
             *
             * Support: Core
             */
            namespaces?: pulumi.Input<inputs.gateway.v1.GatewaySpecListenersAllowedRoutesNamespacesArgs>;
        }
        /**
         * gatewaySpecListenersAllowedRoutesArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesArgs
         */
        export function gatewaySpecListenersAllowedRoutesArgsProvideDefaults(val: GatewaySpecListenersAllowedRoutesArgs): GatewaySpecListenersAllowedRoutesArgs {
            return {
                ...val,
                namespaces: (val.namespaces ? pulumi.output(val.namespaces).apply(inputs.gateway.v1.gatewaySpecListenersAllowedRoutesNamespacesArgsProvideDefaults) : undefined),
            };
        }

        /**
         * RouteGroupKind indicates the group and kind of a Route resource.
         */
        export interface GatewaySpecListenersAllowedRoutesKindsArgs {
            /**
             * Group is the group of the Route.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the kind of the Route.
             */
            kind: pulumi.Input<string>;
        }
        /**
         * gatewaySpecListenersAllowedRoutesKindsArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesKindsArgs
         */
        export function gatewaySpecListenersAllowedRoutesKindsArgsProvideDefaults(val: GatewaySpecListenersAllowedRoutesKindsArgs): GatewaySpecListenersAllowedRoutesKindsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
            };
        }

        /**
         * Namespaces indicates namespaces from which Routes may be attached to this
         * Listener. This is restricted to the namespace of this Gateway by default.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesArgs {
            /**
             * From indicates where Routes will be selected for this Gateway. Possible
             * values are:
             *
             *
             * * All: Routes in all namespaces may be used by this Gateway.
             * * Selector: Routes in namespaces selected by the selector may be used by
             *   this Gateway.
             * * Same: Only Routes in the same namespace may be used by this Gateway.
             *
             *
             * Support: Core
             */
            from?: pulumi.Input<string>;
            /**
             * Selector must be specified when From is set to "Selector". In that case,
             * only Routes in Namespaces matching this Selector will be selected by this
             * Gateway. This field is ignored for other values of "From".
             *
             *
             * Support: Core
             */
            selector?: pulumi.Input<inputs.gateway.v1.GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs>;
        }
        /**
         * gatewaySpecListenersAllowedRoutesNamespacesArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesNamespacesArgs
         */
        export function gatewaySpecListenersAllowedRoutesNamespacesArgsProvideDefaults(val: GatewaySpecListenersAllowedRoutesNamespacesArgs): GatewaySpecListenersAllowedRoutesNamespacesArgs {
            return {
                ...val,
                from: (val.from) ?? "Same",
            };
        }

        /**
         * Selector must be specified when From is set to "Selector". In that case,
         * only Routes in Namespaces matching this Selector will be selected by this
         * Gateway. This field is ignored for other values of "From".
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS is the TLS configuration for the Listener. This field is required if
         * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
         * if the Protocol field is "HTTP", "TCP", or "UDP".
         *
         *
         * The association of SNIs to Certificate defined in GatewayTLSConfig is
         * defined based on the Hostname field for this listener.
         *
         *
         * The GatewayClass MUST use the longest matching SNI out of all
         * available certificates for any TLS handshake.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersTlsArgs {
            /**
             * CertificateRefs contains a series of references to Kubernetes objects that
             * contains TLS certificates and private keys. These certificates are used to
             * establish a TLS handshake for requests that match the hostname of the
             * associated listener.
             *
             *
             * A single CertificateRef to a Kubernetes Secret has "Core" support.
             * Implementations MAY choose to support attaching multiple certificates to
             * a Listener, but this behavior is implementation-specific.
             *
             *
             * References to a resource in different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached. If a ReferenceGrant does not allow this reference, the
             * "ResolvedRefs" condition MUST be set to False for this listener with the
             * "RefNotPermitted" reason.
             *
             *
             * This field is required to have at least one element when the mode is set
             * to "Terminate" (default) and is optional otherwise.
             *
             *
             * CertificateRefs can reference to standard Kubernetes resources, i.e.
             * Secret, or implementation-specific custom resources.
             *
             *
             * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
             *
             *
             * Support: Implementation-specific (More than one reference or other resource types)
             */
            certificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewaySpecListenersTlsCertificateRefsArgs>[]>;
            /**
             * FrontendValidation holds configuration information for validating the frontend (client).
             * Setting this field will require clients to send a client certificate
             * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
             * that requests a user to specify the client certificate.
             * The maximum depth of a certificate chain accepted in verification is Implementation specific.
             *
             *
             * Support: Extended
             */
            frontendValidation?: pulumi.Input<inputs.gateway.v1.GatewaySpecListenersTlsFrontendValidationArgs>;
            /**
             * Mode defines the TLS behavior for the TLS session initiated by the client.
             * There are two possible modes:
             *
             *
             * - Terminate: The TLS session between the downstream client and the
             *   Gateway is terminated at the Gateway. This mode requires certificates
             *   to be specified in some way, such as populating the certificateRefs
             *   field.
             * - Passthrough: The TLS session is NOT terminated by the Gateway. This
             *   implies that the Gateway can't decipher the TLS stream except for
             *   the ClientHello message of the TLS protocol. The certificateRefs field
             *   is ignored in this mode.
             *
             *
             * Support: Core
             */
            mode?: pulumi.Input<string>;
            /**
             * Options are a list of key/value pairs to enable extended TLS
             * configuration for each implementation. For example, configuring the
             * minimum TLS version or supported cipher suites.
             *
             *
             * A set of common keys MAY be defined by the API in the future. To avoid
             * any ambiguity, implementation-specific definitions MUST use
             * domain-prefixed names, such as `example.com/my-custom-option`.
             * Un-prefixed names are reserved for key names defined by Gateway API.
             *
             *
             * Support: Implementation-specific
             */
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }
        /**
         * gatewaySpecListenersTlsArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersTlsArgs
         */
        export function gatewaySpecListenersTlsArgsProvideDefaults(val: GatewaySpecListenersTlsArgs): GatewaySpecListenersTlsArgs {
            return {
                ...val,
                mode: (val.mode) ?? "Terminate",
            };
        }

        /**
         * SecretObjectReference identifies an API object including its namespace,
         * defaulting to Secret.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface GatewaySpecListenersTlsCertificateRefsArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * gatewaySpecListenersTlsCertificateRefsArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersTlsCertificateRefsArgs
         */
        export function gatewaySpecListenersTlsCertificateRefsArgsProvideDefaults(val: GatewaySpecListenersTlsCertificateRefsArgs): GatewaySpecListenersTlsCertificateRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Secret",
            };
        }

        /**
         * FrontendValidation holds configuration information for validating the frontend (client).
         * Setting this field will require clients to send a client certificate
         * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
         * that requests a user to specify the client certificate.
         * The maximum depth of a certificate chain accepted in verification is Implementation specific.
         *
         *
         * Support: Extended
         */
        export interface GatewaySpecListenersTlsFrontendValidationArgs {
            /**
             * CACertificateRefs contains one or more references to
             * Kubernetes objects that contain TLS certificates of
             * the Certificate Authorities that can be used
             * as a trust anchor to validate the certificates presented by the client.
             *
             *
             * A single CA certificate reference to a Kubernetes ConfigMap
             * has "Core" support.
             * Implementations MAY choose to support attaching multiple CA certificates to
             * a Listener, but this behavior is implementation-specific.
             *
             *
             * Support: Core - A single reference to a Kubernetes ConfigMap
             * with the CA certificate in a key named `ca.crt`.
             *
             *
             * Support: Implementation-specific (More than one reference, or other kinds
             * of resources).
             *
             *
             * References to a resource in a different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached. If a ReferenceGrant does not allow this reference, the
             * "ResolvedRefs" condition MUST be set to False for this listener with the
             * "RefNotPermitted" reason.
             */
            caCertificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewaySpecListenersTlsFrontendValidationCaCertificateRefsArgs>[]>;
        }

        /**
         * ObjectReference identifies an API object including its namespace.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface GatewaySpecListenersTlsFrontendValidationCaCertificateRefsArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "ConfigMap" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Status defines the current state of Gateway.
         */
        export interface GatewayStatusArgs {
            /**
             * Addresses lists the network addresses that have been bound to the
             * Gateway.
             *
             *
             * This list may differ from the addresses provided in the spec under some
             * conditions:
             *
             *
             *   * no addresses are specified, all addresses are dynamically assigned
             *   * a combination of specified and dynamic addresses are assigned
             *   * a specified address was unusable (e.g. already in use)
             */
            addresses?: pulumi.Input<any[]>;
            /**
             * Conditions describe the current conditions of the Gateway.
             *
             *
             * Implementations should prefer to express Gateway conditions
             * using the `GatewayConditionType` and `GatewayConditionReason`
             * constants so that operators and tools can converge on a common
             * vocabulary to describe Gateway state.
             *
             *
             * Known condition types are:
             *
             *
             * * "Accepted"
             * * "Programmed"
             * * "Ready"
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewayStatusConditionsArgs>[]>;
            /**
             * Listeners provide status for each unique listener port defined in the Spec.
             */
            listeners?: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewayStatusListenersArgs>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ListenerStatus is the status associated with a Listener.
         */
        export interface GatewayStatusListenersArgs {
            /**
             * AttachedRoutes represents the total number of Routes that have been
             * successfully attached to this Listener.
             *
             *
             * Successful attachment of a Route to a Listener is based solely on the
             * combination of the AllowedRoutes field on the corresponding Listener
             * and the Route's ParentRefs field. A Route is successfully attached to
             * a Listener when it is selected by the Listener's AllowedRoutes field
             * AND the Route has a valid ParentRef selecting the whole Gateway
             * resource or a specific Listener as a parent resource (more detail on
             * attachment semantics can be found in the documentation on the various
             * Route kinds ParentRefs fields). Listener or Route status does not impact
             * successful attachment, i.e. the AttachedRoutes field count MUST be set
             * for Listeners with condition Accepted: false and MUST count successfully
             * attached Routes that may themselves have Accepted: false conditions.
             *
             *
             * Uses for this field include troubleshooting Route attachment and
             * measuring blast radius/impact of changes to a Listener.
             */
            attachedRoutes: pulumi.Input<number>;
            /**
             * Conditions describe the current condition of this listener.
             */
            conditions: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewayStatusListenersConditionsArgs>[]>;
            /**
             * Name is the name of the Listener that this status corresponds to.
             */
            name: pulumi.Input<string>;
            /**
             * SupportedKinds is the list indicating the Kinds supported by this
             * listener. This MUST represent the kinds an implementation supports for
             * that Listener configuration.
             *
             *
             * If kinds are specified in Spec that are not supported, they MUST NOT
             * appear in this list and an implementation MUST set the "ResolvedRefs"
             * condition to "False" with the "InvalidRouteKinds" reason. If both valid
             * and invalid Route kinds are specified, the implementation MUST
             * reference the valid Route kinds that have been specified.
             */
            supportedKinds: pulumi.Input<pulumi.Input<inputs.gateway.v1.GatewayStatusListenersSupportedKindsArgs>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayStatusListenersConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * RouteGroupKind indicates the group and kind of a Route resource.
         */
        export interface GatewayStatusListenersSupportedKindsArgs {
            /**
             * Group is the group of the Route.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the kind of the Route.
             */
            kind: pulumi.Input<string>;
        }
        /**
         * gatewayStatusListenersSupportedKindsArgsProvideDefaults sets the appropriate defaults for GatewayStatusListenersSupportedKindsArgs
         */
        export function gatewayStatusListenersSupportedKindsArgsProvideDefaults(val: GatewayStatusListenersSupportedKindsArgs): GatewayStatusListenersSupportedKindsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
            };
        }

        /**
         * Spec defines the desired state of HTTPRoute.
         */
        export interface HTTPRouteSpecArgs {
            /**
             * Hostnames defines a set of hostnames that should match against the HTTP Host
             * header to select a HTTPRoute used to process the request. Implementations
             * MUST ignore any port value specified in the HTTP Host header while
             * performing a match and (absent of any applicable header modification
             * configuration) MUST forward this header unmodified to the backend.
             *
             *
             * Valid values for Hostnames are determined by RFC 1123 definition of a
             * hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label must appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and HTTPRoute, there
             * must be at least one intersecting hostname for the HTTPRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches HTTPRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches HTTPRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
             *   all match. On the other hand, `example.com` and `test.example.net` would
             *   not match.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * If both the Listener and HTTPRoute have specified hostnames, any
             * HTTPRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * HTTPRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` must not be considered for a match.
             *
             *
             * If both the Listener and HTTPRoute have specified hostnames, and none
             * match with the criteria above, then the HTTPRoute is not accepted. The
             * implementation must raise an 'Accepted' Condition with a status of
             * `False` in the corresponding RouteParentStatus.
             *
             *
             * In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
             * overlapping wildcard matching and exact matching hostnames), precedence must
             * be given to rules from the HTTPRoute with the largest number of:
             *
             *
             * * Characters in a matching non-wildcard hostname.
             * * Characters in a matching hostname.
             *
             *
             * If ties exist across multiple Routes, the matching precedence rules for
             * HTTPRouteMatches takes over.
             *
             *
             * Support: Core
             */
            hostnames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecParentRefsArgs>[]>;
            /**
             * Rules are a list of HTTP matchers, filters and actions.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesArgs>[]>;
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface HTTPRouteSpecParentRefsArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * httprouteSpecParentRefsArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecParentRefsArgs
         */
        export function httprouteSpecParentRefsArgsProvideDefaults(val: HTTPRouteSpecParentRefsArgs): HTTPRouteSpecParentRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * HTTPRouteRule defines semantics for matching an HTTP request based on
         * conditions (matches), processing it (filters), and forwarding the request to
         * an API object (backendRefs).
         */
        export interface HTTPRouteSpecRulesArgs {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent.
             *
             *
             * Failure behavior here depends on how many BackendRefs are specified and
             * how many are invalid.
             *
             *
             * If *all* entries in BackendRefs are invalid, and there are also no filters
             * specified in this route rule, *all* traffic which matches this rule MUST
             * receive a 500 status code.
             *
             *
             * See the HTTPBackendRef definition for the rules about what makes a single
             * HTTPBackendRef invalid.
             *
             *
             * When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
             * requests that would have otherwise been routed to an invalid backend. If
             * multiple backends are specified, and some are invalid, the proportion of
             * requests that would otherwise have been routed to an invalid backend
             * MUST receive a 500 status code.
             *
             *
             * For example, if two backends are specified with equal weights, and one is
             * invalid, 50 percent of traffic must receive a 500. Implementations may
             * choose how that 50 percent is determined.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Core
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsArgs>[]>;
            /**
             * Filters define the filters that are applied to requests that match
             * this rule.
             *
             *
             * Wherever possible, implementations SHOULD implement filters in the order
             * they are specified.
             *
             *
             * Implementations MAY choose to implement this ordering strictly, rejecting
             * any combination or order of filters that can not be supported. If implementations
             * choose a strict interpretation of filter ordering, they MUST clearly document
             * that behavior.
             *
             *
             * To reject an invalid combination or order of filters, implementations SHOULD
             * consider the Route Rules with this configuration invalid. If all Route Rules
             * in a Route are invalid, the entire Route would be considered invalid. If only
             * a portion of Route Rules are invalid, implementations MUST set the
             * "PartiallyInvalid" condition for the Route.
             *
             *
             * Conformance-levels at this level are defined based on the type of filter:
             *
             *
             * - ALL core filters MUST be supported by all implementations.
             * - Implementers are encouraged to support extended filters.
             * - Implementation-specific custom filters have no API guarantees across
             *   implementations.
             *
             *
             * Specifying the same filter multiple times is not supported unless explicitly
             * indicated in the filter.
             *
             *
             * All filters are expected to be compatible with each other except for the
             * URLRewrite and RequestRedirect filters, which may not be combined. If an
             * implementation can not support other combinations of filters, they must clearly
             * document that limitation. In cases where incompatible or unsupported
             * filters are specified and cause the `Accepted` condition to be set to status
             * `False`, implementations may use the `IncompatibleFilters` reason to specify
             * this configuration error.
             *
             *
             * Support: Core
             */
            filters?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersArgs>[]>;
            /**
             * Matches define conditions used for matching the rule against incoming
             * HTTP requests. Each match is independent, i.e. this rule will be matched
             * if **any** one of the matches is satisfied.
             *
             *
             * For example, take the following matches configuration:
             *
             *
             * ```
             * matches:
             * - path:
             *     value: "/foo"
             *   headers:
             *   - name: "version"
             *     value: "v2"
             * - path:
             *     value: "/v2/foo"
             * ```
             *
             *
             * For a request to match against this rule, a request must satisfy
             * EITHER of the two conditions:
             *
             *
             * - path prefixed with `/foo` AND contains the header `version: v2`
             * - path prefix of `/v2/foo`
             *
             *
             * See the documentation for HTTPRouteMatch on how to specify multiple
             * match conditions that should be ANDed together.
             *
             *
             * If no matches are specified, the default is a prefix
             * path match on "/", which has the effect of matching every
             * HTTP request.
             *
             *
             * Proxy or Load Balancer routing configuration generated from HTTPRoutes
             * MUST prioritize matches based on the following criteria, continuing on
             * ties. Across all rules specified on applicable Routes, precedence must be
             * given to the match having:
             *
             *
             * * "Exact" path match.
             * * "Prefix" path match with largest number of characters.
             * * Method match.
             * * Largest number of header matches.
             * * Largest number of query param matches.
             *
             *
             * Note: The precedence of RegularExpression path matches are implementation-specific.
             *
             *
             * If ties still exist across multiple Routes, matching precedence MUST be
             * determined in order of the following criteria, continuing on ties:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * If ties still exist within an HTTPRoute, matching precedence MUST be granted
             * to the FIRST matching rule (in list order) with a match meeting the above
             * criteria.
             *
             *
             * When no rules matching a request have been successfully attached to the
             * parent a request is coming from, a HTTP 404 status code MUST be returned.
             */
            matches?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesMatchesArgs>[]>;
            /**
             * SessionPersistence defines and configures session persistence
             * for the route rule.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesSessionPersistenceArgs>;
            /**
             * Timeouts defines the timeouts that can be configured for an HTTP request.
             *
             *
             * Support: Extended
             */
            timeouts?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesTimeoutsArgs>;
        }
        /**
         * httprouteSpecRulesArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesArgs
         */
        export function httprouteSpecRulesArgsProvideDefaults(val: HTTPRouteSpecRulesArgs): HTTPRouteSpecRulesArgs {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? pulumi.output(val.sessionPersistence).apply(inputs.gateway.v1.httprouteSpecRulesSessionPersistenceArgsProvideDefaults) : undefined),
            };
        }

        /**
         * HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         */
        export interface HTTPRouteSpecRulesBackendRefsArgs {
            /**
             * Filters defined at this level should be executed if and only if the
             * request is being forwarded to the backend defined here.
             *
             *
             * Support: Implementation-specific (For broader support of filters, use the
             * Filters field in HTTPRouteRule.)
             */
            filters?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersArgs>[]>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesBackendRefsArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsArgs
         */
        export function httprouteSpecRulesBackendRefsArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsArgs): HTTPRouteSpecRulesBackendRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * HTTPRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. HTTPRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersArgs {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * This filter can be used multiple times within the same rule.
             *
             *
             * Support: Implementation-specific
             */
            extensionRef?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs>;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs>;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs>;
            /**
             * RequestRedirect defines a schema for a filter that responds to the
             * request with an HTTP redirection.
             *
             *
             * Support: Core
             */
            requestRedirect?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs>;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs>;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations must support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by
             *   specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` should be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
            /**
             * URLRewrite defines a schema for a filter that modifies a request during forwarding.
             *
             *
             * Support: Extended
             */
            urlRewrite?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs>;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersArgs
         */
        export function httprouteSpecRulesBackendRefsFiltersArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersArgs): HTTPRouteSpecRulesBackendRefsFiltersArgs {
            return {
                ...val,
                requestMirror: (val.requestMirror ? pulumi.output(val.requestMirror).apply(inputs.gateway.v1.httprouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults) : undefined),
                requestRedirect: (val.requestRedirect ? pulumi.output(val.requestRedirect).apply(inputs.gateway.v1.httprouteSpecRulesBackendRefsFiltersRequestRedirectArgsProvideDefaults) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * This filter can be used multiple times within the same rule.
         *
         *
         * Support: Implementation-specific
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs>;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs): HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
            return {
                ...val,
                backendRef: pulumi.output(val.backendRef).apply(inputs.gateway.v1.httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs): HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * RequestRedirect defines a schema for a filter that responds to the
         * request with an HTTP redirection.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             *
             *
             * Support: Core
             */
            hostname?: pulumi.Input<string>;
            /**
             * Path defines parameters used to modify the path of the incoming request.
             * The modified path is then used to construct the `Location` header. When
             * empty, the request path is used as-is.
             *
             *
             * Support: Extended
             */
            path?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs>;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             *
             * If no port is specified, the redirect port MUST be derived using the
             * following rules:
             *
             *
             * * If redirect scheme is not-empty, the redirect port MUST be the well-known
             *   port associated with the redirect scheme. Specifically "http" to port 80
             *   and "https" to port 443. If the redirect scheme does not have a
             *   well-known port, the listener port of the Gateway SHOULD be used.
             * * If redirect scheme is empty, the redirect port MUST be the Gateway
             *   Listener port.
             *
             *
             * Implementations SHOULD NOT add the port number in the 'Location'
             * header in the following cases:
             *
             *
             * * A Location header that will use HTTP (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 80.
             * * A Location header that will use HTTPS (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 443.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             *
             *
             * Scheme redirects can affect the port of the redirect, for more information,
             * refer to the documentation for the port field of this filter.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Extended
             */
            scheme?: pulumi.Input<string>;
            /**
             * StatusCode is the HTTP status code to be used in response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Core
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestRedirectArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestRedirectArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs): HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs {
            return {
                ...val,
                statusCode: (val.statusCode) ?? 302,
            };
        }

        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * URLRewrite defines a schema for a filter that modifies a request during forwarding.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs {
            /**
             * Hostname is the value to be used to replace the Host header value during
             * forwarding.
             *
             *
             * Support: Extended
             */
            hostname?: pulumi.Input<string>;
            /**
             * Path defines a path rewrite.
             *
             *
             * Support: Extended
             */
            path?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs>;
        }

        /**
         * Path defines a path rewrite.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * HTTPRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. HTTPRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface HTTPRouteSpecRulesFiltersArgs {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * This filter can be used multiple times within the same rule.
             *
             *
             * Support: Implementation-specific
             */
            extensionRef?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersExtensionRefArgs>;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs>;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestMirrorArgs>;
            /**
             * RequestRedirect defines a schema for a filter that responds to the
             * request with an HTTP redirection.
             *
             *
             * Support: Core
             */
            requestRedirect?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestRedirectArgs>;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs>;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations must support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by
             *   specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` should be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
            /**
             * URLRewrite defines a schema for a filter that modifies a request during forwarding.
             *
             *
             * Support: Extended
             */
            urlRewrite?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersUrlRewriteArgs>;
        }
        /**
         * httprouteSpecRulesFiltersArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersArgs
         */
        export function httprouteSpecRulesFiltersArgsProvideDefaults(val: HTTPRouteSpecRulesFiltersArgs): HTTPRouteSpecRulesFiltersArgs {
            return {
                ...val,
                requestMirror: (val.requestMirror ? pulumi.output(val.requestMirror).apply(inputs.gateway.v1.httprouteSpecRulesFiltersRequestMirrorArgsProvideDefaults) : undefined),
                requestRedirect: (val.requestRedirect ? pulumi.output(val.requestRedirect).apply(inputs.gateway.v1.httprouteSpecRulesFiltersRequestRedirectArgsProvideDefaults) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * This filter can be used multiple times within the same rule.
         *
         *
         * Support: Implementation-specific
         */
        export interface HTTPRouteSpecRulesFiltersExtensionRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersRequestMirrorArgs {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs>;
        }
        /**
         * httprouteSpecRulesFiltersRequestMirrorArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorArgs
         */
        export function httprouteSpecRulesFiltersRequestMirrorArgsProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestMirrorArgs): HTTPRouteSpecRulesFiltersRequestMirrorArgs {
            return {
                ...val,
                backendRef: pulumi.output(val.backendRef).apply(inputs.gateway.v1.httprouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs
         */
        export function httprouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs): HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * RequestRedirect defines a schema for a filter that responds to the
         * request with an HTTP redirection.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesFiltersRequestRedirectArgs {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             *
             *
             * Support: Core
             */
            hostname?: pulumi.Input<string>;
            /**
             * Path defines parameters used to modify the path of the incoming request.
             * The modified path is then used to construct the `Location` header. When
             * empty, the request path is used as-is.
             *
             *
             * Support: Extended
             */
            path?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersRequestRedirectPathArgs>;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             *
             * If no port is specified, the redirect port MUST be derived using the
             * following rules:
             *
             *
             * * If redirect scheme is not-empty, the redirect port MUST be the well-known
             *   port associated with the redirect scheme. Specifically "http" to port 80
             *   and "https" to port 443. If the redirect scheme does not have a
             *   well-known port, the listener port of the Gateway SHOULD be used.
             * * If redirect scheme is empty, the redirect port MUST be the Gateway
             *   Listener port.
             *
             *
             * Implementations SHOULD NOT add the port number in the 'Location'
             * header in the following cases:
             *
             *
             * * A Location header that will use HTTP (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 80.
             * * A Location header that will use HTTPS (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 443.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             *
             *
             * Scheme redirects can affect the port of the redirect, for more information,
             * refer to the documentation for the port field of this filter.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Extended
             */
            scheme?: pulumi.Input<string>;
            /**
             * StatusCode is the HTTP status code to be used in response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Core
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesFiltersRequestRedirectArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestRedirectArgs
         */
        export function httprouteSpecRulesFiltersRequestRedirectArgsProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestRedirectArgs): HTTPRouteSpecRulesFiltersRequestRedirectArgs {
            return {
                ...val,
                statusCode: (val.statusCode) ?? 302,
            };
        }

        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersRequestRedirectPathArgs {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * URLRewrite defines a schema for a filter that modifies a request during forwarding.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersUrlRewriteArgs {
            /**
             * Hostname is the value to be used to replace the Host header value during
             * forwarding.
             *
             *
             * Support: Extended
             */
            hostname?: pulumi.Input<string>;
            /**
             * Path defines a path rewrite.
             *
             *
             * Support: Extended
             */
            path?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesFiltersUrlRewritePathArgs>;
        }

        /**
         * Path defines a path rewrite.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersUrlRewritePathArgs {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * HTTPRouteMatch defines the predicate used to match requests to a given
         * action. Multiple match types are ANDed together, i.e. the match will
         * evaluate to true only if all conditions are satisfied.
         *
         *
         * For example, the match below will match a HTTP request only if its path
         * starts with `/foo` AND it contains the `version: v1` header:
         *
         *
         * ```
         * match:
         *
         *
         * 	path:
         * 	  value: "/foo"
         * 	headers:
         * 	- name: "version"
         * 	  value "v1"
         *
         *
         * ```
         */
        export interface HTTPRouteSpecRulesMatchesArgs {
            /**
             * Headers specifies HTTP request header matchers. Multiple match values are
             * ANDed together, meaning, a request must match all the specified headers
             * to select the route.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesMatchesHeadersArgs>[]>;
            /**
             * Method specifies HTTP method matcher.
             * When specified, this route will be matched only if the request has the
             * specified method.
             *
             *
             * Support: Extended
             */
            method?: pulumi.Input<string>;
            /**
             * Path specifies a HTTP request path matcher. If this field is not
             * specified, a default prefix match on the "/" path is provided.
             */
            path?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesMatchesPathArgs>;
            /**
             * QueryParams specifies HTTP query parameter matchers. Multiple match
             * values are ANDed together, meaning, a request must match all the
             * specified query parameters to select the route.
             *
             *
             * Support: Extended
             */
            queryParams?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesMatchesQueryParamsArgs>[]>;
        }
        /**
         * httprouteSpecRulesMatchesArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesArgs
         */
        export function httprouteSpecRulesMatchesArgsProvideDefaults(val: HTTPRouteSpecRulesMatchesArgs): HTTPRouteSpecRulesMatchesArgs {
            return {
                ...val,
                path: (val.path ? pulumi.output(val.path).apply(inputs.gateway.v1.httprouteSpecRulesMatchesPathArgsProvideDefaults) : undefined),
            };
        }

        /**
         * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
         * headers.
         */
        export interface HTTPRouteSpecRulesMatchesHeadersArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             *
             *
             * When a header is repeated in an HTTP request, it is
             * implementation-specific behavior as to how this is represented.
             * Generally, proxies should follow the guidance from the RFC:
             * https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
             * processing a repeated header, with special handling for "Set-Cookie".
             */
            name: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the header.
             *
             *
             * Support: Core (Exact)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             *
             *
             * Since RegularExpression HeaderMatchType has implementation-specific
             * conformance, implementations can support POSIX, PCRE or any other dialects
             * of regular expressions. Please read the implementation's documentation to
             * determine the supported dialect.
             */
            type?: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesMatchesHeadersArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesHeadersArgs
         */
        export function httprouteSpecRulesMatchesHeadersArgsProvideDefaults(val: HTTPRouteSpecRulesMatchesHeadersArgs): HTTPRouteSpecRulesMatchesHeadersArgs {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Path specifies a HTTP request path matcher. If this field is not
         * specified, a default prefix match on the "/" path is provided.
         */
        export interface HTTPRouteSpecRulesMatchesPathArgs {
            /**
             * Type specifies how to match against the path Value.
             *
             *
             * Support: Core (Exact, PathPrefix)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             */
            type?: pulumi.Input<string>;
            /**
             * Value of the HTTP path to match against.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesMatchesPathArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesPathArgs
         */
        export function httprouteSpecRulesMatchesPathArgsProvideDefaults(val: HTTPRouteSpecRulesMatchesPathArgs): HTTPRouteSpecRulesMatchesPathArgs {
            return {
                ...val,
                type: (val.type) ?? "PathPrefix",
                value: (val.value) ?? "/",
            };
        }

        /**
         * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
         * query parameters.
         */
        export interface HTTPRouteSpecRulesMatchesQueryParamsArgs {
            /**
             * Name is the name of the HTTP query param to be matched. This must be an
             * exact string match. (See
             * https://tools.ietf.org/html/rfc7230#section-2.7.3).
             *
             *
             * If multiple entries specify equivalent query param names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent query param name MUST be ignored.
             *
             *
             * If a query param is repeated in an HTTP request, the behavior is
             * purposely left undefined, since different data planes have different
             * capabilities. However, it is *recommended* that implementations should
             * match against the first value of the param if the data plane supports it,
             * as this behavior is expected in other load balancing contexts outside of
             * the Gateway API.
             *
             *
             * Users SHOULD NOT route traffic based on repeated query params to guard
             * themselves against potential differences in the implementations.
             */
            name: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the query parameter.
             *
             *
             * Support: Extended (Exact)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             *
             *
             * Since RegularExpression QueryParamMatchType has Implementation-specific
             * conformance, implementations can support POSIX, PCRE or any other
             * dialects of regular expressions. Please read the implementation's
             * documentation to determine the supported dialect.
             */
            type?: pulumi.Input<string>;
            /**
             * Value is the value of HTTP query param to be matched.
             */
            value: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesMatchesQueryParamsArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesQueryParamsArgs
         */
        export function httprouteSpecRulesMatchesQueryParamsArgsProvideDefaults(val: HTTPRouteSpecRulesMatchesQueryParamsArgs): HTTPRouteSpecRulesMatchesQueryParamsArgs {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the route rule.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesSessionPersistenceArgs {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: pulumi.Input<string>;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: pulumi.Input<inputs.gateway.v1.HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs>;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: pulumi.Input<string>;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesSessionPersistenceArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesSessionPersistenceArgs
         */
        export function httprouteSpecRulesSessionPersistenceArgsProvideDefaults(val: HTTPRouteSpecRulesSessionPersistenceArgs): HTTPRouteSpecRulesSessionPersistenceArgs {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? pulumi.output(val.cookieConfig).apply(inputs.gateway.v1.httprouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs
         */
        export function httprouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults(val: HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs): HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * Timeouts defines the timeouts that can be configured for an HTTP request.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesTimeoutsArgs {
            /**
             * BackendRequest specifies a timeout for an individual request from the gateway
             * to a backend. This covers the time from when the request first starts being
             * sent from the gateway to when the full response has been received from the backend.
             *
             *
             * Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
             * completely. Implementations that cannot completely disable the timeout MUST
             * instead interpret the zero duration as the longest possible value to which
             * the timeout can be set.
             *
             *
             * An entire client HTTP transaction with a gateway, covered by the Request timeout,
             * may result in more than one call from the gateway to the destination backend,
             * for example, if automatic retries are supported.
             *
             *
             * Because the Request timeout encompasses the BackendRequest timeout, the value of
             * BackendRequest must be <= the value of Request timeout.
             *
             *
             * Support: Extended
             */
            backendRequest?: pulumi.Input<string>;
            /**
             * Request specifies the maximum duration for a gateway to respond to an HTTP request.
             * If the gateway has not been able to respond before this deadline is met, the gateway
             * MUST return a timeout error.
             *
             *
             * For example, setting the `rules.timeouts.request` field to the value `10s` in an
             * `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
             * to complete.
             *
             *
             * Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
             * completely. Implementations that cannot completely disable the timeout MUST
             * instead interpret the zero duration as the longest possible value to which
             * the timeout can be set.
             *
             *
             * This timeout is intended to cover as close to the whole request-response transaction
             * as possible although an implementation MAY choose to start the timeout after the entire
             * request stream has been received instead of immediately after the transaction is
             * initiated by the client.
             *
             *
             * When this field is unspecified, request timeout behavior is implementation-specific.
             *
             *
             * Support: Extended
             */
            request?: pulumi.Input<string>;
        }

        /**
         * Status defines the current state of HTTPRoute.
         */
        export interface HTTPRouteStatusArgs {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteStatusParentsArgs>[]>;
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface HTTPRouteStatusParentsArgs {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1.HTTPRouteStatusParentsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: pulumi.Input<inputs.gateway.v1.HTTPRouteStatusParentsParentRefArgs>;
        }
        /**
         * httprouteStatusParentsArgsProvideDefaults sets the appropriate defaults for HTTPRouteStatusParentsArgs
         */
        export function httprouteStatusParentsArgsProvideDefaults(val: HTTPRouteStatusParentsArgs): HTTPRouteStatusParentsArgs {
            return {
                ...val,
                parentRef: pulumi.output(val.parentRef).apply(inputs.gateway.v1.httprouteStatusParentsParentRefArgsProvideDefaults),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface HTTPRouteStatusParentsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface HTTPRouteStatusParentsParentRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * httprouteStatusParentsParentRefArgsProvideDefaults sets the appropriate defaults for HTTPRouteStatusParentsParentRefArgs
         */
        export function httprouteStatusParentsParentRefArgsProvideDefaults(val: HTTPRouteStatusParentsParentRefArgs): HTTPRouteStatusParentsParentRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }
    }

    export namespace v1alpha2 {
        /**
         * Spec defines the desired state of BackendLBPolicy.
         */
        export interface BackendLBPolicySpecArgs {
            /**
             * SessionPersistence defines and configures session persistence
             * for the backend.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: pulumi.Input<inputs.gateway.v1alpha2.BackendLBPolicySpecSessionPersistenceArgs>;
            /**
             * TargetRef identifies an API object to apply policy to.
             * Currently, Backends (i.e. Service, ServiceImport, or any
             * implementation-specific backendRef) are the only valid API
             * target references.
             */
            targetRefs: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.BackendLBPolicySpecTargetRefsArgs>[]>;
        }
        /**
         * backendLBPolicySpecArgsProvideDefaults sets the appropriate defaults for BackendLBPolicySpecArgs
         */
        export function backendLBPolicySpecArgsProvideDefaults(val: BackendLBPolicySpecArgs): BackendLBPolicySpecArgs {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? pulumi.output(val.sessionPersistence).apply(inputs.gateway.v1alpha2.backendLBPolicySpecSessionPersistenceArgsProvideDefaults) : undefined),
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the backend.
         *
         *
         * Support: Extended
         */
        export interface BackendLBPolicySpecSessionPersistenceArgs {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: pulumi.Input<string>;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: pulumi.Input<inputs.gateway.v1alpha2.BackendLBPolicySpecSessionPersistenceCookieConfigArgs>;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: pulumi.Input<string>;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: pulumi.Input<string>;
        }
        /**
         * backendLBPolicySpecSessionPersistenceArgsProvideDefaults sets the appropriate defaults for BackendLBPolicySpecSessionPersistenceArgs
         */
        export function backendLBPolicySpecSessionPersistenceArgsProvideDefaults(val: BackendLBPolicySpecSessionPersistenceArgs): BackendLBPolicySpecSessionPersistenceArgs {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? pulumi.output(val.cookieConfig).apply(inputs.gateway.v1alpha2.backendLBPolicySpecSessionPersistenceCookieConfigArgsProvideDefaults) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface BackendLBPolicySpecSessionPersistenceCookieConfigArgs {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: pulumi.Input<string>;
        }
        /**
         * backendLBPolicySpecSessionPersistenceCookieConfigArgsProvideDefaults sets the appropriate defaults for BackendLBPolicySpecSessionPersistenceCookieConfigArgs
         */
        export function backendLBPolicySpecSessionPersistenceCookieConfigArgsProvideDefaults(val: BackendLBPolicySpecSessionPersistenceCookieConfigArgs): BackendLBPolicySpecSessionPersistenceCookieConfigArgs {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * LocalPolicyTargetReference identifies an API object to apply a direct or
         * inherited policy to. This should be used as part of Policy resources
         * that can target Gateway API resources. For more information on how this
         * policy attachment model works, and a sample Policy resource, refer to
         * the policy attachment documentation for Gateway API.
         */
        export interface BackendLBPolicySpecTargetRefsArgs {
            /**
             * Group is the group of the target resource.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name: pulumi.Input<string>;
        }

        /**
         * Status defines the current state of BackendLBPolicy.
         */
        export interface BackendLBPolicyStatusArgs {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.BackendLBPolicyStatusAncestorsArgs>[]>;
        }

        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        export interface BackendLBPolicyStatusAncestorsArgs {
            /**
             * AncestorRef corresponds with a ParentRef in the spec that this
             * PolicyAncestorStatus struct describes the status of.
             */
            ancestorRef: pulumi.Input<inputs.gateway.v1alpha2.BackendLBPolicyStatusAncestorsAncestorRefArgs>;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.BackendLBPolicyStatusAncestorsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
        }
        /**
         * backendLBPolicyStatusAncestorsArgsProvideDefaults sets the appropriate defaults for BackendLBPolicyStatusAncestorsArgs
         */
        export function backendLBPolicyStatusAncestorsArgsProvideDefaults(val: BackendLBPolicyStatusAncestorsArgs): BackendLBPolicyStatusAncestorsArgs {
            return {
                ...val,
                ancestorRef: pulumi.output(val.ancestorRef).apply(inputs.gateway.v1alpha2.backendLBPolicyStatusAncestorsAncestorRefArgsProvideDefaults),
            };
        }

        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        export interface BackendLBPolicyStatusAncestorsAncestorRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * backendLBPolicyStatusAncestorsAncestorRefArgsProvideDefaults sets the appropriate defaults for BackendLBPolicyStatusAncestorsAncestorRefArgs
         */
        export function backendLBPolicyStatusAncestorsAncestorRefArgsProvideDefaults(val: BackendLBPolicyStatusAncestorsAncestorRefArgs): BackendLBPolicyStatusAncestorsAncestorRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface BackendLBPolicyStatusAncestorsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * Spec defines the desired state of GRPCRoute.
         */
        export interface GRPCRouteSpecArgs {
            /**
             * Hostnames defines a set of hostnames to match against the GRPC
             * Host header to select a GRPCRoute to process the request. This matches
             * the RFC 1123 definition of a hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label MUST appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and GRPCRoute, there
             * MUST be at least one intersecting hostname for the GRPCRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches GRPCRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches GRPCRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `test.example.com` and `*.example.com` would both match. On the other
             *   hand, `example.com` and `test.example.net` would not match.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * If both the Listener and GRPCRoute have specified hostnames, any
             * GRPCRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * GRPCRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` MUST NOT be considered for a match.
             *
             *
             * If both the Listener and GRPCRoute have specified hostnames, and none
             * match with the criteria above, then the GRPCRoute MUST NOT be accepted by
             * the implementation. The implementation MUST raise an 'Accepted' Condition
             * with a status of `False` in the corresponding RouteParentStatus.
             *
             *
             * If a Route (A) of type HTTPRoute or GRPCRoute is attached to a
             * Listener and that listener already has another Route (B) of the other
             * type attached and the intersection of the hostnames of A and B is
             * non-empty, then the implementation MUST accept exactly one of these two
             * routes, determined by the following criteria, in order:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * The rejected Route MUST raise an 'Accepted' condition with a status of
             * 'False' in the corresponding RouteParentStatus.
             *
             *
             * Support: Core
             */
            hostnames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecParentRefsArgs>[]>;
            /**
             * Rules are a list of GRPC matchers, filters and actions.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesArgs>[]>;
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface GRPCRouteSpecParentRefsArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecParentRefsArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecParentRefsArgs
         */
        export function grpcrouteSpecParentRefsArgsProvideDefaults(val: GRPCRouteSpecParentRefsArgs): GRPCRouteSpecParentRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * GRPCRouteRule defines the semantics for matching a gRPC request based on
         * conditions (matches), processing it (filters), and forwarding the request to
         * an API object (backendRefs).
         */
        export interface GRPCRouteSpecRulesArgs {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent.
             *
             *
             * Failure behavior here depends on how many BackendRefs are specified and
             * how many are invalid.
             *
             *
             * If *all* entries in BackendRefs are invalid, and there are also no filters
             * specified in this route rule, *all* traffic which matches this rule MUST
             * receive an `UNAVAILABLE` status.
             *
             *
             * See the GRPCBackendRef definition for the rules about what makes a single
             * GRPCBackendRef invalid.
             *
             *
             * When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for
             * requests that would have otherwise been routed to an invalid backend. If
             * multiple backends are specified, and some are invalid, the proportion of
             * requests that would otherwise have been routed to an invalid backend
             * MUST receive an `UNAVAILABLE` status.
             *
             *
             * For example, if two backends are specified with equal weights, and one is
             * invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status.
             * Implementations may choose how that 50 percent is determined.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Core
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsArgs>[]>;
            /**
             * Filters define the filters that are applied to requests that match
             * this rule.
             *
             *
             * The effects of ordering of multiple behaviors are currently unspecified.
             * This can change in the future based on feedback during the alpha stage.
             *
             *
             * Conformance-levels at this level are defined based on the type of filter:
             *
             *
             * - ALL core filters MUST be supported by all implementations that support
             *   GRPCRoute.
             * - Implementers are encouraged to support extended filters.
             * - Implementation-specific custom filters have no API guarantees across
             *   implementations.
             *
             *
             * Specifying the same filter multiple times is not supported unless explicitly
             * indicated in the filter.
             *
             *
             * If an implementation can not support a combination of filters, it must clearly
             * document that limitation. In cases where incompatible or unsupported
             * filters are specified and cause the `Accepted` condition to be set to status
             * `False`, implementations may use the `IncompatibleFilters` reason to specify
             * this configuration error.
             *
             *
             * Support: Core
             */
            filters?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersArgs>[]>;
            /**
             * Matches define conditions used for matching the rule against incoming
             * gRPC requests. Each match is independent, i.e. this rule will be matched
             * if **any** one of the matches is satisfied.
             *
             *
             * For example, take the following matches configuration:
             *
             *
             * ```
             * matches:
             * - method:
             *     service: foo.bar
             *   headers:
             *     values:
             *       version: 2
             * - method:
             *     service: foo.bar.v2
             * ```
             *
             *
             * For a request to match against this rule, it MUST satisfy
             * EITHER of the two conditions:
             *
             *
             * - service of foo.bar AND contains the header `version: 2`
             * - service of foo.bar.v2
             *
             *
             * See the documentation for GRPCRouteMatch on how to specify multiple
             * match conditions to be ANDed together.
             *
             *
             * If no matches are specified, the implementation MUST match every gRPC request.
             *
             *
             * Proxy or Load Balancer routing configuration generated from GRPCRoutes
             * MUST prioritize rules based on the following criteria, continuing on
             * ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes.
             * Precedence MUST be given to the rule with the largest number of:
             *
             *
             * * Characters in a matching non-wildcard hostname.
             * * Characters in a matching hostname.
             * * Characters in a matching service.
             * * Characters in a matching method.
             * * Header matches.
             *
             *
             * If ties still exist across multiple Routes, matching precedence MUST be
             * determined in order of the following criteria, continuing on ties:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * If ties still exist within the Route that has been given precedence,
             * matching precedence MUST be granted to the first matching rule meeting
             * the above criteria.
             */
            matches?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesMatchesArgs>[]>;
            /**
             * SessionPersistence defines and configures session persistence
             * for the route rule.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesSessionPersistenceArgs>;
        }
        /**
         * grpcrouteSpecRulesArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesArgs
         */
        export function grpcrouteSpecRulesArgsProvideDefaults(val: GRPCRouteSpecRulesArgs): GRPCRouteSpecRulesArgs {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? pulumi.output(val.sessionPersistence).apply(inputs.gateway.v1alpha2.grpcrouteSpecRulesSessionPersistenceArgsProvideDefaults) : undefined),
            };
        }

        /**
         * GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         */
        export interface GRPCRouteSpecRulesBackendRefsArgs {
            /**
             * Filters defined at this level MUST be executed if and only if the
             * request is being forwarded to the backend defined here.
             *
             *
             * Support: Implementation-specific (For broader support of filters, use the
             * Filters field in GRPCRouteRule.)
             */
            filters?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersArgs>[]>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * grpcrouteSpecRulesBackendRefsArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsArgs
         */
        export function grpcrouteSpecRulesBackendRefsArgsProvideDefaults(val: GRPCRouteSpecRulesBackendRefsArgs): GRPCRouteSpecRulesBackendRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. GRPCRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersArgs {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * Support: Implementation-specific
             *
             *
             * This filter can be used multiple times within the same rule.
             */
            extensionRef?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs>;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs>;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs>;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs>;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations supporting GRPCRoute MUST support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` MUST be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             */
            type: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersArgs
         */
        export function grpcrouteSpecRulesBackendRefsFiltersArgsProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersArgs): GRPCRouteSpecRulesBackendRefsFiltersArgs {
            return {
                ...val,
                requestMirror: (val.requestMirror ? pulumi.output(val.requestMirror).apply(inputs.gateway.v1alpha2.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * Support: Implementation-specific
         *
         *
         * This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs>;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs): GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
            return {
                ...val,
                backendRef: pulumi.output(val.backendRef).apply(inputs.gateway.v1alpha2.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs): GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. GRPCRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesFiltersArgs {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * Support: Implementation-specific
             *
             *
             * This filter can be used multiple times within the same rule.
             */
            extensionRef?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersExtensionRefArgs>;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs>;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestMirrorArgs>;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs>;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations supporting GRPCRoute MUST support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` MUST be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             */
            type: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesFiltersArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersArgs
         */
        export function grpcrouteSpecRulesFiltersArgsProvideDefaults(val: GRPCRouteSpecRulesFiltersArgs): GRPCRouteSpecRulesFiltersArgs {
            return {
                ...val,
                requestMirror: (val.requestMirror ? pulumi.output(val.requestMirror).apply(inputs.gateway.v1alpha2.grpcrouteSpecRulesFiltersRequestMirrorArgsProvideDefaults) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * Support: Implementation-specific
         *
         *
         * This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesFiltersExtensionRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirrorArgs {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs>;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorArgs
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorArgsProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirrorArgs): GRPCRouteSpecRulesFiltersRequestMirrorArgs {
            return {
                ...val,
                backendRef: pulumi.output(val.backendRef).apply(inputs.gateway.v1alpha2.grpcrouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs): GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * GRPCRouteMatch defines the predicate used to match requests to a given
         * action. Multiple match types are ANDed together, i.e. the match will
         * evaluate to true only if all conditions are satisfied.
         *
         *
         * For example, the match below will match a gRPC request only if its service
         * is `foo` AND it contains the `version: v1` header:
         *
         *
         * ```
         * matches:
         *   - method:
         *     type: Exact
         *     service: "foo"
         *     headers:
         *   - name: "version"
         *     value "v1"
         *
         *
         * ```
         */
        export interface GRPCRouteSpecRulesMatchesArgs {
            /**
             * Headers specifies gRPC request header matchers. Multiple match values are
             * ANDed together, meaning, a request MUST match all the specified headers
             * to select the route.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesMatchesHeadersArgs>[]>;
            /**
             * Method specifies a gRPC request service/method matcher. If this field is
             * not specified, all services and methods will match.
             */
            method?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesMatchesMethodArgs>;
        }
        /**
         * grpcrouteSpecRulesMatchesArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesArgs
         */
        export function grpcrouteSpecRulesMatchesArgsProvideDefaults(val: GRPCRouteSpecRulesMatchesArgs): GRPCRouteSpecRulesMatchesArgs {
            return {
                ...val,
                method: (val.method ? pulumi.output(val.method).apply(inputs.gateway.v1alpha2.grpcrouteSpecRulesMatchesMethodArgsProvideDefaults) : undefined),
            };
        }

        /**
         * GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request
         * headers.
         */
        export interface GRPCRouteSpecRulesMatchesHeadersArgs {
            /**
             * Name is the name of the gRPC Header to be matched.
             *
             *
             * If multiple entries specify equivalent header names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: pulumi.Input<string>;
            /**
             * Value is the value of the gRPC Header to be matched.
             */
            value: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesMatchesHeadersArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeadersArgs
         */
        export function grpcrouteSpecRulesMatchesHeadersArgsProvideDefaults(val: GRPCRouteSpecRulesMatchesHeadersArgs): GRPCRouteSpecRulesMatchesHeadersArgs {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Method specifies a gRPC request service/method matcher. If this field is
         * not specified, all services and methods will match.
         */
        export interface GRPCRouteSpecRulesMatchesMethodArgs {
            /**
             * Value of the method to match against. If left empty or omitted, will
             * match all services.
             *
             *
             * At least one of Service and Method MUST be a non-empty string.
             */
            method?: pulumi.Input<string>;
            /**
             * Value of the service to match against. If left empty or omitted, will
             * match any service.
             *
             *
             * At least one of Service and Method MUST be a non-empty string.
             */
            service?: pulumi.Input<string>;
            /**
             * Type specifies how to match against the service and/or method.
             * Support: Core (Exact with service and method specified)
             *
             *
             * Support: Implementation-specific (Exact with method specified but no service specified)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             */
            type?: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesMatchesMethodArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethodArgs
         */
        export function grpcrouteSpecRulesMatchesMethodArgsProvideDefaults(val: GRPCRouteSpecRulesMatchesMethodArgs): GRPCRouteSpecRulesMatchesMethodArgs {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the route rule.
         *
         *
         * Support: Extended
         */
        export interface GRPCRouteSpecRulesSessionPersistenceArgs {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: pulumi.Input<string>;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs>;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: pulumi.Input<string>;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesSessionPersistenceArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesSessionPersistenceArgs
         */
        export function grpcrouteSpecRulesSessionPersistenceArgsProvideDefaults(val: GRPCRouteSpecRulesSessionPersistenceArgs): GRPCRouteSpecRulesSessionPersistenceArgs {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? pulumi.output(val.cookieConfig).apply(inputs.gateway.v1alpha2.grpcrouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: pulumi.Input<string>;
        }
        /**
         * grpcrouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs
         */
        export function grpcrouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults(val: GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs): GRPCRouteSpecRulesSessionPersistenceCookieConfigArgs {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * Status defines the current state of GRPCRoute.
         */
        export interface GRPCRouteStatusArgs {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteStatusParentsArgs>[]>;
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface GRPCRouteStatusParentsArgs {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteStatusParentsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: pulumi.Input<inputs.gateway.v1alpha2.GRPCRouteStatusParentsParentRefArgs>;
        }
        /**
         * grpcrouteStatusParentsArgsProvideDefaults sets the appropriate defaults for GRPCRouteStatusParentsArgs
         */
        export function grpcrouteStatusParentsArgsProvideDefaults(val: GRPCRouteStatusParentsArgs): GRPCRouteStatusParentsArgs {
            return {
                ...val,
                parentRef: pulumi.output(val.parentRef).apply(inputs.gateway.v1alpha2.grpcrouteStatusParentsParentRefArgsProvideDefaults),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GRPCRouteStatusParentsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface GRPCRouteStatusParentsParentRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * grpcrouteStatusParentsParentRefArgsProvideDefaults sets the appropriate defaults for GRPCRouteStatusParentsParentRefArgs
         */
        export function grpcrouteStatusParentsParentRefArgsProvideDefaults(val: GRPCRouteStatusParentsParentRefArgs): GRPCRouteStatusParentsParentRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of ReferenceGrant.
         */
        export interface ReferenceGrantSpecArgs {
            /**
             * From describes the trusted namespaces and kinds that can reference the
             * resources described in "To". Each entry in this list MUST be considered
             * to be an additional place that references can be valid from, or to put
             * this another way, entries MUST be combined using OR.
             *
             *
             * Support: Core
             */
            from: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.ReferenceGrantSpecFromArgs>[]>;
            /**
             * To describes the resources that may be referenced by the resources
             * described in "From". Each entry in this list MUST be considered to be an
             * additional place that references can be valid to, or to put this another
             * way, entries MUST be combined using OR.
             *
             *
             * Support: Core
             */
            to: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.ReferenceGrantSpecToArgs>[]>;
        }

        /**
         * ReferenceGrantFrom describes trusted namespaces and kinds.
         */
        export interface ReferenceGrantSpecFromArgs {
            /**
             * Group is the group of the referent.
             * When empty, the Kubernetes core API group is inferred.
             *
             *
             * Support: Core
             */
            group: pulumi.Input<string>;
            /**
             * Kind is the kind of the referent. Although implementations may support
             * additional resources, the following types are part of the "Core"
             * support level for this field.
             *
             *
             * When used to permit a SecretObjectReference:
             *
             *
             * * Gateway
             *
             *
             * When used to permit a BackendObjectReference:
             *
             *
             * * GRPCRoute
             * * HTTPRoute
             * * TCPRoute
             * * TLSRoute
             * * UDPRoute
             */
            kind: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent.
             *
             *
             * Support: Core
             */
            namespace: pulumi.Input<string>;
        }

        /**
         * ReferenceGrantTo describes what Kinds are allowed as targets of the
         * references.
         */
        export interface ReferenceGrantSpecToArgs {
            /**
             * Group is the group of the referent.
             * When empty, the Kubernetes core API group is inferred.
             *
             *
             * Support: Core
             */
            group: pulumi.Input<string>;
            /**
             * Kind is the kind of the referent. Although implementations may support
             * additional resources, the following types are part of the "Core"
             * support level for this field:
             *
             *
             * * Secret when used to permit a SecretObjectReference
             * * Service when used to permit a BackendObjectReference
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent. When unspecified, this policy
             * refers to all resources of the specified Group and Kind in the local
             * namespace.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * Spec defines the desired state of TCPRoute.
         */
        export interface TCPRouteSpecArgs {
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TCPRouteSpecParentRefsArgs>[]>;
            /**
             * Rules are a list of TCP matchers and actions.
             */
            rules: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TCPRouteSpecRulesArgs>[]>;
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface TCPRouteSpecParentRefsArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * tcprouteSpecParentRefsArgsProvideDefaults sets the appropriate defaults for TCPRouteSpecParentRefsArgs
         */
        export function tcprouteSpecParentRefsArgsProvideDefaults(val: TCPRouteSpecParentRefsArgs): TCPRouteSpecParentRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * TCPRouteRule is the configuration for a given rule.
         */
        export interface TCPRouteSpecRulesArgs {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent. If unspecified or invalid (refers to a non-existent resource or a
             * Service with no endpoints), the underlying implementation MUST actively
             * reject connection attempts to this backend. Connection rejections must
             * respect weight; if an invalid backend is requested to have 80% of
             * connections, then 80% of connections must be rejected instead.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Extended
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TCPRouteSpecRulesBackendRefsArgs>[]>;
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes
         * resource.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         *
         *
         * Note that when the BackendTLSPolicy object is enabled by the implementation,
         * there are some extra rules about validity to consider here. See the fields
         * where this struct is used for more information about the exact behavior.
         */
        export interface TCPRouteSpecRulesBackendRefsArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * tcprouteSpecRulesBackendRefsArgsProvideDefaults sets the appropriate defaults for TCPRouteSpecRulesBackendRefsArgs
         */
        export function tcprouteSpecRulesBackendRefsArgsProvideDefaults(val: TCPRouteSpecRulesBackendRefsArgs): TCPRouteSpecRulesBackendRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of TCPRoute.
         */
        export interface TCPRouteStatusArgs {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TCPRouteStatusParentsArgs>[]>;
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface TCPRouteStatusParentsArgs {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TCPRouteStatusParentsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: pulumi.Input<inputs.gateway.v1alpha2.TCPRouteStatusParentsParentRefArgs>;
        }
        /**
         * tcprouteStatusParentsArgsProvideDefaults sets the appropriate defaults for TCPRouteStatusParentsArgs
         */
        export function tcprouteStatusParentsArgsProvideDefaults(val: TCPRouteStatusParentsArgs): TCPRouteStatusParentsArgs {
            return {
                ...val,
                parentRef: pulumi.output(val.parentRef).apply(inputs.gateway.v1alpha2.tcprouteStatusParentsParentRefArgsProvideDefaults),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface TCPRouteStatusParentsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface TCPRouteStatusParentsParentRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * tcprouteStatusParentsParentRefArgsProvideDefaults sets the appropriate defaults for TCPRouteStatusParentsParentRefArgs
         */
        export function tcprouteStatusParentsParentRefArgsProvideDefaults(val: TCPRouteStatusParentsParentRefArgs): TCPRouteStatusParentsParentRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of TLSRoute.
         */
        export interface TLSRouteSpecArgs {
            /**
             * Hostnames defines a set of SNI names that should match against the
             * SNI attribute of TLS ClientHello message in TLS handshake. This matches
             * the RFC 1123 definition of a hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed in SNI names per RFC 6066.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label must appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and TLSRoute, there
             * must be at least one intersecting hostname for the TLSRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches TLSRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches TLSRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `test.example.com` and `*.example.com` would both match. On the other
             *   hand, `example.com` and `test.example.net` would not match.
             *
             *
             * If both the Listener and TLSRoute have specified hostnames, any
             * TLSRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * TLSRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` must not be considered for a match.
             *
             *
             * If both the Listener and TLSRoute have specified hostnames, and none
             * match with the criteria above, then the TLSRoute is not accepted. The
             * implementation must raise an 'Accepted' Condition with a status of
             * `False` in the corresponding RouteParentStatus.
             *
             *
             * Support: Core
             */
            hostnames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TLSRouteSpecParentRefsArgs>[]>;
            /**
             * Rules are a list of TLS matchers and actions.
             */
            rules: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TLSRouteSpecRulesArgs>[]>;
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface TLSRouteSpecParentRefsArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * tlsrouteSpecParentRefsArgsProvideDefaults sets the appropriate defaults for TLSRouteSpecParentRefsArgs
         */
        export function tlsrouteSpecParentRefsArgsProvideDefaults(val: TLSRouteSpecParentRefsArgs): TLSRouteSpecParentRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * TLSRouteRule is the configuration for a given rule.
         */
        export interface TLSRouteSpecRulesArgs {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent. If unspecified or invalid (refers to a non-existent resource or
             * a Service with no endpoints), the rule performs no forwarding; if no
             * filters are specified that would result in a response being sent, the
             * underlying implementation must actively reject request attempts to this
             * backend, by rejecting the connection or returning a 500 status code.
             * Request rejections must respect weight; if an invalid backend is
             * requested to have 80% of requests, then 80% of requests must be rejected
             * instead.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Extended
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TLSRouteSpecRulesBackendRefsArgs>[]>;
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes
         * resource.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         *
         *
         * Note that when the BackendTLSPolicy object is enabled by the implementation,
         * there are some extra rules about validity to consider here. See the fields
         * where this struct is used for more information about the exact behavior.
         */
        export interface TLSRouteSpecRulesBackendRefsArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * tlsrouteSpecRulesBackendRefsArgsProvideDefaults sets the appropriate defaults for TLSRouteSpecRulesBackendRefsArgs
         */
        export function tlsrouteSpecRulesBackendRefsArgsProvideDefaults(val: TLSRouteSpecRulesBackendRefsArgs): TLSRouteSpecRulesBackendRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of TLSRoute.
         */
        export interface TLSRouteStatusArgs {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TLSRouteStatusParentsArgs>[]>;
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface TLSRouteStatusParentsArgs {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.TLSRouteStatusParentsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: pulumi.Input<inputs.gateway.v1alpha2.TLSRouteStatusParentsParentRefArgs>;
        }
        /**
         * tlsrouteStatusParentsArgsProvideDefaults sets the appropriate defaults for TLSRouteStatusParentsArgs
         */
        export function tlsrouteStatusParentsArgsProvideDefaults(val: TLSRouteStatusParentsArgs): TLSRouteStatusParentsArgs {
            return {
                ...val,
                parentRef: pulumi.output(val.parentRef).apply(inputs.gateway.v1alpha2.tlsrouteStatusParentsParentRefArgsProvideDefaults),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface TLSRouteStatusParentsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface TLSRouteStatusParentsParentRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * tlsrouteStatusParentsParentRefArgsProvideDefaults sets the appropriate defaults for TLSRouteStatusParentsParentRefArgs
         */
        export function tlsrouteStatusParentsParentRefArgsProvideDefaults(val: TLSRouteStatusParentsParentRefArgs): TLSRouteStatusParentsParentRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of UDPRoute.
         */
        export interface UDPRouteSpecArgs {
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.UDPRouteSpecParentRefsArgs>[]>;
            /**
             * Rules are a list of UDP matchers and actions.
             */
            rules: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.UDPRouteSpecRulesArgs>[]>;
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface UDPRouteSpecParentRefsArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * udprouteSpecParentRefsArgsProvideDefaults sets the appropriate defaults for UDPRouteSpecParentRefsArgs
         */
        export function udprouteSpecParentRefsArgsProvideDefaults(val: UDPRouteSpecParentRefsArgs): UDPRouteSpecParentRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * UDPRouteRule is the configuration for a given rule.
         */
        export interface UDPRouteSpecRulesArgs {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent. If unspecified or invalid (refers to a non-existent resource or a
             * Service with no endpoints), the underlying implementation MUST actively
             * reject connection attempts to this backend. Packet drops must
             * respect weight; if an invalid backend is requested to have 80% of
             * the packets, then 80% of packets must be dropped instead.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Extended
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.UDPRouteSpecRulesBackendRefsArgs>[]>;
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes
         * resource.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         *
         *
         * Note that when the BackendTLSPolicy object is enabled by the implementation,
         * there are some extra rules about validity to consider here. See the fields
         * where this struct is used for more information about the exact behavior.
         */
        export interface UDPRouteSpecRulesBackendRefsArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * udprouteSpecRulesBackendRefsArgsProvideDefaults sets the appropriate defaults for UDPRouteSpecRulesBackendRefsArgs
         */
        export function udprouteSpecRulesBackendRefsArgsProvideDefaults(val: UDPRouteSpecRulesBackendRefsArgs): UDPRouteSpecRulesBackendRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of UDPRoute.
         */
        export interface UDPRouteStatusArgs {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.UDPRouteStatusParentsArgs>[]>;
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface UDPRouteStatusParentsArgs {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha2.UDPRouteStatusParentsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: pulumi.Input<inputs.gateway.v1alpha2.UDPRouteStatusParentsParentRefArgs>;
        }
        /**
         * udprouteStatusParentsArgsProvideDefaults sets the appropriate defaults for UDPRouteStatusParentsArgs
         */
        export function udprouteStatusParentsArgsProvideDefaults(val: UDPRouteStatusParentsArgs): UDPRouteStatusParentsArgs {
            return {
                ...val,
                parentRef: pulumi.output(val.parentRef).apply(inputs.gateway.v1alpha2.udprouteStatusParentsParentRefArgsProvideDefaults),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface UDPRouteStatusParentsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface UDPRouteStatusParentsParentRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * udprouteStatusParentsParentRefArgsProvideDefaults sets the appropriate defaults for UDPRouteStatusParentsParentRefArgs
         */
        export function udprouteStatusParentsParentRefArgsProvideDefaults(val: UDPRouteStatusParentsParentRefArgs): UDPRouteStatusParentsParentRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }
    }

    export namespace v1alpha3 {
        /**
         * Spec defines the desired state of BackendTLSPolicy.
         */
        export interface BackendTLSPolicySpecArgs {
            /**
             * TargetRefs identifies an API object to apply the policy to.
             * Only Services have Extended support. Implementations MAY support
             * additional objects, with Implementation Specific support.
             * Note that this config applies to the entire referenced resource
             * by default, but this default may change in the future to provide
             * a more granular application of the policy.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            targetRefs: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha3.BackendTLSPolicySpecTargetRefsArgs>[]>;
            /**
             * Validation contains backend TLS validation configuration.
             */
            validation: pulumi.Input<inputs.gateway.v1alpha3.BackendTLSPolicySpecValidationArgs>;
        }

        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        export interface BackendTLSPolicySpecTargetRefsArgs {
            /**
             * Group is the group of the target resource.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }

        /**
         * Validation contains backend TLS validation configuration.
         */
        export interface BackendTLSPolicySpecValidationArgs {
            /**
             * CACertificateRefs contains one or more references to Kubernetes objects that
             * contain a PEM-encoded TLS CA certificate bundle, which is used to
             * validate a TLS handshake between the Gateway and backend Pod.
             *
             *
             * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
             * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
             * not both. If CACertifcateRefs is empty or unspecified, the configuration for
             * WellKnownCACertificates MUST be honored instead if supported by the implementation.
             *
             *
             * References to a resource in a different namespace are invalid for the
             * moment, although we will revisit this in the future.
             *
             *
             * A single CACertificateRef to a Kubernetes ConfigMap kind has "Core" support.
             * Implementations MAY choose to support attaching multiple certificates to
             * a backend, but this behavior is implementation-specific.
             *
             *
             * Support: Core - An optional single reference to a Kubernetes ConfigMap,
             * with the CA certificate in a key named `ca.crt`.
             *
             *
             * Support: Implementation-specific (More than one reference, or other kinds
             * of resources).
             */
            caCertificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha3.BackendTLSPolicySpecValidationCaCertificateRefsArgs>[]>;
            /**
             * Hostname is used for two purposes in the connection between Gateways and
             * backends:
             *
             *
             * 1. Hostname MUST be used as the SNI to connect to the backend (RFC 6066).
             * 2. Hostname MUST be used for authentication and MUST match the certificate
             *    served by the matching backend.
             *
             *
             * Support: Core
             */
            hostname: pulumi.Input<string>;
            /**
             * WellKnownCACertificates specifies whether system CA certificates may be used in
             * the TLS handshake between the gateway and backend pod.
             *
             *
             * If WellKnownCACertificates is unspecified or empty (""), then CACertificateRefs
             * must be specified with at least one entry for a valid configuration. Only one of
             * CACertificateRefs or WellKnownCACertificates may be specified, not both. If an
             * implementation does not support the WellKnownCACertificates field or the value
             * supplied is not supported, the Status Conditions on the Policy MUST be
             * updated to include an Accepted: False Condition with Reason: Invalid.
             *
             *
             * Support: Implementation-specific
             */
            wellKnownCACertificates?: pulumi.Input<string>;
        }

        /**
         * LocalObjectReference identifies an API object within the namespace of the
         * referrer.
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface BackendTLSPolicySpecValidationCaCertificateRefsArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * Status defines the current state of BackendTLSPolicy.
         */
        export interface BackendTLSPolicyStatusArgs {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha3.BackendTLSPolicyStatusAncestorsArgs>[]>;
        }

        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        export interface BackendTLSPolicyStatusAncestorsArgs {
            /**
             * AncestorRef corresponds with a ParentRef in the spec that this
             * PolicyAncestorStatus struct describes the status of.
             */
            ancestorRef: pulumi.Input<inputs.gateway.v1alpha3.BackendTLSPolicyStatusAncestorsAncestorRefArgs>;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha3.BackendTLSPolicyStatusAncestorsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
        }
        /**
         * backendTLSPolicyStatusAncestorsArgsProvideDefaults sets the appropriate defaults for BackendTLSPolicyStatusAncestorsArgs
         */
        export function backendTLSPolicyStatusAncestorsArgsProvideDefaults(val: BackendTLSPolicyStatusAncestorsArgs): BackendTLSPolicyStatusAncestorsArgs {
            return {
                ...val,
                ancestorRef: pulumi.output(val.ancestorRef).apply(inputs.gateway.v1alpha3.backendTLSPolicyStatusAncestorsAncestorRefArgsProvideDefaults),
            };
        }

        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        export interface BackendTLSPolicyStatusAncestorsAncestorRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * backendTLSPolicyStatusAncestorsAncestorRefArgsProvideDefaults sets the appropriate defaults for BackendTLSPolicyStatusAncestorsAncestorRefArgs
         */
        export function backendTLSPolicyStatusAncestorsAncestorRefArgsProvideDefaults(val: BackendTLSPolicyStatusAncestorsAncestorRefArgs): BackendTLSPolicyStatusAncestorsAncestorRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface BackendTLSPolicyStatusAncestorsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }
    }

    export namespace v1beta1 {
        /**
         * Spec defines the desired state of GatewayClass.
         */
        export interface GatewayClassSpecArgs {
            /**
             * ControllerName is the name of the controller that is managing Gateways of
             * this class. The value of this field MUST be a domain prefixed path.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * This field is not mutable and cannot be empty.
             *
             *
             * Support: Core
             */
            controllerName: pulumi.Input<string>;
            /**
             * Description helps describe a GatewayClass with more details.
             */
            description?: pulumi.Input<string>;
            /**
             * ParametersRef is a reference to a resource that contains the configuration
             * parameters corresponding to the GatewayClass. This is optional if the
             * controller does not require any additional configuration.
             *
             *
             * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
             * or an implementation-specific custom resource. The resource can be
             * cluster-scoped or namespace-scoped.
             *
             *
             * If the referent cannot be found, the GatewayClass's "InvalidParameters"
             * status condition will be true.
             *
             *
             * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
             * the merging behavior is implementation specific.
             * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
             *
             *
             * Support: Implementation-specific
             */
            parametersRef?: pulumi.Input<inputs.gateway.v1beta1.GatewayClassSpecParametersRefArgs>;
        }

        /**
         * ParametersRef is a reference to a resource that contains the configuration
         * parameters corresponding to the GatewayClass. This is optional if the
         * controller does not require any additional configuration.
         *
         *
         * ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
         * or an implementation-specific custom resource. The resource can be
         * cluster-scoped or namespace-scoped.
         *
         *
         * If the referent cannot be found, the GatewayClass's "InvalidParameters"
         * status condition will be true.
         *
         *
         * A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified,
         * the merging behavior is implementation specific.
         * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
         *
         *
         * Support: Implementation-specific
         */
        export interface GatewayClassSpecParametersRefArgs {
            /**
             * Group is the group of the referent.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent.
             * This field is required when referring to a Namespace-scoped resource and
             * MUST be unset when referring to a Cluster-scoped resource.
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Status defines the current state of GatewayClass.
         *
         *
         * Implementations MUST populate status on all GatewayClass resources which
         * specify their controller name.
         */
        export interface GatewayClassStatusArgs {
            /**
             * Conditions is the current status from the controller for
             * this GatewayClass.
             *
             *
             * Controllers should prefer to publish conditions using values
             * of GatewayClassConditionType for the type of each Condition.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewayClassStatusConditionsArgs>[]>;
            /**
             * SupportedFeatures is the set of features the GatewayClass support.
             * It MUST be sorted in ascending alphabetical order.
             */
            supportedFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayClassStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * Spec defines the desired state of Gateway.
         */
        export interface GatewaySpecArgs {
            /**
             * Addresses requested for this Gateway. This is optional and behavior can
             * depend on the implementation. If a value is set in the spec and the
             * requested address is invalid or unavailable, the implementation MUST
             * indicate this in the associated entry in GatewayStatus.Addresses.
             *
             *
             * The Addresses field represents a request for the address(es) on the
             * "outside of the Gateway", that traffic bound for this Gateway will use.
             * This could be the IP address or hostname of an external load balancer or
             * other networking infrastructure, or some other address that traffic will
             * be sent to.
             *
             *
             * If no Addresses are specified, the implementation MAY schedule the
             * Gateway in an implementation-specific manner, assigning an appropriate
             * set of Addresses.
             *
             *
             * The implementation MUST bind all Listeners to every GatewayAddress that
             * it assigns to the Gateway and add a corresponding entry in
             * GatewayStatus.Addresses.
             *
             *
             * Support: Extended
             */
            addresses?: pulumi.Input<any[]>;
            /**
             * GatewayClassName used for this Gateway. This is the name of a
             * GatewayClass resource.
             */
            gatewayClassName: pulumi.Input<string>;
            /**
             * Infrastructure defines infrastructure level attributes about this Gateway instance.
             *
             *
             * Support: Core
             */
            infrastructure?: pulumi.Input<inputs.gateway.v1beta1.GatewaySpecInfrastructureArgs>;
            /**
             * Listeners associated with this Gateway. Listeners define
             * logical endpoints that are bound on this Gateway's addresses.
             * At least one Listener MUST be specified.
             *
             *
             * Each Listener in a set of Listeners (for example, in a single Gateway)
             * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to
             * exactly one listener. (This section uses "set of Listeners" rather than
             * "Listeners in a single Gateway" because implementations MAY merge configuration
             * from multiple Gateways onto a single data plane, and these rules _also_
             * apply in that case).
             *
             *
             * Practically, this means that each listener in a set MUST have a unique
             * combination of Port, Protocol, and, if supported by the protocol, Hostname.
             *
             *
             * Some combinations of port, protocol, and TLS settings are considered
             * Core support and MUST be supported by implementations based on their
             * targeted conformance profile:
             *
             *
             * HTTP Profile
             *
             *
             * 1. HTTPRoute, Port: 80, Protocol: HTTP
             * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided
             *
             *
             * TLS Profile
             *
             *
             * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough
             *
             *
             * "Distinct" Listeners have the following property:
             *
             *
             * The implementation can match inbound requests to a single distinct
             * Listener. When multiple Listeners share values for fields (for
             * example, two Listeners with the same Port value), the implementation
             * can match requests to only one of the Listeners using other
             * Listener fields.
             *
             *
             * For example, the following Listener scenarios are distinct:
             *
             *
             * 1. Multiple Listeners with the same Port that all use the "HTTP"
             *    Protocol that all have unique Hostname values.
             * 2. Multiple Listeners with the same Port that use either the "HTTPS" or
             *    "TLS" Protocol that all have unique Hostname values.
             * 3. A mixture of "TCP" and "UDP" Protocol Listeners, where no Listener
             *    with the same Protocol has the same Port value.
             *
             *
             * Some fields in the Listener struct have possible values that affect
             * whether the Listener is distinct. Hostname is particularly relevant
             * for HTTP or HTTPS protocols.
             *
             *
             * When using the Hostname value to select between same-Port, same-Protocol
             * Listeners, the Hostname value must be different on each Listener for the
             * Listener to be distinct.
             *
             *
             * When the Listeners are distinct based on Hostname, inbound request
             * hostnames MUST match from the most specific to least specific Hostname
             * values to choose the correct Listener and its associated set of Routes.
             *
             *
             * Exact matches must be processed before wildcard matches, and wildcard
             * matches must be processed before fallback (empty Hostname value)
             * matches. For example, `"foo.example.com"` takes precedence over
             * `"*.example.com"`, and `"*.example.com"` takes precedence over `""`.
             *
             *
             * Additionally, if there are multiple wildcard entries, more specific
             * wildcard entries must be processed before less specific wildcard entries.
             * For example, `"*.foo.example.com"` takes precedence over `"*.example.com"`.
             * The precise definition here is that the higher the number of dots in the
             * hostname to the right of the wildcard character, the higher the precedence.
             *
             *
             * The wildcard character will match any number of characters _and dots_ to
             * the left, however, so `"*.example.com"` will match both
             * `"foo.bar.example.com"` _and_ `"bar.example.com"`.
             *
             *
             * If a set of Listeners contains Listeners that are not distinct, then those
             * Listeners are Conflicted, and the implementation MUST set the "Conflicted"
             * condition in the Listener Status to "True".
             *
             *
             * Implementations MAY choose to accept a Gateway with some Conflicted
             * Listeners only if they only accept the partial Listener set that contains
             * no Conflicted Listeners. To put this another way, implementations may
             * accept a partial Listener set only if they throw out *all* the conflicting
             * Listeners. No picking one of the conflicting listeners as the winner.
             * This also means that the Gateway must have at least one non-conflicting
             * Listener in this case, otherwise it violates the requirement that at
             * least one Listener must be present.
             *
             *
             * The implementation MUST set a "ListenersNotValid" condition on the
             * Gateway Status when the Gateway contains Conflicted Listeners whether or
             * not they accept the Gateway. That Condition SHOULD clearly
             * indicate in the Message which Listeners are conflicted, and which are
             * Accepted. Additionally, the Listener status for those listeners SHOULD
             * indicate which Listeners are conflicted and not Accepted.
             *
             *
             * A Gateway's Listeners are considered "compatible" if:
             *
             *
             * 1. They are distinct.
             * 2. The implementation can serve them in compliance with the Addresses
             *    requirement that all Listeners are available on all assigned
             *    addresses.
             *
             *
             * Compatible combinations in Extended support are expected to vary across
             * implementations. A combination that is compatible for one implementation
             * may not be compatible for another.
             *
             *
             * For example, an implementation that cannot serve both TCP and UDP listeners
             * on the same address, or cannot mix HTTPS and generic TLS listens on the same port
             * would not consider those cases compatible, even though they are distinct.
             *
             *
             * Note that requests SHOULD match at most one Listener. For example, if
             * Listeners are defined for "foo.example.com" and "*.example.com", a
             * request to "foo.example.com" SHOULD only be routed using routes attached
             * to the "foo.example.com" Listener (and not the "*.example.com" Listener).
             * This concept is known as "Listener Isolation". Implementations that do
             * not support Listener Isolation MUST clearly document this.
             *
             *
             * Implementations MAY merge separate Gateways onto a single set of
             * Addresses if all Listeners across all Gateways are compatible.
             *
             *
             * Support: Core
             */
            listeners: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersArgs>[]>;
        }

        /**
         * Infrastructure defines infrastructure level attributes about this Gateway instance.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecInfrastructureArgs {
            /**
             * Annotations that SHOULD be applied to any resources created in response to this Gateway.
             *
             *
             * For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
             * For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
             *
             *
             * An implementation may chose to add additional implementation-specific annotations as they see fit.
             *
             *
             * Support: Extended
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Labels that SHOULD be applied to any resources created in response to this Gateway.
             *
             *
             * For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
             * For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
             *
             *
             * An implementation may chose to add additional implementation-specific labels as they see fit.
             *
             *
             * Support: Extended
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * ParametersRef is a reference to a resource that contains the configuration
             * parameters corresponding to the Gateway. This is optional if the
             * controller does not require any additional configuration.
             *
             *
             * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
             *
             *
             * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
             * the merging behavior is implementation specific.
             * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
             *
             *
             * Support: Implementation-specific
             */
            parametersRef?: pulumi.Input<inputs.gateway.v1beta1.GatewaySpecInfrastructureParametersRefArgs>;
        }

        /**
         * ParametersRef is a reference to a resource that contains the configuration
         * parameters corresponding to the Gateway. This is optional if the
         * controller does not require any additional configuration.
         *
         *
         * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
         *
         *
         * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
         * the merging behavior is implementation specific.
         * It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
         *
         *
         * Support: Implementation-specific
         */
        export interface GatewaySpecInfrastructureParametersRefArgs {
            /**
             * Group is the group of the referent.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * Listener embodies the concept of a logical endpoint where a Gateway accepts
         * network connections.
         */
        export interface GatewaySpecListenersArgs {
            /**
             * AllowedRoutes defines the types of routes that MAY be attached to a
             * Listener and the trusted namespaces where those Route resources MAY be
             * present.
             *
             *
             * Although a client request may match multiple route rules, only one rule
             * may ultimately receive the request. Matching precedence MUST be
             * determined in order of the following criteria:
             *
             *
             * * The most specific match as defined by the Route type.
             * * The oldest Route based on creation timestamp. For example, a Route with
             *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
             *   a Route with a creation timestamp of "2020-09-08 01:02:04".
             * * If everything else is equivalent, the Route appearing first in
             *   alphabetical order (namespace/name) should be given precedence. For
             *   example, foo/bar is given precedence over foo/baz.
             *
             *
             * All valid rules within a Route attached to this Listener should be
             * implemented. Invalid Route rules can be ignored (sometimes that will mean
             * the full Route). If a Route rule transitions from valid to invalid,
             * support for that Route rule should be dropped to ensure consistency. For
             * example, even if a filter specified by a Route rule is invalid, the rest
             * of the rules within that Route should still be supported.
             *
             *
             * Support: Core
             */
            allowedRoutes?: pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesArgs>;
            /**
             * Hostname specifies the virtual hostname to match for protocol types that
             * define this concept. When unspecified, all hostnames are matched. This
             * field is ignored for protocols that don't require hostname based
             * matching.
             *
             *
             * Implementations MUST apply Hostname matching appropriately for each of
             * the following protocols:
             *
             *
             * * TLS: The Listener Hostname MUST match the SNI.
             * * HTTP: The Listener Hostname MUST match the Host header of the request.
             * * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
             *   protocol layers as described above. If an implementation does not
             *   ensure that both the SNI and Host header match the Listener hostname,
             *   it MUST clearly document that.
             *
             *
             * For HTTPRoute and TLSRoute resources, there is an interaction with the
             * `spec.hostnames` array. When both listener and route specify hostnames,
             * there MUST be an intersection between the values for a Route to be
             * accepted. For more information, refer to the Route specific Hostnames
             * documentation.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * Support: Core
             */
            hostname?: pulumi.Input<string>;
            /**
             * Name is the name of the Listener. This name MUST be unique within a
             * Gateway.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Port is the network port. Multiple listeners may use the
             * same port, subject to the Listener compatibility rules.
             *
             *
             * Support: Core
             */
            port: pulumi.Input<number>;
            /**
             * Protocol specifies the network protocol this listener expects to receive.
             *
             *
             * Support: Core
             */
            protocol: pulumi.Input<string>;
            /**
             * TLS is the TLS configuration for the Listener. This field is required if
             * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
             * if the Protocol field is "HTTP", "TCP", or "UDP".
             *
             *
             * The association of SNIs to Certificate defined in GatewayTLSConfig is
             * defined based on the Hostname field for this listener.
             *
             *
             * The GatewayClass MUST use the longest matching SNI out of all
             * available certificates for any TLS handshake.
             *
             *
             * Support: Core
             */
            tls?: pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersTlsArgs>;
        }
        /**
         * gatewaySpecListenersArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersArgs
         */
        export function gatewaySpecListenersArgsProvideDefaults(val: GatewaySpecListenersArgs): GatewaySpecListenersArgs {
            return {
                ...val,
                allowedRoutes: (val.allowedRoutes ? pulumi.output(val.allowedRoutes).apply(inputs.gateway.v1beta1.gatewaySpecListenersAllowedRoutesArgsProvideDefaults) : undefined),
                tls: (val.tls ? pulumi.output(val.tls).apply(inputs.gateway.v1beta1.gatewaySpecListenersTlsArgsProvideDefaults) : undefined),
            };
        }

        /**
         * AllowedRoutes defines the types of routes that MAY be attached to a
         * Listener and the trusted namespaces where those Route resources MAY be
         * present.
         *
         *
         * Although a client request may match multiple route rules, only one rule
         * may ultimately receive the request. Matching precedence MUST be
         * determined in order of the following criteria:
         *
         *
         * * The most specific match as defined by the Route type.
         * * The oldest Route based on creation timestamp. For example, a Route with
         *   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
         *   a Route with a creation timestamp of "2020-09-08 01:02:04".
         * * If everything else is equivalent, the Route appearing first in
         *   alphabetical order (namespace/name) should be given precedence. For
         *   example, foo/bar is given precedence over foo/baz.
         *
         *
         * All valid rules within a Route attached to this Listener should be
         * implemented. Invalid Route rules can be ignored (sometimes that will mean
         * the full Route). If a Route rule transitions from valid to invalid,
         * support for that Route rule should be dropped to ensure consistency. For
         * example, even if a filter specified by a Route rule is invalid, the rest
         * of the rules within that Route should still be supported.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesArgs {
            /**
             * Kinds specifies the groups and kinds of Routes that are allowed to bind
             * to this Gateway Listener. When unspecified or empty, the kinds of Routes
             * selected are determined using the Listener protocol.
             *
             *
             * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
             * with the application protocol specified in the Listener's Protocol field.
             * If an implementation does not support or recognize this resource type, it
             * MUST set the "ResolvedRefs" condition to False for this Listener with the
             * "InvalidRouteKinds" reason.
             *
             *
             * Support: Core
             */
            kinds?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesKindsArgs>[]>;
            /**
             * Namespaces indicates namespaces from which Routes may be attached to this
             * Listener. This is restricted to the namespace of this Gateway by default.
             *
             *
             * Support: Core
             */
            namespaces?: pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesNamespacesArgs>;
        }
        /**
         * gatewaySpecListenersAllowedRoutesArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesArgs
         */
        export function gatewaySpecListenersAllowedRoutesArgsProvideDefaults(val: GatewaySpecListenersAllowedRoutesArgs): GatewaySpecListenersAllowedRoutesArgs {
            return {
                ...val,
                namespaces: (val.namespaces ? pulumi.output(val.namespaces).apply(inputs.gateway.v1beta1.gatewaySpecListenersAllowedRoutesNamespacesArgsProvideDefaults) : undefined),
            };
        }

        /**
         * RouteGroupKind indicates the group and kind of a Route resource.
         */
        export interface GatewaySpecListenersAllowedRoutesKindsArgs {
            /**
             * Group is the group of the Route.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the kind of the Route.
             */
            kind: pulumi.Input<string>;
        }
        /**
         * gatewaySpecListenersAllowedRoutesKindsArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesKindsArgs
         */
        export function gatewaySpecListenersAllowedRoutesKindsArgsProvideDefaults(val: GatewaySpecListenersAllowedRoutesKindsArgs): GatewaySpecListenersAllowedRoutesKindsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
            };
        }

        /**
         * Namespaces indicates namespaces from which Routes may be attached to this
         * Listener. This is restricted to the namespace of this Gateway by default.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesArgs {
            /**
             * From indicates where Routes will be selected for this Gateway. Possible
             * values are:
             *
             *
             * * All: Routes in all namespaces may be used by this Gateway.
             * * Selector: Routes in namespaces selected by the selector may be used by
             *   this Gateway.
             * * Same: Only Routes in the same namespace may be used by this Gateway.
             *
             *
             * Support: Core
             */
            from?: pulumi.Input<string>;
            /**
             * Selector must be specified when From is set to "Selector". In that case,
             * only Routes in Namespaces matching this Selector will be selected by this
             * Gateway. This field is ignored for other values of "From".
             *
             *
             * Support: Core
             */
            selector?: pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs>;
        }
        /**
         * gatewaySpecListenersAllowedRoutesNamespacesArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersAllowedRoutesNamespacesArgs
         */
        export function gatewaySpecListenersAllowedRoutesNamespacesArgsProvideDefaults(val: GatewaySpecListenersAllowedRoutesNamespacesArgs): GatewaySpecListenersAllowedRoutesNamespacesArgs {
            return {
                ...val,
                from: (val.from) ?? "Same",
            };
        }

        /**
         * Selector must be specified when From is set to "Selector". In that case,
         * only Routes in Namespaces matching this Selector will be selected by this
         * Gateway. This field is ignored for other values of "From".
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TLS is the TLS configuration for the Listener. This field is required if
         * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
         * if the Protocol field is "HTTP", "TCP", or "UDP".
         *
         *
         * The association of SNIs to Certificate defined in GatewayTLSConfig is
         * defined based on the Hostname field for this listener.
         *
         *
         * The GatewayClass MUST use the longest matching SNI out of all
         * available certificates for any TLS handshake.
         *
         *
         * Support: Core
         */
        export interface GatewaySpecListenersTlsArgs {
            /**
             * CertificateRefs contains a series of references to Kubernetes objects that
             * contains TLS certificates and private keys. These certificates are used to
             * establish a TLS handshake for requests that match the hostname of the
             * associated listener.
             *
             *
             * A single CertificateRef to a Kubernetes Secret has "Core" support.
             * Implementations MAY choose to support attaching multiple certificates to
             * a Listener, but this behavior is implementation-specific.
             *
             *
             * References to a resource in different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached. If a ReferenceGrant does not allow this reference, the
             * "ResolvedRefs" condition MUST be set to False for this listener with the
             * "RefNotPermitted" reason.
             *
             *
             * This field is required to have at least one element when the mode is set
             * to "Terminate" (default) and is optional otherwise.
             *
             *
             * CertificateRefs can reference to standard Kubernetes resources, i.e.
             * Secret, or implementation-specific custom resources.
             *
             *
             * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
             *
             *
             * Support: Implementation-specific (More than one reference or other resource types)
             */
            certificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersTlsCertificateRefsArgs>[]>;
            /**
             * FrontendValidation holds configuration information for validating the frontend (client).
             * Setting this field will require clients to send a client certificate
             * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
             * that requests a user to specify the client certificate.
             * The maximum depth of a certificate chain accepted in verification is Implementation specific.
             *
             *
             * Support: Extended
             */
            frontendValidation?: pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersTlsFrontendValidationArgs>;
            /**
             * Mode defines the TLS behavior for the TLS session initiated by the client.
             * There are two possible modes:
             *
             *
             * - Terminate: The TLS session between the downstream client and the
             *   Gateway is terminated at the Gateway. This mode requires certificates
             *   to be specified in some way, such as populating the certificateRefs
             *   field.
             * - Passthrough: The TLS session is NOT terminated by the Gateway. This
             *   implies that the Gateway can't decipher the TLS stream except for
             *   the ClientHello message of the TLS protocol. The certificateRefs field
             *   is ignored in this mode.
             *
             *
             * Support: Core
             */
            mode?: pulumi.Input<string>;
            /**
             * Options are a list of key/value pairs to enable extended TLS
             * configuration for each implementation. For example, configuring the
             * minimum TLS version or supported cipher suites.
             *
             *
             * A set of common keys MAY be defined by the API in the future. To avoid
             * any ambiguity, implementation-specific definitions MUST use
             * domain-prefixed names, such as `example.com/my-custom-option`.
             * Un-prefixed names are reserved for key names defined by Gateway API.
             *
             *
             * Support: Implementation-specific
             */
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }
        /**
         * gatewaySpecListenersTlsArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersTlsArgs
         */
        export function gatewaySpecListenersTlsArgsProvideDefaults(val: GatewaySpecListenersTlsArgs): GatewaySpecListenersTlsArgs {
            return {
                ...val,
                mode: (val.mode) ?? "Terminate",
            };
        }

        /**
         * SecretObjectReference identifies an API object including its namespace,
         * defaulting to Secret.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface GatewaySpecListenersTlsCertificateRefsArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * gatewaySpecListenersTlsCertificateRefsArgsProvideDefaults sets the appropriate defaults for GatewaySpecListenersTlsCertificateRefsArgs
         */
        export function gatewaySpecListenersTlsCertificateRefsArgsProvideDefaults(val: GatewaySpecListenersTlsCertificateRefsArgs): GatewaySpecListenersTlsCertificateRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Secret",
            };
        }

        /**
         * FrontendValidation holds configuration information for validating the frontend (client).
         * Setting this field will require clients to send a client certificate
         * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
         * that requests a user to specify the client certificate.
         * The maximum depth of a certificate chain accepted in verification is Implementation specific.
         *
         *
         * Support: Extended
         */
        export interface GatewaySpecListenersTlsFrontendValidationArgs {
            /**
             * CACertificateRefs contains one or more references to
             * Kubernetes objects that contain TLS certificates of
             * the Certificate Authorities that can be used
             * as a trust anchor to validate the certificates presented by the client.
             *
             *
             * A single CA certificate reference to a Kubernetes ConfigMap
             * has "Core" support.
             * Implementations MAY choose to support attaching multiple CA certificates to
             * a Listener, but this behavior is implementation-specific.
             *
             *
             * Support: Core - A single reference to a Kubernetes ConfigMap
             * with the CA certificate in a key named `ca.crt`.
             *
             *
             * Support: Implementation-specific (More than one reference, or other kinds
             * of resources).
             *
             *
             * References to a resource in a different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached. If a ReferenceGrant does not allow this reference, the
             * "ResolvedRefs" condition MUST be set to False for this listener with the
             * "RefNotPermitted" reason.
             */
            caCertificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewaySpecListenersTlsFrontendValidationCaCertificateRefsArgs>[]>;
        }

        /**
         * ObjectReference identifies an API object including its namespace.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        export interface GatewaySpecListenersTlsFrontendValidationCaCertificateRefsArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "ConfigMap" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Status defines the current state of Gateway.
         */
        export interface GatewayStatusArgs {
            /**
             * Addresses lists the network addresses that have been bound to the
             * Gateway.
             *
             *
             * This list may differ from the addresses provided in the spec under some
             * conditions:
             *
             *
             *   * no addresses are specified, all addresses are dynamically assigned
             *   * a combination of specified and dynamic addresses are assigned
             *   * a specified address was unusable (e.g. already in use)
             */
            addresses?: pulumi.Input<any[]>;
            /**
             * Conditions describe the current conditions of the Gateway.
             *
             *
             * Implementations should prefer to express Gateway conditions
             * using the `GatewayConditionType` and `GatewayConditionReason`
             * constants so that operators and tools can converge on a common
             * vocabulary to describe Gateway state.
             *
             *
             * Known condition types are:
             *
             *
             * * "Accepted"
             * * "Programmed"
             * * "Ready"
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewayStatusConditionsArgs>[]>;
            /**
             * Listeners provide status for each unique listener port defined in the Spec.
             */
            listeners?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewayStatusListenersArgs>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ListenerStatus is the status associated with a Listener.
         */
        export interface GatewayStatusListenersArgs {
            /**
             * AttachedRoutes represents the total number of Routes that have been
             * successfully attached to this Listener.
             *
             *
             * Successful attachment of a Route to a Listener is based solely on the
             * combination of the AllowedRoutes field on the corresponding Listener
             * and the Route's ParentRefs field. A Route is successfully attached to
             * a Listener when it is selected by the Listener's AllowedRoutes field
             * AND the Route has a valid ParentRef selecting the whole Gateway
             * resource or a specific Listener as a parent resource (more detail on
             * attachment semantics can be found in the documentation on the various
             * Route kinds ParentRefs fields). Listener or Route status does not impact
             * successful attachment, i.e. the AttachedRoutes field count MUST be set
             * for Listeners with condition Accepted: false and MUST count successfully
             * attached Routes that may themselves have Accepted: false conditions.
             *
             *
             * Uses for this field include troubleshooting Route attachment and
             * measuring blast radius/impact of changes to a Listener.
             */
            attachedRoutes: pulumi.Input<number>;
            /**
             * Conditions describe the current condition of this listener.
             */
            conditions: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewayStatusListenersConditionsArgs>[]>;
            /**
             * Name is the name of the Listener that this status corresponds to.
             */
            name: pulumi.Input<string>;
            /**
             * SupportedKinds is the list indicating the Kinds supported by this
             * listener. This MUST represent the kinds an implementation supports for
             * that Listener configuration.
             *
             *
             * If kinds are specified in Spec that are not supported, they MUST NOT
             * appear in this list and an implementation MUST set the "ResolvedRefs"
             * condition to "False" with the "InvalidRouteKinds" reason. If both valid
             * and invalid Route kinds are specified, the implementation MUST
             * reference the valid Route kinds that have been specified.
             */
            supportedKinds: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.GatewayStatusListenersSupportedKindsArgs>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface GatewayStatusListenersConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * RouteGroupKind indicates the group and kind of a Route resource.
         */
        export interface GatewayStatusListenersSupportedKindsArgs {
            /**
             * Group is the group of the Route.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the kind of the Route.
             */
            kind: pulumi.Input<string>;
        }
        /**
         * gatewayStatusListenersSupportedKindsArgsProvideDefaults sets the appropriate defaults for GatewayStatusListenersSupportedKindsArgs
         */
        export function gatewayStatusListenersSupportedKindsArgsProvideDefaults(val: GatewayStatusListenersSupportedKindsArgs): GatewayStatusListenersSupportedKindsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
            };
        }

        /**
         * Spec defines the desired state of HTTPRoute.
         */
        export interface HTTPRouteSpecArgs {
            /**
             * Hostnames defines a set of hostnames that should match against the HTTP Host
             * header to select a HTTPRoute used to process the request. Implementations
             * MUST ignore any port value specified in the HTTP Host header while
             * performing a match and (absent of any applicable header modification
             * configuration) MUST forward this header unmodified to the backend.
             *
             *
             * Valid values for Hostnames are determined by RFC 1123 definition of a
             * hostname with 2 notable exceptions:
             *
             *
             * 1. IPs are not allowed.
             * 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
             *    label must appear by itself as the first label.
             *
             *
             * If a hostname is specified by both the Listener and HTTPRoute, there
             * must be at least one intersecting hostname for the HTTPRoute to be
             * attached to the Listener. For example:
             *
             *
             * * A Listener with `test.example.com` as the hostname matches HTTPRoutes
             *   that have either not specified any hostnames, or have specified at
             *   least one of `test.example.com` or `*.example.com`.
             * * A Listener with `*.example.com` as the hostname matches HTTPRoutes
             *   that have either not specified any hostnames or have specified at least
             *   one hostname that matches the Listener hostname. For example,
             *   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
             *   all match. On the other hand, `example.com` and `test.example.net` would
             *   not match.
             *
             *
             * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
             * as a suffix match. That means that a match for `*.example.com` would match
             * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
             *
             *
             * If both the Listener and HTTPRoute have specified hostnames, any
             * HTTPRoute hostnames that do not match the Listener hostname MUST be
             * ignored. For example, if a Listener specified `*.example.com`, and the
             * HTTPRoute specified `test.example.com` and `test.example.net`,
             * `test.example.net` must not be considered for a match.
             *
             *
             * If both the Listener and HTTPRoute have specified hostnames, and none
             * match with the criteria above, then the HTTPRoute is not accepted. The
             * implementation must raise an 'Accepted' Condition with a status of
             * `False` in the corresponding RouteParentStatus.
             *
             *
             * In the event that multiple HTTPRoutes specify intersecting hostnames (e.g.
             * overlapping wildcard matching and exact matching hostnames), precedence must
             * be given to rules from the HTTPRoute with the largest number of:
             *
             *
             * * Characters in a matching non-wildcard hostname.
             * * Characters in a matching hostname.
             *
             *
             * If ties exist across multiple Routes, the matching precedence rules for
             * HTTPRouteMatches takes over.
             *
             *
             * Support: Core
             */
            hostnames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants
             * to be attached to. Note that the referenced parent resource needs to
             * allow this for the attachment to be complete. For Gateways, that means
             * the Gateway needs to allow attachment from Routes of this kind and
             * namespace. For Services, that means the Service must either be in the same
             * namespace for a "producer" route, or the mesh implementation must support
             * and allow "consumer" routes for the referenced Service. ReferenceGrant is
             * not applicable for governing ParentRefs to Services - it is not possible to
             * create a "producer" route for a Service in a different namespace from the
             * Route.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * This API may be extended in the future to support additional kinds of parent
             * resources.
             *
             *
             * ParentRefs must be _distinct_. This means either that:
             *
             *
             * * They select different objects.  If this is the case, then parentRef
             *   entries are distinct. In terms of fields, this means that the
             *   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
             *   be unique across all parentRef entries in the Route.
             * * They do not select different objects, but for each optional field used,
             *   each ParentRef that selects the same object must set the same set of
             *   optional fields to different values. If one ParentRef sets a
             *   combination of optional fields, all must set the same combination.
             *
             *
             * Some examples:
             *
             *
             * * If one ParentRef sets `sectionName`, all ParentRefs referencing the
             *   same object must also set `sectionName`.
             * * If one ParentRef sets `port`, all ParentRefs referencing the same
             *   object must also set `port`.
             * * If one ParentRef sets `sectionName` and `port`, all ParentRefs
             *   referencing the same object must also set `sectionName` and `port`.
             *
             *
             * It is possible to separately reference multiple distinct objects that may
             * be collapsed by an implementation. For example, some implementations may
             * choose to merge compatible Gateway Listeners together. If that is the
             * case, the list of routes attached to those resources should also be
             * merged.
             *
             *
             * Note that for ParentRefs that cross namespace boundaries, there are specific
             * rules. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example,
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable other kinds of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             */
            parentRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecParentRefsArgs>[]>;
            /**
             * Rules are a list of HTTP matchers, filters and actions.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesArgs>[]>;
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered
         * a parent of this resource (usually a route). There are two kinds of parent resources
         * with "Core" support:
         *
         *
         * * Gateway (Gateway conformance profile)
         * * Service (Mesh conformance profile, ClusterIP Services only)
         *
         *
         * This API may be extended in the future to support additional kinds of parent
         * resources.
         *
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         */
        export interface HTTPRouteSpecParentRefsArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * httprouteSpecParentRefsArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecParentRefsArgs
         */
        export function httprouteSpecParentRefsArgsProvideDefaults(val: HTTPRouteSpecParentRefsArgs): HTTPRouteSpecParentRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * HTTPRouteRule defines semantics for matching an HTTP request based on
         * conditions (matches), processing it (filters), and forwarding the request to
         * an API object (backendRefs).
         */
        export interface HTTPRouteSpecRulesArgs {
            /**
             * BackendRefs defines the backend(s) where matching requests should be
             * sent.
             *
             *
             * Failure behavior here depends on how many BackendRefs are specified and
             * how many are invalid.
             *
             *
             * If *all* entries in BackendRefs are invalid, and there are also no filters
             * specified in this route rule, *all* traffic which matches this rule MUST
             * receive a 500 status code.
             *
             *
             * See the HTTPBackendRef definition for the rules about what makes a single
             * HTTPBackendRef invalid.
             *
             *
             * When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
             * requests that would have otherwise been routed to an invalid backend. If
             * multiple backends are specified, and some are invalid, the proportion of
             * requests that would otherwise have been routed to an invalid backend
             * MUST receive a 500 status code.
             *
             *
             * For example, if two backends are specified with equal weights, and one is
             * invalid, 50 percent of traffic must receive a 500. Implementations may
             * choose how that 50 percent is determined.
             *
             *
             * Support: Core for Kubernetes Service
             *
             *
             * Support: Extended for Kubernetes ServiceImport
             *
             *
             * Support: Implementation-specific for any other resource
             *
             *
             * Support for weight: Core
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsArgs>[]>;
            /**
             * Filters define the filters that are applied to requests that match
             * this rule.
             *
             *
             * Wherever possible, implementations SHOULD implement filters in the order
             * they are specified.
             *
             *
             * Implementations MAY choose to implement this ordering strictly, rejecting
             * any combination or order of filters that can not be supported. If implementations
             * choose a strict interpretation of filter ordering, they MUST clearly document
             * that behavior.
             *
             *
             * To reject an invalid combination or order of filters, implementations SHOULD
             * consider the Route Rules with this configuration invalid. If all Route Rules
             * in a Route are invalid, the entire Route would be considered invalid. If only
             * a portion of Route Rules are invalid, implementations MUST set the
             * "PartiallyInvalid" condition for the Route.
             *
             *
             * Conformance-levels at this level are defined based on the type of filter:
             *
             *
             * - ALL core filters MUST be supported by all implementations.
             * - Implementers are encouraged to support extended filters.
             * - Implementation-specific custom filters have no API guarantees across
             *   implementations.
             *
             *
             * Specifying the same filter multiple times is not supported unless explicitly
             * indicated in the filter.
             *
             *
             * All filters are expected to be compatible with each other except for the
             * URLRewrite and RequestRedirect filters, which may not be combined. If an
             * implementation can not support other combinations of filters, they must clearly
             * document that limitation. In cases where incompatible or unsupported
             * filters are specified and cause the `Accepted` condition to be set to status
             * `False`, implementations may use the `IncompatibleFilters` reason to specify
             * this configuration error.
             *
             *
             * Support: Core
             */
            filters?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersArgs>[]>;
            /**
             * Matches define conditions used for matching the rule against incoming
             * HTTP requests. Each match is independent, i.e. this rule will be matched
             * if **any** one of the matches is satisfied.
             *
             *
             * For example, take the following matches configuration:
             *
             *
             * ```
             * matches:
             * - path:
             *     value: "/foo"
             *   headers:
             *   - name: "version"
             *     value: "v2"
             * - path:
             *     value: "/v2/foo"
             * ```
             *
             *
             * For a request to match against this rule, a request must satisfy
             * EITHER of the two conditions:
             *
             *
             * - path prefixed with `/foo` AND contains the header `version: v2`
             * - path prefix of `/v2/foo`
             *
             *
             * See the documentation for HTTPRouteMatch on how to specify multiple
             * match conditions that should be ANDed together.
             *
             *
             * If no matches are specified, the default is a prefix
             * path match on "/", which has the effect of matching every
             * HTTP request.
             *
             *
             * Proxy or Load Balancer routing configuration generated from HTTPRoutes
             * MUST prioritize matches based on the following criteria, continuing on
             * ties. Across all rules specified on applicable Routes, precedence must be
             * given to the match having:
             *
             *
             * * "Exact" path match.
             * * "Prefix" path match with largest number of characters.
             * * Method match.
             * * Largest number of header matches.
             * * Largest number of query param matches.
             *
             *
             * Note: The precedence of RegularExpression path matches are implementation-specific.
             *
             *
             * If ties still exist across multiple Routes, matching precedence MUST be
             * determined in order of the following criteria, continuing on ties:
             *
             *
             * * The oldest Route based on creation timestamp.
             * * The Route appearing first in alphabetical order by
             *   "{namespace}/{name}".
             *
             *
             * If ties still exist within an HTTPRoute, matching precedence MUST be granted
             * to the FIRST matching rule (in list order) with a match meeting the above
             * criteria.
             *
             *
             * When no rules matching a request have been successfully attached to the
             * parent a request is coming from, a HTTP 404 status code MUST be returned.
             */
            matches?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesMatchesArgs>[]>;
            /**
             * SessionPersistence defines and configures session persistence
             * for the route rule.
             *
             *
             * Support: Extended
             */
            sessionPersistence?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesSessionPersistenceArgs>;
            /**
             * Timeouts defines the timeouts that can be configured for an HTTP request.
             *
             *
             * Support: Extended
             */
            timeouts?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesTimeoutsArgs>;
        }
        /**
         * httprouteSpecRulesArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesArgs
         */
        export function httprouteSpecRulesArgsProvideDefaults(val: HTTPRouteSpecRulesArgs): HTTPRouteSpecRulesArgs {
            return {
                ...val,
                sessionPersistence: (val.sessionPersistence ? pulumi.output(val.sessionPersistence).apply(inputs.gateway.v1beta1.httprouteSpecRulesSessionPersistenceArgsProvideDefaults) : undefined),
            };
        }

        /**
         * HTTPBackendRef defines how a HTTPRoute forwards a HTTP request.
         *
         *
         * Note that when a namespace different than the local namespace is specified, a
         * ReferenceGrant object is required in the referent namespace to allow that
         * namespace's owner to accept the reference. See the ReferenceGrant
         * documentation for details.
         *
         *
         * <gateway:experimental:description>
         *
         *
         * When the BackendRef points to a Kubernetes Service, implementations SHOULD
         * honor the appProtocol field if it is set for the target Service Port.
         *
         *
         * Implementations supporting appProtocol SHOULD recognize the Kubernetes
         * Standard Application Protocols defined in KEP-3726.
         *
         *
         * If a Service appProtocol isn't specified, an implementation MAY infer the
         * backend protocol through its own means. Implementations MAY infer the
         * protocol from the Route type referring to the backend Service.
         *
         *
         * If a Route is not able to send traffic to the backend using the specified
         * protocol then the backend is considered invalid. Implementations MUST set the
         * "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
         *
         *
         * </gateway:experimental:description>
         */
        export interface HTTPRouteSpecRulesBackendRefsArgs {
            /**
             * Filters defined at this level should be executed if and only if the
             * request is being forwarded to the backend defined here.
             *
             *
             * Support: Implementation-specific (For broader support of filters, use the
             * Filters field in HTTPRouteRule.)
             */
            filters?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersArgs>[]>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced
             * backend. This is computed as weight/(sum of all weights in this
             * BackendRefs list). For non-zero values, there may be some epsilon from
             * the exact proportion defined here depending on the precision an
             * implementation supports. Weight is not a percentage and the sum of
             * weights does not need to equal 100.
             *
             *
             * If only one backend is specified and it has a weight greater than 0, 100%
             * of the traffic is forwarded to that backend. If weight is set to 0, no
             * traffic should be forwarded for this entry. If unspecified, weight
             * defaults to 1.
             *
             *
             * Support for this field varies based on the context where used.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesBackendRefsArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsArgs
         */
        export function httprouteSpecRulesBackendRefsArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsArgs): HTTPRouteSpecRulesBackendRefsArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * HTTPRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. HTTPRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersArgs {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * This filter can be used multiple times within the same rule.
             *
             *
             * Support: Implementation-specific
             */
            extensionRef?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs>;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs>;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs>;
            /**
             * RequestRedirect defines a schema for a filter that responds to the
             * request with an HTTP redirection.
             *
             *
             * Support: Core
             */
            requestRedirect?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs>;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs>;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations must support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by
             *   specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` should be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
            /**
             * URLRewrite defines a schema for a filter that modifies a request during forwarding.
             *
             *
             * Support: Extended
             */
            urlRewrite?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs>;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersArgs
         */
        export function httprouteSpecRulesBackendRefsFiltersArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersArgs): HTTPRouteSpecRulesBackendRefsFiltersArgs {
            return {
                ...val,
                requestMirror: (val.requestMirror ? pulumi.output(val.requestMirror).apply(inputs.gateway.v1beta1.httprouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults) : undefined),
                requestRedirect: (val.requestRedirect ? pulumi.output(val.requestRedirect).apply(inputs.gateway.v1beta1.httprouteSpecRulesBackendRefsFiltersRequestRedirectArgsProvideDefaults) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * This filter can be used multiple times within the same rule.
         *
         *
         * Support: Implementation-specific
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersExtensionRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs>;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestMirrorArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs): HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
            return {
                ...val,
                backendRef: pulumi.output(val.backendRef).apply(inputs.gateway.v1beta1.httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs): HTTPRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * RequestRedirect defines a schema for a filter that responds to the
         * request with an HTTP redirection.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             *
             *
             * Support: Core
             */
            hostname?: pulumi.Input<string>;
            /**
             * Path defines parameters used to modify the path of the incoming request.
             * The modified path is then used to construct the `Location` header. When
             * empty, the request path is used as-is.
             *
             *
             * Support: Extended
             */
            path?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs>;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             *
             * If no port is specified, the redirect port MUST be derived using the
             * following rules:
             *
             *
             * * If redirect scheme is not-empty, the redirect port MUST be the well-known
             *   port associated with the redirect scheme. Specifically "http" to port 80
             *   and "https" to port 443. If the redirect scheme does not have a
             *   well-known port, the listener port of the Gateway SHOULD be used.
             * * If redirect scheme is empty, the redirect port MUST be the Gateway
             *   Listener port.
             *
             *
             * Implementations SHOULD NOT add the port number in the 'Location'
             * header in the following cases:
             *
             *
             * * A Location header that will use HTTP (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 80.
             * * A Location header that will use HTTPS (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 443.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             *
             *
             * Scheme redirects can affect the port of the redirect, for more information,
             * refer to the documentation for the port field of this filter.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Extended
             */
            scheme?: pulumi.Input<string>;
            /**
             * StatusCode is the HTTP status code to be used in response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Core
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesBackendRefsFiltersRequestRedirectArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs
         */
        export function httprouteSpecRulesBackendRefsFiltersRequestRedirectArgsProvideDefaults(val: HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs): HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectArgs {
            return {
                ...val,
                statusCode: (val.statusCode) ?? 302,
            };
        }

        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersRequestRedirectPathArgs {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * URLRewrite defines a schema for a filter that modifies a request during forwarding.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersUrlRewriteArgs {
            /**
             * Hostname is the value to be used to replace the Host header value during
             * forwarding.
             *
             *
             * Support: Extended
             */
            hostname?: pulumi.Input<string>;
            /**
             * Path defines a path rewrite.
             *
             *
             * Support: Extended
             */
            path?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs>;
        }

        /**
         * Path defines a path rewrite.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesBackendRefsFiltersUrlRewritePathArgs {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * HTTPRouteFilter defines processing steps that must be completed during the
         * request or response lifecycle. HTTPRouteFilters are meant as an extension
         * point to express processing that may be done in Gateway implementations. Some
         * examples include request or response modification, implementing
         * authentication strategies, rate-limiting, and traffic shaping. API
         * guarantee/conformance is defined based on the type of the filter.
         */
        export interface HTTPRouteSpecRulesFiltersArgs {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the
             * "filter" behavior.  For example, resource "myroutefilter" in group
             * "networking.example.net"). ExtensionRef MUST NOT be used for core and
             * extended filters.
             *
             *
             * This filter can be used multiple times within the same rule.
             *
             *
             * Support: Implementation-specific
             */
            extensionRef?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersExtensionRefArgs>;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request
             * headers.
             *
             *
             * Support: Core
             */
            requestHeaderModifier?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs>;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests.
             * Requests are sent to the specified destination, but responses from
             * that destination are ignored.
             *
             *
             * This filter can be used multiple times within the same rule. Note that
             * not all implementations will be able to support mirroring to multiple
             * backends.
             *
             *
             * Support: Extended
             */
            requestMirror?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestMirrorArgs>;
            /**
             * RequestRedirect defines a schema for a filter that responds to the
             * request with an HTTP redirection.
             *
             *
             * Support: Core
             */
            requestRedirect?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestRedirectArgs>;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response
             * headers.
             *
             *
             * Support: Extended
             */
            responseHeaderModifier?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs>;
            /**
             * Type identifies the type of filter to apply. As with other API fields,
             * types are classified into three conformance levels:
             *
             *
             * - Core: Filter types and their corresponding configuration defined by
             *   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
             *   implementations must support core filters.
             *
             *
             * - Extended: Filter types and their corresponding configuration defined by
             *   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
             *   are encouraged to support extended filters.
             *
             *
             * - Implementation-specific: Filters that are defined and supported by
             *   specific vendors.
             *   In the future, filters showing convergence in behavior across multiple
             *   implementations will be considered for inclusion in extended or core
             *   conformance levels. Filter-specific configuration for such filters
             *   is specified using the ExtensionRef field. `Type` should be set to
             *   "ExtensionRef" for custom filters.
             *
             *
             * Implementers are encouraged to define custom implementation types to
             * extend the core API with implementation-specific behavior.
             *
             *
             * If a reference to a custom filter type cannot be resolved, the filter
             * MUST NOT be skipped. Instead, requests that would have been processed by
             * that filter MUST receive a HTTP error response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
            /**
             * URLRewrite defines a schema for a filter that modifies a request during forwarding.
             *
             *
             * Support: Extended
             */
            urlRewrite?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersUrlRewriteArgs>;
        }
        /**
         * httprouteSpecRulesFiltersArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersArgs
         */
        export function httprouteSpecRulesFiltersArgsProvideDefaults(val: HTTPRouteSpecRulesFiltersArgs): HTTPRouteSpecRulesFiltersArgs {
            return {
                ...val,
                requestMirror: (val.requestMirror ? pulumi.output(val.requestMirror).apply(inputs.gateway.v1beta1.httprouteSpecRulesFiltersRequestMirrorArgsProvideDefaults) : undefined),
                requestRedirect: (val.requestRedirect ? pulumi.output(val.requestRedirect).apply(inputs.gateway.v1beta1.httprouteSpecRulesFiltersRequestRedirectArgsProvideDefaults) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the
         * "filter" behavior.  For example, resource "myroutefilter" in group
         * "networking.example.net"). ExtensionRef MUST NOT be used for core and
         * extended filters.
         *
         *
         * This filter can be used multiple times within the same rule.
         *
         *
         * Support: Implementation-specific
         */
        export interface HTTPRouteSpecRulesFiltersExtensionRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request
         * headers.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersRequestHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests.
         * Requests are sent to the specified destination, but responses from
         * that destination are ignored.
         *
         *
         * This filter can be used multiple times within the same rule. Note that
         * not all implementations will be able to support mirroring to multiple
         * backends.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersRequestMirrorArgs {
            /**
             * BackendRef references a resource where mirrored requests are sent.
             *
             *
             * Mirrored requests must be sent only to a single destination endpoint
             * within this BackendRef, irrespective of how many endpoints are present
             * within this BackendRef.
             *
             *
             * If the referent cannot be found, this BackendRef is invalid and must be
             * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
             * condition on the Route status is set to `status: False` and not configure
             * this backend in the underlying implementation.
             *
             *
             * If there is a cross-namespace reference to an *existing* object
             * that is not allowed by a ReferenceGrant, the controller must ensure the
             * "ResolvedRefs"  condition on the Route is set to `status: False`,
             * with the "RefNotPermitted" reason and not configure this backend in the
             * underlying implementation.
             *
             *
             * In either error case, the Message of the `ResolvedRefs` Condition
             * should be used to provide more detail about the problem.
             *
             *
             * Support: Extended for Kubernetes Service
             *
             *
             * Support: Implementation-specific for any other resource
             */
            backendRef: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs>;
        }
        /**
         * httprouteSpecRulesFiltersRequestMirrorArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorArgs
         */
        export function httprouteSpecRulesFiltersRequestMirrorArgsProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestMirrorArgs): HTTPRouteSpecRulesFiltersRequestMirrorArgs {
            return {
                ...val,
                backendRef: pulumi.output(val.backendRef).apply(inputs.gateway.v1beta1.httprouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent.
         *
         *
         * Mirrored requests must be sent only to a single destination endpoint
         * within this BackendRef, irrespective of how many endpoints are present
         * within this BackendRef.
         *
         *
         * If the referent cannot be found, this BackendRef is invalid and must be
         * dropped from the Gateway. The controller must ensure the "ResolvedRefs"
         * condition on the Route status is set to `status: False` and not configure
         * this backend in the underlying implementation.
         *
         *
         * If there is a cross-namespace reference to an *existing* object
         * that is not allowed by a ReferenceGrant, the controller must ensure the
         * "ResolvedRefs"  condition on the Route is set to `status: False`,
         * with the "RefNotPermitted" reason and not configure this backend in the
         * underlying implementation.
         *
         *
         * In either error case, the Message of the `ResolvedRefs` Condition
         * should be used to provide more detail about the problem.
         *
         *
         * Support: Extended for Kubernetes Service
         *
         *
         * Support: Implementation-specific for any other resource
         */
        export interface HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             *
             * Defaults to "Service" when not specified.
             *
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs
         */
        export function httprouteSpecRulesFiltersRequestMirrorBackendRefArgsProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs): HTTPRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * RequestRedirect defines a schema for a filter that responds to the
         * request with an HTTP redirection.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesFiltersRequestRedirectArgs {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             *
             *
             * Support: Core
             */
            hostname?: pulumi.Input<string>;
            /**
             * Path defines parameters used to modify the path of the incoming request.
             * The modified path is then used to construct the `Location` header. When
             * empty, the request path is used as-is.
             *
             *
             * Support: Extended
             */
            path?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersRequestRedirectPathArgs>;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             *
             * If no port is specified, the redirect port MUST be derived using the
             * following rules:
             *
             *
             * * If redirect scheme is not-empty, the redirect port MUST be the well-known
             *   port associated with the redirect scheme. Specifically "http" to port 80
             *   and "https" to port 443. If the redirect scheme does not have a
             *   well-known port, the listener port of the Gateway SHOULD be used.
             * * If redirect scheme is empty, the redirect port MUST be the Gateway
             *   Listener port.
             *
             *
             * Implementations SHOULD NOT add the port number in the 'Location'
             * header in the following cases:
             *
             *
             * * A Location header that will use HTTP (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 80.
             * * A Location header that will use HTTPS (whether that is determined via
             *   the Listener protocol or the Scheme field) _and_ use port 443.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             *
             *
             * Scheme redirects can affect the port of the redirect, for more information,
             * refer to the documentation for the port field of this filter.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Extended
             */
            scheme?: pulumi.Input<string>;
            /**
             * StatusCode is the HTTP status code to be used in response.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             *
             *
             * Support: Core
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * httprouteSpecRulesFiltersRequestRedirectArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesFiltersRequestRedirectArgs
         */
        export function httprouteSpecRulesFiltersRequestRedirectArgsProvideDefaults(val: HTTPRouteSpecRulesFiltersRequestRedirectArgs): HTTPRouteSpecRulesFiltersRequestRedirectArgs {
            return {
                ...val,
                statusCode: (val.statusCode) ?? 302,
            };
        }

        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersRequestRedirectPathArgs {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response
         * headers.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierArgs {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs>[]>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierAddArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface HTTPRouteSpecRulesFiltersResponseHeaderModifierSetArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }

        /**
         * URLRewrite defines a schema for a filter that modifies a request during forwarding.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersUrlRewriteArgs {
            /**
             * Hostname is the value to be used to replace the Host header value during
             * forwarding.
             *
             *
             * Support: Extended
             */
            hostname?: pulumi.Input<string>;
            /**
             * Path defines a path rewrite.
             *
             *
             * Support: Extended
             */
            path?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesFiltersUrlRewritePathArgs>;
        }

        /**
         * Path defines a path rewrite.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesFiltersUrlRewritePathArgs {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             * -------------|--------------|----------------|----------
             * /foo/bar     | /foo         | /xyz           | /xyz/bar
             * /foo/bar     | /foo         | /xyz/          | /xyz/bar
             * /foo/bar     | /foo/        | /xyz           | /xyz/bar
             * /foo/bar     | /foo/        | /xyz/          | /xyz/bar
             * /foo         | /foo         | /xyz           | /xyz
             * /foo/        | /foo         | /xyz           | /xyz/
             * /foo/bar     | /foo         | <empty string> | /bar
             * /foo/        | /foo         | <empty string> | /
             * /foo         | /foo         | <empty string> | /
             * /foo/        | /foo         | /              | /
             * /foo         | /foo         | /              | /
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * HTTPRouteMatch defines the predicate used to match requests to a given
         * action. Multiple match types are ANDed together, i.e. the match will
         * evaluate to true only if all conditions are satisfied.
         *
         *
         * For example, the match below will match a HTTP request only if its path
         * starts with `/foo` AND it contains the `version: v1` header:
         *
         *
         * ```
         * match:
         *
         *
         * 	path:
         * 	  value: "/foo"
         * 	headers:
         * 	- name: "version"
         * 	  value "v1"
         *
         *
         * ```
         */
        export interface HTTPRouteSpecRulesMatchesArgs {
            /**
             * Headers specifies HTTP request header matchers. Multiple match values are
             * ANDed together, meaning, a request must match all the specified headers
             * to select the route.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesMatchesHeadersArgs>[]>;
            /**
             * Method specifies HTTP method matcher.
             * When specified, this route will be matched only if the request has the
             * specified method.
             *
             *
             * Support: Extended
             */
            method?: pulumi.Input<string>;
            /**
             * Path specifies a HTTP request path matcher. If this field is not
             * specified, a default prefix match on the "/" path is provided.
             */
            path?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesMatchesPathArgs>;
            /**
             * QueryParams specifies HTTP query parameter matchers. Multiple match
             * values are ANDed together, meaning, a request must match all the
             * specified query parameters to select the route.
             *
             *
             * Support: Extended
             */
            queryParams?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesMatchesQueryParamsArgs>[]>;
        }
        /**
         * httprouteSpecRulesMatchesArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesArgs
         */
        export function httprouteSpecRulesMatchesArgsProvideDefaults(val: HTTPRouteSpecRulesMatchesArgs): HTTPRouteSpecRulesMatchesArgs {
            return {
                ...val,
                path: (val.path ? pulumi.output(val.path).apply(inputs.gateway.v1beta1.httprouteSpecRulesMatchesPathArgsProvideDefaults) : undefined),
            };
        }

        /**
         * HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
         * headers.
         */
        export interface HTTPRouteSpecRulesMatchesHeadersArgs {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             *
             * If multiple entries specify equivalent header names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             *
             *
             * When a header is repeated in an HTTP request, it is
             * implementation-specific behavior as to how this is represented.
             * Generally, proxies should follow the guidance from the RFC:
             * https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
             * processing a repeated header, with special handling for "Set-Cookie".
             */
            name: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the header.
             *
             *
             * Support: Core (Exact)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             *
             *
             * Since RegularExpression HeaderMatchType has implementation-specific
             * conformance, implementations can support POSIX, PCRE or any other dialects
             * of regular expressions. Please read the implementation's documentation to
             * determine the supported dialect.
             */
            type?: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesMatchesHeadersArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesHeadersArgs
         */
        export function httprouteSpecRulesMatchesHeadersArgsProvideDefaults(val: HTTPRouteSpecRulesMatchesHeadersArgs): HTTPRouteSpecRulesMatchesHeadersArgs {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Path specifies a HTTP request path matcher. If this field is not
         * specified, a default prefix match on the "/" path is provided.
         */
        export interface HTTPRouteSpecRulesMatchesPathArgs {
            /**
             * Type specifies how to match against the path Value.
             *
             *
             * Support: Core (Exact, PathPrefix)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             */
            type?: pulumi.Input<string>;
            /**
             * Value of the HTTP path to match against.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesMatchesPathArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesPathArgs
         */
        export function httprouteSpecRulesMatchesPathArgsProvideDefaults(val: HTTPRouteSpecRulesMatchesPathArgs): HTTPRouteSpecRulesMatchesPathArgs {
            return {
                ...val,
                type: (val.type) ?? "PathPrefix",
                value: (val.value) ?? "/",
            };
        }

        /**
         * HTTPQueryParamMatch describes how to select a HTTP route by matching HTTP
         * query parameters.
         */
        export interface HTTPRouteSpecRulesMatchesQueryParamsArgs {
            /**
             * Name is the name of the HTTP query param to be matched. This must be an
             * exact string match. (See
             * https://tools.ietf.org/html/rfc7230#section-2.7.3).
             *
             *
             * If multiple entries specify equivalent query param names, only the first
             * entry with an equivalent name MUST be considered for a match. Subsequent
             * entries with an equivalent query param name MUST be ignored.
             *
             *
             * If a query param is repeated in an HTTP request, the behavior is
             * purposely left undefined, since different data planes have different
             * capabilities. However, it is *recommended* that implementations should
             * match against the first value of the param if the data plane supports it,
             * as this behavior is expected in other load balancing contexts outside of
             * the Gateway API.
             *
             *
             * Users SHOULD NOT route traffic based on repeated query params to guard
             * themselves against potential differences in the implementations.
             */
            name: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the query parameter.
             *
             *
             * Support: Extended (Exact)
             *
             *
             * Support: Implementation-specific (RegularExpression)
             *
             *
             * Since RegularExpression QueryParamMatchType has Implementation-specific
             * conformance, implementations can support POSIX, PCRE or any other
             * dialects of regular expressions. Please read the implementation's
             * documentation to determine the supported dialect.
             */
            type?: pulumi.Input<string>;
            /**
             * Value is the value of HTTP query param to be matched.
             */
            value: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesMatchesQueryParamsArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesMatchesQueryParamsArgs
         */
        export function httprouteSpecRulesMatchesQueryParamsArgsProvideDefaults(val: HTTPRouteSpecRulesMatchesQueryParamsArgs): HTTPRouteSpecRulesMatchesQueryParamsArgs {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * SessionPersistence defines and configures session persistence
         * for the route rule.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesSessionPersistenceArgs {
            /**
             * AbsoluteTimeout defines the absolute timeout of the persistent
             * session. Once the AbsoluteTimeout duration has elapsed, the
             * session becomes invalid.
             *
             *
             * Support: Extended
             */
            absoluteTimeout?: pulumi.Input<string>;
            /**
             * CookieConfig provides configuration settings that are specific
             * to cookie-based session persistence.
             *
             *
             * Support: Core
             */
            cookieConfig?: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs>;
            /**
             * IdleTimeout defines the idle timeout of the persistent session.
             * Once the session has been idle for more than the specified
             * IdleTimeout duration, the session becomes invalid.
             *
             *
             * Support: Extended
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * SessionName defines the name of the persistent session token
             * which may be reflected in the cookie or the header. Users
             * should avoid reusing session names to prevent unintended
             * consequences, such as rejection or unpredictable behavior.
             *
             *
             * Support: Implementation-specific
             */
            sessionName?: pulumi.Input<string>;
            /**
             * Type defines the type of session persistence such as through
             * the use a header or cookie. Defaults to cookie based session
             * persistence.
             *
             *
             * Support: Core for "Cookie" type
             *
             *
             * Support: Extended for "Header" type
             */
            type?: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesSessionPersistenceArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesSessionPersistenceArgs
         */
        export function httprouteSpecRulesSessionPersistenceArgsProvideDefaults(val: HTTPRouteSpecRulesSessionPersistenceArgs): HTTPRouteSpecRulesSessionPersistenceArgs {
            return {
                ...val,
                cookieConfig: (val.cookieConfig ? pulumi.output(val.cookieConfig).apply(inputs.gateway.v1beta1.httprouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults) : undefined),
                type: (val.type) ?? "Cookie",
            };
        }

        /**
         * CookieConfig provides configuration settings that are specific
         * to cookie-based session persistence.
         *
         *
         * Support: Core
         */
        export interface HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs {
            /**
             * LifetimeType specifies whether the cookie has a permanent or
             * session-based lifetime. A permanent cookie persists until its
             * specified expiry time, defined by the Expires or Max-Age cookie
             * attributes, while a session cookie is deleted when the current
             * session ends.
             *
             *
             * When set to "Permanent", AbsoluteTimeout indicates the
             * cookie's lifetime via the Expires or Max-Age cookie attributes
             * and is required.
             *
             *
             * When set to "Session", AbsoluteTimeout indicates the
             * absolute lifetime of the cookie tracked by the gateway and
             * is optional.
             *
             *
             * Support: Core for "Session" type
             *
             *
             * Support: Extended for "Permanent" type
             */
            lifetimeType?: pulumi.Input<string>;
        }
        /**
         * httprouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults sets the appropriate defaults for HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs
         */
        export function httprouteSpecRulesSessionPersistenceCookieConfigArgsProvideDefaults(val: HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs): HTTPRouteSpecRulesSessionPersistenceCookieConfigArgs {
            return {
                ...val,
                lifetimeType: (val.lifetimeType) ?? "Session",
            };
        }

        /**
         * Timeouts defines the timeouts that can be configured for an HTTP request.
         *
         *
         * Support: Extended
         */
        export interface HTTPRouteSpecRulesTimeoutsArgs {
            /**
             * BackendRequest specifies a timeout for an individual request from the gateway
             * to a backend. This covers the time from when the request first starts being
             * sent from the gateway to when the full response has been received from the backend.
             *
             *
             * Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
             * completely. Implementations that cannot completely disable the timeout MUST
             * instead interpret the zero duration as the longest possible value to which
             * the timeout can be set.
             *
             *
             * An entire client HTTP transaction with a gateway, covered by the Request timeout,
             * may result in more than one call from the gateway to the destination backend,
             * for example, if automatic retries are supported.
             *
             *
             * Because the Request timeout encompasses the BackendRequest timeout, the value of
             * BackendRequest must be <= the value of Request timeout.
             *
             *
             * Support: Extended
             */
            backendRequest?: pulumi.Input<string>;
            /**
             * Request specifies the maximum duration for a gateway to respond to an HTTP request.
             * If the gateway has not been able to respond before this deadline is met, the gateway
             * MUST return a timeout error.
             *
             *
             * For example, setting the `rules.timeouts.request` field to the value `10s` in an
             * `HTTPRoute` will cause a timeout if a client request is taking longer than 10 seconds
             * to complete.
             *
             *
             * Setting a timeout to the zero duration (e.g. "0s") SHOULD disable the timeout
             * completely. Implementations that cannot completely disable the timeout MUST
             * instead interpret the zero duration as the longest possible value to which
             * the timeout can be set.
             *
             *
             * This timeout is intended to cover as close to the whole request-response transaction
             * as possible although an implementation MAY choose to start the timeout after the entire
             * request stream has been received instead of immediately after the transaction is
             * initiated by the client.
             *
             *
             * When this field is unspecified, request timeout behavior is implementation-specific.
             *
             *
             * Support: Extended
             */
            request?: pulumi.Input<string>;
        }

        /**
         * Status defines the current state of HTTPRoute.
         */
        export interface HTTPRouteStatusArgs {
            /**
             * Parents is a list of parent resources (usually Gateways) that are
             * associated with the route, and the status of the route with respect to
             * each parent. When this route attaches to a parent, the controller that
             * manages the parent must add an entry to this list when the controller
             * first sees the route and should update the entry as appropriate when the
             * route or gateway is modified.
             *
             *
             * Note that parent references that cannot be resolved by an implementation
             * of this API will not be added to this list. Implementations of this API
             * can only populate Route status for the Gateways/parent resources they are
             * responsible for.
             *
             *
             * A maximum of 32 Gateways will be represented in this list. An empty list
             * means the route has not been attached to any Gateway.
             */
            parents: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteStatusParentsArgs>[]>;
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an
         * associated Parent.
         */
        export interface HTTPRouteStatusParentsArgs {
            /**
             * Conditions describes the status of the route with respect to the Gateway.
             * Note that the route's availability is also subject to the Gateway's own
             * status conditions and listener status.
             *
             *
             * If the Route's ParentRef specifies an existing Gateway that supports
             * Routes of this kind AND that Gateway's controller has sufficient access,
             * then that Gateway's controller MUST set the "Accepted" condition on the
             * Route, to indicate whether the route has been accepted or rejected by the
             * Gateway, and why.
             *
             *
             * A Route MUST be considered "Accepted" if at least one of the Route's
             * rules is implemented by the Gateway.
             *
             *
             * There are a number of cases where the "Accepted" condition may not be set
             * due to lack of controller visibility, that includes when:
             *
             *
             * * The Route refers to a non-existent parent.
             * * The Route is of a type that the controller does not support.
             * * The Route is in a namespace the controller does not have access to.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.HTTPRouteStatusParentsConditionsArgs>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             *
             * Example: "example.net/gateway-controller".
             *
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName: pulumi.Input<string>;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this
             * RouteParentStatus struct describes the status of.
             */
            parentRef: pulumi.Input<inputs.gateway.v1beta1.HTTPRouteStatusParentsParentRefArgs>;
        }
        /**
         * httprouteStatusParentsArgsProvideDefaults sets the appropriate defaults for HTTPRouteStatusParentsArgs
         */
        export function httprouteStatusParentsArgsProvideDefaults(val: HTTPRouteStatusParentsArgs): HTTPRouteStatusParentsArgs {
            return {
                ...val,
                parentRef: pulumi.output(val.parentRef).apply(inputs.gateway.v1beta1.httprouteStatusParentsParentRefArgsProvideDefaults),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         * ---
         * This struct is intended for direct use as an array at the field path .status.conditions.  For example,
         *
         *
         * 	type FooStatus struct{
         * 	    // Represents the observations of a foo's current state.
         * 	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
         * 	    // +patchMergeKey=type
         * 	    // +patchStrategy=merge
         * 	    // +listType=map
         * 	    // +listMapKey=type
         * 	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
         *
         *
         * 	    // other fields
         * 	}
         */
        export interface HTTPRouteStatusParentsConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             * ---
             * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
             * useful (see .node.status.conditions), the ability to deconflict is important.
             * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: pulumi.Input<string>;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this
         * RouteParentStatus struct describes the status of.
         */
        export interface HTTPRouteStatusParentsParentRefArgs {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             *
             * There are two kinds of parent resources with "Core" support:
             *
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             *
             * Support: Core
             */
            name: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             *
             *
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             *
             *
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             *
             *
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             *
             *
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * httprouteStatusParentsParentRefArgsProvideDefaults sets the appropriate defaults for HTTPRouteStatusParentsParentRefArgs
         */
        export function httprouteStatusParentsParentRefArgsProvideDefaults(val: HTTPRouteStatusParentsParentRefArgs): HTTPRouteStatusParentsParentRefArgs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of ReferenceGrant.
         */
        export interface ReferenceGrantSpecArgs {
            /**
             * From describes the trusted namespaces and kinds that can reference the
             * resources described in "To". Each entry in this list MUST be considered
             * to be an additional place that references can be valid from, or to put
             * this another way, entries MUST be combined using OR.
             *
             *
             * Support: Core
             */
            from: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.ReferenceGrantSpecFromArgs>[]>;
            /**
             * To describes the resources that may be referenced by the resources
             * described in "From". Each entry in this list MUST be considered to be an
             * additional place that references can be valid to, or to put this another
             * way, entries MUST be combined using OR.
             *
             *
             * Support: Core
             */
            to: pulumi.Input<pulumi.Input<inputs.gateway.v1beta1.ReferenceGrantSpecToArgs>[]>;
        }

        /**
         * ReferenceGrantFrom describes trusted namespaces and kinds.
         */
        export interface ReferenceGrantSpecFromArgs {
            /**
             * Group is the group of the referent.
             * When empty, the Kubernetes core API group is inferred.
             *
             *
             * Support: Core
             */
            group: pulumi.Input<string>;
            /**
             * Kind is the kind of the referent. Although implementations may support
             * additional resources, the following types are part of the "Core"
             * support level for this field.
             *
             *
             * When used to permit a SecretObjectReference:
             *
             *
             * * Gateway
             *
             *
             * When used to permit a BackendObjectReference:
             *
             *
             * * GRPCRoute
             * * HTTPRoute
             * * TCPRoute
             * * TLSRoute
             * * UDPRoute
             */
            kind: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent.
             *
             *
             * Support: Core
             */
            namespace: pulumi.Input<string>;
        }

        /**
         * ReferenceGrantTo describes what Kinds are allowed as targets of the
         * references.
         */
        export interface ReferenceGrantSpecToArgs {
            /**
             * Group is the group of the referent.
             * When empty, the Kubernetes core API group is inferred.
             *
             *
             * Support: Core
             */
            group: pulumi.Input<string>;
            /**
             * Kind is the kind of the referent. Although implementations may support
             * additional resources, the following types are part of the "Core"
             * support level for this field:
             *
             *
             * * Secret when used to permit a SecretObjectReference
             * * Service when used to permit a BackendObjectReference
             */
            kind: pulumi.Input<string>;
            /**
             * Name is the name of the referent. When unspecified, this policy
             * refers to all resources of the specified Group and Kind in the local
             * namespace.
             */
            name?: pulumi.Input<string>;
        }
    }
}
