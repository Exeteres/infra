// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi"
import * as inputs from "./input"
import * as outputs from "./output"

import * as utilities from "../utilities"

import { ObjectMeta } from "../meta/v1"

export namespace autoscaling {
  export namespace v1alpha1 {
    /**
     * Spec holds the desired state of the Metric (from the client).
     */
    export interface MetricSpec {
      /**
       * PanicWindow is the aggregation window for metrics where quick reactions are needed.
       */
      panicWindow: number
      /**
       * ScrapeTarget is the K8s service that publishes the metric endpoint.
       */
      scrapeTarget: string
      /**
       * StableWindow is the aggregation window for metrics in a stable state.
       */
      stableWindow: number
    }

    /**
     * Status communicates the observed state of the Metric (from the controller).
     */
    export interface MetricStatus {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.autoscaling.v1alpha1.MetricStatusConditions[]
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface MetricStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }

    /**
     * Spec holds the desired state of the PodAutoscaler (from the client).
     */
    export interface PodAutoscalerSpec {
      /**
       * ContainerConcurrency specifies the maximum allowed
       * in-flight (concurrent) requests per container of the Revision.
       * Defaults to `0` which means unlimited concurrency.
       */
      containerConcurrency?: number
      /**
       * The application-layer protocol. Matches `ProtocolType` inferred from the revision spec.
       */
      protocolType: string
      /**
       * Reachability specifies whether or not the `ScaleTargetRef` can be reached (ie. has a route).
       * Defaults to `ReachabilityUnknown`
       */
      reachability?: string
      /**
       * ScaleTargetRef defines the /scale-able resource that this PodAutoscaler
       * is responsible for quickly right-sizing.
       */
      scaleTargetRef: outputs.autoscaling.v1alpha1.PodAutoscalerSpecScaleTargetRef
    }

    /**
     * ScaleTargetRef defines the /scale-able resource that this PodAutoscaler
     * is responsible for quickly right-sizing.
     */
    export interface PodAutoscalerSpecScaleTargetRef {
      /**
       * API version of the referent.
       */
      apiVersion?: string
      /**
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      kind?: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name?: string
    }

    /**
     * Status communicates the observed state of the PodAutoscaler (from the controller).
     */
    export interface PodAutoscalerStatus {
      /**
       * ActualScale shows the actual number of replicas for the revision.
       */
      actualScale?: number
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.autoscaling.v1alpha1.PodAutoscalerStatusConditions[]
      /**
       * DesiredScale shows the current desired number of replicas for the revision.
       */
      desiredScale?: number
      /**
       * MetricsServiceName is the K8s Service name that provides revision metrics.
       * The service is managed by the PA object.
       */
      metricsServiceName: string
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
      /**
       * ServiceName is the K8s Service name that serves the revision, scaled by this PA.
       * The service is created and owned by the ServerlessService object owned by this PA.
       */
      serviceName: string
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface PodAutoscalerStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }
  }
}

export namespace caching {
  export namespace v1alpha1 {
    /**
     * Spec holds the desired state of the Image (from the client).
     */
    export interface ImageSpec {
      /**
       * Image is the name of the container image url to cache across the cluster.
       */
      image: string
      /**
       * ImagePullSecrets contains the names of the Kubernetes Secrets containing login
       * information used by the Pods which will run this container.
       */
      imagePullSecrets?: outputs.caching.v1alpha1.ImageSpecImagePullSecrets[]
      /**
       * ServiceAccountName is the name of the Kubernetes ServiceAccount as which the Pods
       * will run this container.  This is potentially used to authenticate the image pull
       * if the service account has attached pull secrets.  For more information:
       * https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account
       */
      serviceAccountName?: string
    }

    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface ImageSpecImagePullSecrets {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
    }

    /**
     * Status communicates the observed state of the Image (from the controller).
     */
    export interface ImageStatus {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.caching.v1alpha1.ImageStatusConditions[]
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface ImageStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }
  }
}

export namespace networking {
  export namespace v1alpha1 {
    /**
     * Spec is the desired state of the Certificate.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface CertificateSpec {
      /**
       * DNSNames is a list of DNS names the Certificate could support.
       * The wildcard format of DNSNames (e.g. *.default.example.com) is supported.
       */
      dnsNames: string[]
      /**
       * Domain is the top level domain of the values for DNSNames.
       */
      domain?: string
      /**
       * SecretName is the name of the secret resource to store the SSL certificate in.
       */
      secretName: string
    }

    /**
     * Status is the current state of the Certificate.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface CertificateStatus {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.networking.v1alpha1.CertificateStatusConditions[]
      /**
       * HTTP01Challenges is a list of HTTP01 challenges that need to be fulfilled
       * in order to get the TLS certificate..
       */
      http01Challenges?: outputs.networking.v1alpha1.CertificateStatusHttp01Challenges[]
      /**
       * The expiration time of the TLS certificate stored in the secret named
       * by this resource in spec.secretName.
       */
      notAfter?: string
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface CertificateStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }

    /**
     * HTTP01Challenge defines the status of a HTTP01 challenge that a certificate needs
     * to fulfill.
     */
    export interface CertificateStatusHttp01Challenges {
      /**
       * ServiceName is the name of the service to serve HTTP01 challenge requests.
       */
      serviceName?: string
      /**
       * ServiceNamespace is the namespace of the service to serve HTTP01 challenge requests.
       */
      serviceNamespace?: string
      /**
       * ServicePort is the port of the service to serve HTTP01 challenge requests.
       */
      servicePort?: number | string
      /**
       * URL is the URL that the HTTP01 challenge is expected to serve on.
       */
      url?: string
    }

    /**
     * Spec is the desired state of the ClusterDomainClaim.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface ClusterDomainClaimSpec {
      /**
       * Namespace is the namespace which is allowed to create a DomainMapping
       * using this ClusterDomainClaim's name.
       */
      namespace: string
    }

    /**
     * Spec is the desired state of the Ingress.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface IngressSpec {
      /**
       * HTTPOption is the option of HTTP. It has the following two values:
       * `HTTPOptionEnabled`, `HTTPOptionRedirected`
       */
      httpOption?: string
      /**
       * A list of host rules used to configure the Ingress.
       */
      rules?: outputs.networking.v1alpha1.IngressSpecRules[]
      /**
       * TLS configuration. Currently Ingress only supports a single TLS
       * port: 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       */
      tls?: outputs.networking.v1alpha1.IngressSpecTls[]
    }

    /**
     * IngressRule represents the rules mapping the paths under a specified host to
     * the related backend services. Incoming requests are first evaluated for a host
     * match, then routed to the backend associated with the matching IngressRuleValue.
     */
    export interface IngressSpecRules {
      /**
       * Host is the fully qualified domain name of a network host, as defined
       * by RFC 3986. Note the following deviations from the "host" part of the
       * URI as defined in the RFC:
       * 1. IPs are not allowed. Currently a rule value can only apply to the
       * 	  IP in the Spec of the parent .
       * 2. The `:` delimiter is not respected because ports are not allowed.
       * 	  Currently the port of an Ingress is implicitly :80 for http and
       * 	  :443 for https.
       * Both these may change in the future.
       * If the host is unspecified, the Ingress routes all traffic based on the
       * specified IngressRuleValue.
       * If multiple matching Hosts were provided, the first rule will take precedent.
       */
      hosts?: string[]
      /**
       * HTTP represents a rule to apply against incoming requests. If the
       * rule is satisfied, the request is routed to the specified backend.
       */
      http?: outputs.networking.v1alpha1.IngressSpecRulesHttp
      /**
       * Visibility signifies whether this rule should `ClusterLocal`. If it's not
       * specified then it defaults to `ExternalIP`.
       */
      visibility?: string
    }

    /**
     * HTTP represents a rule to apply against incoming requests. If the
     * rule is satisfied, the request is routed to the specified backend.
     */
    export interface IngressSpecRulesHttp {
      /**
       * A collection of paths that map requests to backends.
       *
       *
       * If they are multiple matching paths, the first match takes precedence.
       */
      paths: outputs.networking.v1alpha1.IngressSpecRulesHttpPaths[]
    }

    /**
     * HTTPIngressPath associates a path regex with a backend. Incoming URLs matching
     * the path are forwarded to the backend.
     */
    export interface IngressSpecRulesHttpPaths {
      /**
       * AppendHeaders allow specifying additional HTTP headers to add
       * before forwarding a request to the destination service.
       *
       *
       * NOTE: This differs from K8s Ingress which doesn't allow header appending.
       */
      appendHeaders?: { [key: string]: string }
      /**
       * Headers defines header matching rules which is a map from a header name
       * to HeaderMatch which specify a matching condition.
       * When a request matched with all the header matching rules,
       * the request is routed by the corresponding ingress rule.
       * If it is empty, the headers are not used for matching
       */
      headers?: { [key: string]: outputs.networking.v1alpha1.IngressSpecRulesHttpPathsHeaders }
      /**
       * Path represents a literal prefix to which this rule should apply.
       * Currently it can contain characters disallowed from the conventional
       * "path" part of a URL as defined by RFC 3986. Paths must begin with
       * a '/'. If unspecified, the path defaults to a catch all sending
       * traffic to the backend.
       */
      path?: string
      /**
       * RewriteHost rewrites the incoming request's host header.
       *
       *
       * This field is currently experimental and not supported by all Ingress
       * implementations.
       */
      rewriteHost?: string
      /**
       * Splits defines the referenced service endpoints to which the traffic
       * will be forwarded to.
       */
      splits: outputs.networking.v1alpha1.IngressSpecRulesHttpPathsSplits[]
    }

    /**
     * HeaderMatch represents a matching value of Headers in HTTPIngressPath.
     * Currently, only the exact matching is supported.
     */
    export interface IngressSpecRulesHttpPathsHeaders {
      exact: string
    }

    /**
     * IngressBackendSplit describes all endpoints for a given service and port.
     */
    export interface IngressSpecRulesHttpPathsSplits {
      /**
       * AppendHeaders allow specifying additional HTTP headers to add
       * before forwarding a request to the destination service.
       *
       *
       * NOTE: This differs from K8s Ingress which doesn't allow header appending.
       */
      appendHeaders?: { [key: string]: string }
      /**
       * Specifies the split percentage, a number between 0 and 100.  If
       * only one split is specified, we default to 100.
       *
       *
       * NOTE: This differs from K8s Ingress to allow percentage split.
       */
      percent?: number
      /**
       * Specifies the name of the referenced service.
       */
      serviceName: string
      /**
       * Specifies the namespace of the referenced service.
       *
       *
       * NOTE: This differs from K8s Ingress to allow routing to different namespaces.
       */
      serviceNamespace: string
      /**
       * Specifies the port of the referenced service.
       */
      servicePort: number | string
    }

    /**
     * IngressTLS describes the transport layer security associated with an Ingress.
     */
    export interface IngressSpecTls {
      /**
       * Hosts is a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       */
      hosts?: string[]
      /**
       * SecretName is the name of the secret used to terminate SSL traffic.
       */
      secretName?: string
      /**
       * SecretNamespace is the namespace of the secret used to terminate SSL traffic.
       * If not set the namespace should be assumed to be the same as the Ingress.
       * If set the secret should have the same namespace as the Ingress otherwise
       * the behaviour is undefined and not supported.
       */
      secretNamespace?: string
    }

    /**
     * Status is the current state of the Ingress.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface IngressStatus {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.networking.v1alpha1.IngressStatusConditions[]
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
      /**
       * PrivateLoadBalancer contains the current status of the load-balancer.
       */
      privateLoadBalancer?: outputs.networking.v1alpha1.IngressStatusPrivateLoadBalancer
      /**
       * PublicLoadBalancer contains the current status of the load-balancer.
       */
      publicLoadBalancer?: outputs.networking.v1alpha1.IngressStatusPublicLoadBalancer
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface IngressStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }

    /**
     * PrivateLoadBalancer contains the current status of the load-balancer.
     */
    export interface IngressStatusPrivateLoadBalancer {
      /**
       * Ingress is a list containing ingress points for the load-balancer.
       * Traffic intended for the service should be sent to these ingress points.
       */
      ingress?: outputs.networking.v1alpha1.IngressStatusPrivateLoadBalancerIngress[]
    }

    /**
     * LoadBalancerIngressStatus represents the status of a load-balancer ingress point:
     * traffic intended for the service should be sent to an ingress point.
     */
    export interface IngressStatusPrivateLoadBalancerIngress {
      /**
       * Domain is set for load-balancer ingress points that are DNS based
       * (typically AWS load-balancers)
       */
      domain?: string
      /**
       * DomainInternal is set if there is a cluster-local DNS name to access the Ingress.
       *
       *
       * NOTE: This differs from K8s Ingress, since we also desire to have a cluster-local
       *       DNS name to allow routing in case of not having a mesh.
       */
      domainInternal?: string
      /**
       * IP is set for load-balancer ingress points that are IP based
       * (typically GCE or OpenStack load-balancers)
       */
      ip?: string
      /**
       * MeshOnly is set if the Ingress is only load-balanced through a Service mesh.
       */
      meshOnly?: boolean
    }

    /**
     * PublicLoadBalancer contains the current status of the load-balancer.
     */
    export interface IngressStatusPublicLoadBalancer {
      /**
       * Ingress is a list containing ingress points for the load-balancer.
       * Traffic intended for the service should be sent to these ingress points.
       */
      ingress?: outputs.networking.v1alpha1.IngressStatusPublicLoadBalancerIngress[]
    }

    /**
     * LoadBalancerIngressStatus represents the status of a load-balancer ingress point:
     * traffic intended for the service should be sent to an ingress point.
     */
    export interface IngressStatusPublicLoadBalancerIngress {
      /**
       * Domain is set for load-balancer ingress points that are DNS based
       * (typically AWS load-balancers)
       */
      domain?: string
      /**
       * DomainInternal is set if there is a cluster-local DNS name to access the Ingress.
       *
       *
       * NOTE: This differs from K8s Ingress, since we also desire to have a cluster-local
       *       DNS name to allow routing in case of not having a mesh.
       */
      domainInternal?: string
      /**
       * IP is set for load-balancer ingress points that are IP based
       * (typically GCE or OpenStack load-balancers)
       */
      ip?: string
      /**
       * MeshOnly is set if the Ingress is only load-balanced through a Service mesh.
       */
      meshOnly?: boolean
    }

    /**
     * Spec is the desired state of the ServerlessService.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface ServerlessServiceSpec {
      /**
       * Mode describes the mode of operation of the ServerlessService.
       */
      mode?: string
      /**
       * NumActivators contains number of Activators that this revision should be
       * assigned.
       * O means — assign all.
       */
      numActivators?: number
      /**
       * ObjectRef defines the resource that this ServerlessService
       * is responsible for making "serverless".
       */
      objectRef: outputs.networking.v1alpha1.ServerlessServiceSpecObjectRef
      /**
       * The application-layer protocol. Matches `RevisionProtocolType` set on the owning pa/revision.
       * serving imports networking, so just use string.
       */
      protocolType: string
    }

    /**
     * ObjectRef defines the resource that this ServerlessService
     * is responsible for making "serverless".
     */
    export interface ServerlessServiceSpecObjectRef {
      /**
       * API version of the referent.
       */
      apiVersion?: string
      /**
       * If referring to a piece of an object instead of an entire object, this string
       * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
       * For example, if the object reference is to a container within a pod, this would take on a value like:
       * "spec.containers{name}" (where "name" refers to the name of the container that triggered
       * the event) or if no container name is specified "spec.containers[2]" (container with
       * index 2 in this pod). This syntax is chosen only to have some well-defined way of
       * referencing a part of an object.
       * TODO: this design is not final and this field is subject to change in the future.
       */
      fieldPath?: string
      /**
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      kind?: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name?: string
      /**
       * Namespace of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
       */
      namespace?: string
      /**
       * Specific resourceVersion to which this reference is made, if any.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       */
      resourceVersion?: string
      /**
       * UID of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
       */
      uid?: string
    }

    /**
     * Status is the current state of the ServerlessService.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface ServerlessServiceStatus {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.networking.v1alpha1.ServerlessServiceStatusConditions[]
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
      /**
       * PrivateServiceName holds the name of a core K8s Service resource that
       * load balances over the user service pods backing this Revision.
       */
      privateServiceName?: string
      /**
       * ServiceName holds the name of a core K8s Service resource that
       * load balances over the pods backing this Revision (activator or revision).
       */
      serviceName?: string
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface ServerlessServiceStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }
  }
}

export namespace serving {
  export namespace v1 {
    /**
     * ConfigurationSpec holds the desired state of the Configuration (from the client).
     */
    export interface ConfigurationSpec {
      /**
       * Template holds the latest specification for the Revision to be stamped out.
       */
      template?: outputs.serving.v1.ConfigurationSpecTemplate
    }

    /**
     * Template holds the latest specification for the Revision to be stamped out.
     */
    export interface ConfigurationSpecTemplate {
      metadata?: { [key: string]: any }
      /**
       * RevisionSpec holds the desired state of the Revision (from the client).
       */
      spec?: outputs.serving.v1.ConfigurationSpecTemplateSpec
    }

    /**
     * RevisionSpec holds the desired state of the Revision (from the client).
     */
    export interface ConfigurationSpecTemplateSpec {
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-affinity
       */
      affinity?: { [key: string]: any }
      /**
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       */
      automountServiceAccountToken?: boolean
      /**
       * ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
       * requests per container of the Revision.  Defaults to `0` which means
       * concurrency to the application is not limited, and the system decides the
       * target concurrency for the autoscaler.
       */
      containerConcurrency?: number
      /**
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       */
      containers: outputs.serving.v1.ConfigurationSpecTemplateSpecContainers[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
       */
      dnsConfig?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
       */
      dnsPolicy?: string
      /**
       * EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
       */
      enableServiceLinks?: boolean
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-hostaliases
       */
      hostAliases?: { [key: string]: any }[]
      /**
       * IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
       * to stay open while not receiving any bytes from the user's application. If
       * unspecified, a system default will be provided.
       */
      idleTimeoutSeconds?: number
      /**
       * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
       */
      imagePullSecrets?: outputs.serving.v1.ConfigurationSpecTemplateSpecImagePullSecrets[]
      /**
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       */
      initContainers?: { [key: string]: any }[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-nodeselector
       */
      nodeSelector?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
       */
      priorityClassName?: { [key: string]: any }
      /**
       * ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
       * routing layer will wait for a request delivered to a container to begin
       * sending any network traffic.
       */
      responseStartTimeoutSeconds?: number
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
       */
      runtimeClassName?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-schedulername
       */
      schedulerName?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-securitycontext
       */
      securityContext?: { [key: string]: any }
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       */
      serviceAccountName?: string
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-shareproccessnamespace
       */
      shareProcessNamespace?: { [key: string]: any }
      /**
       * TimeoutSeconds is the maximum duration in seconds that the request instance
       * is allowed to respond to a request. If unspecified, a system default will
       * be provided.
       */
      timeoutSeconds?: number
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-tolerations
       */
      tolerations?: { [key: string]: any }[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
       */
      topologySpreadConstraints?: { [key: string]: any }[]
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       */
      volumes?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumes[]
    }

    /**
     * A single application container that you want to run within a pod.
     */
    export interface ConfigurationSpecTemplateSpecContainers {
      /**
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      args?: string[]
      /**
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      command?: string[]
      /**
       * List of environment variables to set in the container.
       * Cannot be updated.
       */
      env?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnv[]
      /**
       * List of sources to populate environment variables in the container.
       * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       * will be reported as an event when the container is starting. When a key exists in multiple
       * sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence.
       * Cannot be updated.
       */
      envFrom?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvFrom[]
      /**
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       */
      image?: string
      /**
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       */
      imagePullPolicy?: string
      /**
       * Periodic probe of container liveness.
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      livenessProbe?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbe
      /**
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       */
      name?: string
      /**
       * List of ports to expose from the container. Not specifying a port here
       * DOES NOT prevent that port from being exposed. Any port which is
       * listening on the default "0.0.0.0" address inside a container will be
       * accessible from the network.
       * Modifying this array with strategic merge patch may corrupt the data.
       * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
       * Cannot be updated.
       */
      ports?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersPorts[]
      /**
       * Periodic probe of container service readiness.
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      readinessProbe?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbe
      /**
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      resources?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersResources
      /**
       * SecurityContext defines the security options the container should be run with.
       * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       */
      securityContext?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersSecurityContext
      /**
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       */
      terminationMessagePath?: string
      /**
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       */
      terminationMessagePolicy?: string
      /**
       * Pod volumes to mount into the container's filesystem.
       * Cannot be updated.
       */
      volumeMounts?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersVolumeMounts[]
      /**
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string
    }

    /**
     * EnvVar represents an environment variable present in a Container.
     */
    export interface ConfigurationSpecTemplateSpecContainersEnv {
      /**
       * Name of the environment variable. Must be a C_IDENTIFIER.
       */
      name: string
      /**
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       */
      value?: string
      /**
       * Source for the environment variable's value. Cannot be used if value is not empty.
       */
      valueFrom?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvValueFrom
    }

    /**
     * EnvFromSource represents the source of a set of ConfigMaps
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvFrom {
      /**
       * The ConfigMap to select from
       */
      configMapRef?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvFromConfigMapRef
      /**
       * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
       */
      prefix?: string
      /**
       * The Secret to select from
       */
      secretRef?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvFromSecretRef
    }

    /**
     * The ConfigMap to select from
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvFromConfigMapRef {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean
    }

    /**
     * The Secret to select from
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvFromSecretRef {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean
    }

    /**
     * Source for the environment variable's value. Cannot be used if value is not empty.
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvValueFrom {
      /**
       * Selects a key of a ConfigMap.
       */
      configMapKeyRef?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      fieldRef?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      resourceFieldRef?: { [key: string]: any }
      /**
       * Selects a key of a secret in the pod's namespace
       */
      secretKeyRef?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvValueFromSecretKeyRef
    }

    /**
     * Selects a key of a ConfigMap.
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
      /**
       * The key to select.
       */
      key: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the ConfigMap or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Selects a key of a secret in the pod's namespace
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
      /**
       * The key of the secret to select from.  Must be a valid secret key.
       */
      key: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the Secret or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Periodic probe of container liveness.
     * Container will be restarted if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbe {
      /**
       * Exec specifies the action to take.
       */
      exec?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeExec
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: number
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeGrpc
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeHttpGet
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: number
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: number
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: number
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeTcpSocket
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: number
    }

    /**
     * Exec specifies the action to take.
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeExec {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: string[]
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeGrpc {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: number
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: string
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeHttpGet {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: string
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[]
      /**
       * Path to access on the HTTP server.
       */
      path?: string
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: string
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: string
      /**
       * The header field value
       */
      value: string
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeTcpSocket {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: string
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
    }

    /**
     * ContainerPort represents a network port in a single container.
     */
    export interface ConfigurationSpecTemplateSpecContainersPorts {
      /**
       * Number of port to expose on the pod's IP address.
       * This must be a valid port number, 0 < x < 65536.
       */
      containerPort: number
      /**
       * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
       * named port in a pod must have a unique name. Name for the port that can be
       * referred to by services.
       */
      name?: string
      /**
       * Protocol for port. Must be UDP, TCP, or SCTP.
       * Defaults to "TCP".
       */
      protocol?: string
    }
    /**
     * configurationSpecTemplateSpecContainersPortsProvideDefaults sets the appropriate defaults for ConfigurationSpecTemplateSpecContainersPorts
     */
    export function configurationSpecTemplateSpecContainersPortsProvideDefaults(
      val: ConfigurationSpecTemplateSpecContainersPorts,
    ): ConfigurationSpecTemplateSpecContainersPorts {
      return {
        ...val,
        protocol: val.protocol ?? "TCP",
      }
    }

    /**
     * Periodic probe of container service readiness.
     * Container will be removed from service endpoints if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbe {
      /**
       * Exec specifies the action to take.
       */
      exec?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeExec
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: number
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeGrpc
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeHttpGet
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: number
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: number
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: number
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeTcpSocket
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: number
    }

    /**
     * Exec specifies the action to take.
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeExec {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: string[]
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeGrpc {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: number
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: string
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeHttpGet {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: string
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[]
      /**
       * Path to access on the HTTP server.
       */
      path?: string
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: string
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: string
      /**
       * The header field value
       */
      value: string
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeTcpSocket {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: string
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
    }

    /**
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     */
    export interface ConfigurationSpecTemplateSpecContainersResources {
      /**
       * Claims lists the names of resources, defined in spec.resourceClaims,
       * that are used by this container.
       *
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       *
       * This field is immutable. It can only be set for containers.
       */
      claims?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersResourcesClaims[]
      /**
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      limits?: { [key: string]: number | string }
      /**
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      requests?: { [key: string]: number | string }
    }

    /**
     * ResourceClaim references one entry in PodSpec.ResourceClaims.
     */
    export interface ConfigurationSpecTemplateSpecContainersResourcesClaims {
      /**
       * Name must match the name of one entry in pod.spec.resourceClaims of
       * the Pod where this field is used. It makes that resource available
       * inside a container.
       */
      name: string
    }

    /**
     * SecurityContext defines the security options the container should be run with.
     * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     */
    export interface ConfigurationSpecTemplateSpecContainersSecurityContext {
      /**
       * AllowPrivilegeEscalation controls whether a process can gain more
       * privileges than its parent process. This bool directly controls if
       * the no_new_privs flag will be set on the container process.
       * AllowPrivilegeEscalation is true always when the container is:
       * 1) run as Privileged
       * 2) has CAP_SYS_ADMIN
       * Note that this field cannot be set when spec.os.name is windows.
       */
      allowPrivilegeEscalation?: boolean
      /**
       * The capabilities to add/drop when running containers.
       * Defaults to the default set of capabilities granted by the container runtime.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      capabilities?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersSecurityContextCapabilities
      /**
       * Whether this container has a read-only root filesystem.
       * Default is false.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      readOnlyRootFilesystem?: boolean
      /**
       * The GID to run the entrypoint of the container process.
       * Uses runtime default if unset.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsGroup?: number
      /**
       * Indicates that the container must run as a non-root user.
       * If true, the Kubelet will validate the image at runtime to ensure that it
       * does not run as UID 0 (root) and fail to start the container if it does.
       * If unset or false, no such validation will be performed.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean
      /**
       * The UID to run the entrypoint of the container process.
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsUser?: number
      /**
       * The seccomp options to use by this container. If seccomp options are
       * provided at both the pod & container level, the container options
       * override the pod options.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      seccompProfile?: outputs.serving.v1.ConfigurationSpecTemplateSpecContainersSecurityContextSeccompProfile
    }

    /**
     * The capabilities to add/drop when running containers.
     * Defaults to the default set of capabilities granted by the container runtime.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface ConfigurationSpecTemplateSpecContainersSecurityContextCapabilities {
      /**
       * This is accessible behind a feature flag - kubernetes.containerspec-addcapabilities
       */
      add?: string[]
      /**
       * Removed capabilities
       */
      drop?: string[]
    }

    /**
     * The seccomp options to use by this container. If seccomp options are
     * provided at both the pod & container level, the container options
     * override the pod options.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface ConfigurationSpecTemplateSpecContainersSecurityContextSeccompProfile {
      /**
       * localhostProfile indicates a profile defined in a file on the node should be used.
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must be set if type is "Localhost". Must NOT be set for any other type.
       */
      localhostProfile?: string
      /**
       * type indicates which kind of seccomp profile will be applied.
       * Valid options are:
       *
       *
       * Localhost - a profile defined in a file on the node should be used.
       * RuntimeDefault - the container runtime default profile should be used.
       * Unconfined - no profile should be applied.
       */
      type: string
    }

    /**
     * VolumeMount describes a mounting of a Volume within a container.
     */
    export interface ConfigurationSpecTemplateSpecContainersVolumeMounts {
      /**
       * Path within the container at which the volume should be mounted.  Must
       * not contain ':'.
       */
      mountPath: string
      /**
       * This must match the Name of a Volume.
       */
      name: string
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       * Defaults to false.
       */
      readOnly?: boolean
      /**
       * Path within the volume from which the container's volume should be mounted.
       * Defaults to "" (volume's root).
       */
      subPath?: string
    }

    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface ConfigurationSpecTemplateSpecImagePullSecrets {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
    }

    /**
     * Volume represents a named volume in a pod that may be accessed by any container in the pod.
     */
    export interface ConfigurationSpecTemplateSpecVolumes {
      /**
       * configMap represents a configMap that should populate this volume
       */
      configMap?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesConfigMap
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-emptydir
       */
      emptyDir?: { [key: string]: any }
      /**
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name: string
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-persistent-volume-claim
       */
      persistentVolumeClaim?: { [key: string]: any }
      /**
       * projected items for all in one resources secrets, configmaps, and downward API
       */
      projected?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjected
      /**
       * secret represents a secret that should populate this volume.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secret?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesSecret
    }

    /**
     * configMap represents a configMap that should populate this volume
     */
    export interface ConfigurationSpecTemplateSpecVolumesConfigMap {
      /**
       * defaultMode is optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesConfigMapItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ConfigurationSpecTemplateSpecVolumesConfigMapItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * projected items for all in one resources secrets, configmaps, and downward API
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjected {
      /**
       * defaultMode are the mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * sources is the list of volume projections
       */
      sources?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSources[]
    }

    /**
     * Projection that may be projected along with other supported volume types
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSources {
      /**
       * configMap information about the configMap data to project
       */
      configMap?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesConfigMap
      /**
       * downwardAPI information about the downwardAPI data to project
       */
      downwardAPI?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApi
      /**
       * secret information about the secret data to project
       */
      secret?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesSecret
      /**
       * serviceAccountToken is information about the serviceAccountToken data to project
       */
      serviceAccountToken?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken
    }

    /**
     * configMap information about the configMap data to project
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesConfigMap {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesConfigMapItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * downwardAPI information about the downwardAPI data to project
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApi {
      /**
       * Items is a list of DownwardAPIVolume file
       */
      items?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems[]
    }

    /**
     * DownwardAPIVolumeFile represents information to create the file containing the pod field
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems {
      /**
       * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
       */
      fieldRef?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
      /**
       * Optional: mode bits used to set permissions on this file, must be an octal value
       * between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
       */
      path: string
      /**
       * Selects a resource of the container: only resources limits and requests
       * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
       */
      resourceFieldRef?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
    }

    /**
     * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
      /**
       * Version of the schema the FieldPath is written in terms of, defaults to "v1".
       */
      apiVersion?: string
      /**
       * Path of the field to select in the specified API version.
       */
      fieldPath: string
    }

    /**
     * Selects a resource of the container: only resources limits and requests
     * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
      /**
       * Container name: required for volumes, optional for env vars
       */
      containerName?: string
      /**
       * Specifies the output format of the exposed resources, defaults to "1"
       */
      divisor?: number | string
      /**
       * Required: resource to select
       */
      resource: string
    }

    /**
     * secret information about the secret data to project
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesSecret {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesSecretItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional field specify whether the Secret or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesSecretItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * serviceAccountToken is information about the serviceAccountToken data to project
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
      /**
       * audience is the intended audience of the token. A recipient of a token
       * must identify itself with an identifier specified in the audience of the
       * token, and otherwise should reject the token. The audience defaults to the
       * identifier of the apiserver.
       */
      audience?: string
      /**
       * expirationSeconds is the requested duration of validity of the service
       * account token. As the token approaches expiration, the kubelet volume
       * plugin will proactively rotate the service account token. The kubelet will
       * start trying to rotate the token if the token is older than 80 percent of
       * its time to live or if the token is older than 24 hours.Defaults to 1 hour
       * and must be at least 10 minutes.
       */
      expirationSeconds?: number
      /**
       * path is the path relative to the mount point of the file to project the
       * token into.
       */
      path: string
    }

    /**
     * secret represents a secret that should populate this volume.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    export interface ConfigurationSpecTemplateSpecVolumesSecret {
      /**
       * defaultMode is Optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values
       * for mode bits. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * items If unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.ConfigurationSpecTemplateSpecVolumesSecretItems[]
      /**
       * optional field specify whether the Secret or its keys must be defined
       */
      optional?: boolean
      /**
       * secretName is the name of the secret in the pod's namespace to use.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secretName?: string
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ConfigurationSpecTemplateSpecVolumesSecretItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * ConfigurationStatus communicates the observed state of the Configuration (from the controller).
     */
    export interface ConfigurationStatus {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.serving.v1.ConfigurationStatusConditions[]
      /**
       * LatestCreatedRevisionName is the last revision that was created from this
       * Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
       */
      latestCreatedRevisionName?: string
      /**
       * LatestReadyRevisionName holds the name of the latest Revision stamped out
       * from this Configuration that has had its "Ready" condition become "True".
       */
      latestReadyRevisionName?: string
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface ConfigurationStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }

    /**
     * RevisionSpec holds the desired state of the Revision (from the client).
     */
    export interface RevisionSpec {
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-affinity
       */
      affinity?: { [key: string]: any }
      /**
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       */
      automountServiceAccountToken?: boolean
      /**
       * ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
       * requests per container of the Revision.  Defaults to `0` which means
       * concurrency to the application is not limited, and the system decides the
       * target concurrency for the autoscaler.
       */
      containerConcurrency?: number
      /**
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       */
      containers: outputs.serving.v1.RevisionSpecContainers[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
       */
      dnsConfig?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
       */
      dnsPolicy?: string
      /**
       * EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
       */
      enableServiceLinks?: boolean
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-hostaliases
       */
      hostAliases?: { [key: string]: any }[]
      /**
       * IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
       * to stay open while not receiving any bytes from the user's application. If
       * unspecified, a system default will be provided.
       */
      idleTimeoutSeconds?: number
      /**
       * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
       */
      imagePullSecrets?: outputs.serving.v1.RevisionSpecImagePullSecrets[]
      /**
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       */
      initContainers?: { [key: string]: any }[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-nodeselector
       */
      nodeSelector?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
       */
      priorityClassName?: { [key: string]: any }
      /**
       * ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
       * routing layer will wait for a request delivered to a container to begin
       * sending any network traffic.
       */
      responseStartTimeoutSeconds?: number
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
       */
      runtimeClassName?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-schedulername
       */
      schedulerName?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-securitycontext
       */
      securityContext?: { [key: string]: any }
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       */
      serviceAccountName?: string
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-shareproccessnamespace
       */
      shareProcessNamespace?: { [key: string]: any }
      /**
       * TimeoutSeconds is the maximum duration in seconds that the request instance
       * is allowed to respond to a request. If unspecified, a system default will
       * be provided.
       */
      timeoutSeconds?: number
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-tolerations
       */
      tolerations?: { [key: string]: any }[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
       */
      topologySpreadConstraints?: { [key: string]: any }[]
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       */
      volumes?: outputs.serving.v1.RevisionSpecVolumes[]
    }

    /**
     * A single application container that you want to run within a pod.
     */
    export interface RevisionSpecContainers {
      /**
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      args?: string[]
      /**
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      command?: string[]
      /**
       * List of environment variables to set in the container.
       * Cannot be updated.
       */
      env?: outputs.serving.v1.RevisionSpecContainersEnv[]
      /**
       * List of sources to populate environment variables in the container.
       * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       * will be reported as an event when the container is starting. When a key exists in multiple
       * sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence.
       * Cannot be updated.
       */
      envFrom?: outputs.serving.v1.RevisionSpecContainersEnvFrom[]
      /**
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       */
      image?: string
      /**
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       */
      imagePullPolicy?: string
      /**
       * Periodic probe of container liveness.
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      livenessProbe?: outputs.serving.v1.RevisionSpecContainersLivenessProbe
      /**
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       */
      name?: string
      /**
       * List of ports to expose from the container. Not specifying a port here
       * DOES NOT prevent that port from being exposed. Any port which is
       * listening on the default "0.0.0.0" address inside a container will be
       * accessible from the network.
       * Modifying this array with strategic merge patch may corrupt the data.
       * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
       * Cannot be updated.
       */
      ports?: outputs.serving.v1.RevisionSpecContainersPorts[]
      /**
       * Periodic probe of container service readiness.
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      readinessProbe?: outputs.serving.v1.RevisionSpecContainersReadinessProbe
      /**
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      resources?: outputs.serving.v1.RevisionSpecContainersResources
      /**
       * SecurityContext defines the security options the container should be run with.
       * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       */
      securityContext?: outputs.serving.v1.RevisionSpecContainersSecurityContext
      /**
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       */
      terminationMessagePath?: string
      /**
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       */
      terminationMessagePolicy?: string
      /**
       * Pod volumes to mount into the container's filesystem.
       * Cannot be updated.
       */
      volumeMounts?: outputs.serving.v1.RevisionSpecContainersVolumeMounts[]
      /**
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string
    }

    /**
     * EnvVar represents an environment variable present in a Container.
     */
    export interface RevisionSpecContainersEnv {
      /**
       * Name of the environment variable. Must be a C_IDENTIFIER.
       */
      name: string
      /**
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       */
      value?: string
      /**
       * Source for the environment variable's value. Cannot be used if value is not empty.
       */
      valueFrom?: outputs.serving.v1.RevisionSpecContainersEnvValueFrom
    }

    /**
     * EnvFromSource represents the source of a set of ConfigMaps
     */
    export interface RevisionSpecContainersEnvFrom {
      /**
       * The ConfigMap to select from
       */
      configMapRef?: outputs.serving.v1.RevisionSpecContainersEnvFromConfigMapRef
      /**
       * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
       */
      prefix?: string
      /**
       * The Secret to select from
       */
      secretRef?: outputs.serving.v1.RevisionSpecContainersEnvFromSecretRef
    }

    /**
     * The ConfigMap to select from
     */
    export interface RevisionSpecContainersEnvFromConfigMapRef {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean
    }

    /**
     * The Secret to select from
     */
    export interface RevisionSpecContainersEnvFromSecretRef {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean
    }

    /**
     * Source for the environment variable's value. Cannot be used if value is not empty.
     */
    export interface RevisionSpecContainersEnvValueFrom {
      /**
       * Selects a key of a ConfigMap.
       */
      configMapKeyRef?: outputs.serving.v1.RevisionSpecContainersEnvValueFromConfigMapKeyRef
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      fieldRef?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      resourceFieldRef?: { [key: string]: any }
      /**
       * Selects a key of a secret in the pod's namespace
       */
      secretKeyRef?: outputs.serving.v1.RevisionSpecContainersEnvValueFromSecretKeyRef
    }

    /**
     * Selects a key of a ConfigMap.
     */
    export interface RevisionSpecContainersEnvValueFromConfigMapKeyRef {
      /**
       * The key to select.
       */
      key: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the ConfigMap or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Selects a key of a secret in the pod's namespace
     */
    export interface RevisionSpecContainersEnvValueFromSecretKeyRef {
      /**
       * The key of the secret to select from.  Must be a valid secret key.
       */
      key: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the Secret or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Periodic probe of container liveness.
     * Container will be restarted if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface RevisionSpecContainersLivenessProbe {
      /**
       * Exec specifies the action to take.
       */
      exec?: outputs.serving.v1.RevisionSpecContainersLivenessProbeExec
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: number
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: outputs.serving.v1.RevisionSpecContainersLivenessProbeGrpc
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: outputs.serving.v1.RevisionSpecContainersLivenessProbeHttpGet
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: number
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: number
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: number
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: outputs.serving.v1.RevisionSpecContainersLivenessProbeTcpSocket
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: number
    }

    /**
     * Exec specifies the action to take.
     */
    export interface RevisionSpecContainersLivenessProbeExec {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: string[]
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface RevisionSpecContainersLivenessProbeGrpc {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: number
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: string
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface RevisionSpecContainersLivenessProbeHttpGet {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: string
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: outputs.serving.v1.RevisionSpecContainersLivenessProbeHttpGetHttpHeaders[]
      /**
       * Path to access on the HTTP server.
       */
      path?: string
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: string
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface RevisionSpecContainersLivenessProbeHttpGetHttpHeaders {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: string
      /**
       * The header field value
       */
      value: string
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface RevisionSpecContainersLivenessProbeTcpSocket {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: string
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
    }

    /**
     * ContainerPort represents a network port in a single container.
     */
    export interface RevisionSpecContainersPorts {
      /**
       * Number of port to expose on the pod's IP address.
       * This must be a valid port number, 0 < x < 65536.
       */
      containerPort: number
      /**
       * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
       * named port in a pod must have a unique name. Name for the port that can be
       * referred to by services.
       */
      name?: string
      /**
       * Protocol for port. Must be UDP, TCP, or SCTP.
       * Defaults to "TCP".
       */
      protocol?: string
    }
    /**
     * revisionSpecContainersPortsProvideDefaults sets the appropriate defaults for RevisionSpecContainersPorts
     */
    export function revisionSpecContainersPortsProvideDefaults(
      val: RevisionSpecContainersPorts,
    ): RevisionSpecContainersPorts {
      return {
        ...val,
        protocol: val.protocol ?? "TCP",
      }
    }

    /**
     * Periodic probe of container service readiness.
     * Container will be removed from service endpoints if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface RevisionSpecContainersReadinessProbe {
      /**
       * Exec specifies the action to take.
       */
      exec?: outputs.serving.v1.RevisionSpecContainersReadinessProbeExec
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: number
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: outputs.serving.v1.RevisionSpecContainersReadinessProbeGrpc
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: outputs.serving.v1.RevisionSpecContainersReadinessProbeHttpGet
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: number
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: number
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: number
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: outputs.serving.v1.RevisionSpecContainersReadinessProbeTcpSocket
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: number
    }

    /**
     * Exec specifies the action to take.
     */
    export interface RevisionSpecContainersReadinessProbeExec {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: string[]
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface RevisionSpecContainersReadinessProbeGrpc {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: number
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: string
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface RevisionSpecContainersReadinessProbeHttpGet {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: string
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: outputs.serving.v1.RevisionSpecContainersReadinessProbeHttpGetHttpHeaders[]
      /**
       * Path to access on the HTTP server.
       */
      path?: string
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: string
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface RevisionSpecContainersReadinessProbeHttpGetHttpHeaders {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: string
      /**
       * The header field value
       */
      value: string
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface RevisionSpecContainersReadinessProbeTcpSocket {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: string
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
    }

    /**
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     */
    export interface RevisionSpecContainersResources {
      /**
       * Claims lists the names of resources, defined in spec.resourceClaims,
       * that are used by this container.
       *
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       *
       * This field is immutable. It can only be set for containers.
       */
      claims?: outputs.serving.v1.RevisionSpecContainersResourcesClaims[]
      /**
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      limits?: { [key: string]: number | string }
      /**
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      requests?: { [key: string]: number | string }
    }

    /**
     * ResourceClaim references one entry in PodSpec.ResourceClaims.
     */
    export interface RevisionSpecContainersResourcesClaims {
      /**
       * Name must match the name of one entry in pod.spec.resourceClaims of
       * the Pod where this field is used. It makes that resource available
       * inside a container.
       */
      name: string
    }

    /**
     * SecurityContext defines the security options the container should be run with.
     * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     */
    export interface RevisionSpecContainersSecurityContext {
      /**
       * AllowPrivilegeEscalation controls whether a process can gain more
       * privileges than its parent process. This bool directly controls if
       * the no_new_privs flag will be set on the container process.
       * AllowPrivilegeEscalation is true always when the container is:
       * 1) run as Privileged
       * 2) has CAP_SYS_ADMIN
       * Note that this field cannot be set when spec.os.name is windows.
       */
      allowPrivilegeEscalation?: boolean
      /**
       * The capabilities to add/drop when running containers.
       * Defaults to the default set of capabilities granted by the container runtime.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      capabilities?: outputs.serving.v1.RevisionSpecContainersSecurityContextCapabilities
      /**
       * Whether this container has a read-only root filesystem.
       * Default is false.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      readOnlyRootFilesystem?: boolean
      /**
       * The GID to run the entrypoint of the container process.
       * Uses runtime default if unset.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsGroup?: number
      /**
       * Indicates that the container must run as a non-root user.
       * If true, the Kubelet will validate the image at runtime to ensure that it
       * does not run as UID 0 (root) and fail to start the container if it does.
       * If unset or false, no such validation will be performed.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean
      /**
       * The UID to run the entrypoint of the container process.
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsUser?: number
      /**
       * The seccomp options to use by this container. If seccomp options are
       * provided at both the pod & container level, the container options
       * override the pod options.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      seccompProfile?: outputs.serving.v1.RevisionSpecContainersSecurityContextSeccompProfile
    }

    /**
     * The capabilities to add/drop when running containers.
     * Defaults to the default set of capabilities granted by the container runtime.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface RevisionSpecContainersSecurityContextCapabilities {
      /**
       * This is accessible behind a feature flag - kubernetes.containerspec-addcapabilities
       */
      add?: string[]
      /**
       * Removed capabilities
       */
      drop?: string[]
    }

    /**
     * The seccomp options to use by this container. If seccomp options are
     * provided at both the pod & container level, the container options
     * override the pod options.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface RevisionSpecContainersSecurityContextSeccompProfile {
      /**
       * localhostProfile indicates a profile defined in a file on the node should be used.
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must be set if type is "Localhost". Must NOT be set for any other type.
       */
      localhostProfile?: string
      /**
       * type indicates which kind of seccomp profile will be applied.
       * Valid options are:
       *
       *
       * Localhost - a profile defined in a file on the node should be used.
       * RuntimeDefault - the container runtime default profile should be used.
       * Unconfined - no profile should be applied.
       */
      type: string
    }

    /**
     * VolumeMount describes a mounting of a Volume within a container.
     */
    export interface RevisionSpecContainersVolumeMounts {
      /**
       * Path within the container at which the volume should be mounted.  Must
       * not contain ':'.
       */
      mountPath: string
      /**
       * This must match the Name of a Volume.
       */
      name: string
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       * Defaults to false.
       */
      readOnly?: boolean
      /**
       * Path within the volume from which the container's volume should be mounted.
       * Defaults to "" (volume's root).
       */
      subPath?: string
    }

    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface RevisionSpecImagePullSecrets {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
    }

    /**
     * Volume represents a named volume in a pod that may be accessed by any container in the pod.
     */
    export interface RevisionSpecVolumes {
      /**
       * configMap represents a configMap that should populate this volume
       */
      configMap?: outputs.serving.v1.RevisionSpecVolumesConfigMap
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-emptydir
       */
      emptyDir?: { [key: string]: any }
      /**
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name: string
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-persistent-volume-claim
       */
      persistentVolumeClaim?: { [key: string]: any }
      /**
       * projected items for all in one resources secrets, configmaps, and downward API
       */
      projected?: outputs.serving.v1.RevisionSpecVolumesProjected
      /**
       * secret represents a secret that should populate this volume.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secret?: outputs.serving.v1.RevisionSpecVolumesSecret
    }

    /**
     * configMap represents a configMap that should populate this volume
     */
    export interface RevisionSpecVolumesConfigMap {
      /**
       * defaultMode is optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.RevisionSpecVolumesConfigMapItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface RevisionSpecVolumesConfigMapItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * projected items for all in one resources secrets, configmaps, and downward API
     */
    export interface RevisionSpecVolumesProjected {
      /**
       * defaultMode are the mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * sources is the list of volume projections
       */
      sources?: outputs.serving.v1.RevisionSpecVolumesProjectedSources[]
    }

    /**
     * Projection that may be projected along with other supported volume types
     */
    export interface RevisionSpecVolumesProjectedSources {
      /**
       * configMap information about the configMap data to project
       */
      configMap?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesConfigMap
      /**
       * downwardAPI information about the downwardAPI data to project
       */
      downwardAPI?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesDownwardApi
      /**
       * secret information about the secret data to project
       */
      secret?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesSecret
      /**
       * serviceAccountToken is information about the serviceAccountToken data to project
       */
      serviceAccountToken?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesServiceAccountToken
    }

    /**
     * configMap information about the configMap data to project
     */
    export interface RevisionSpecVolumesProjectedSourcesConfigMap {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesConfigMapItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface RevisionSpecVolumesProjectedSourcesConfigMapItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * downwardAPI information about the downwardAPI data to project
     */
    export interface RevisionSpecVolumesProjectedSourcesDownwardApi {
      /**
       * Items is a list of DownwardAPIVolume file
       */
      items?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesDownwardApiItems[]
    }

    /**
     * DownwardAPIVolumeFile represents information to create the file containing the pod field
     */
    export interface RevisionSpecVolumesProjectedSourcesDownwardApiItems {
      /**
       * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
       */
      fieldRef?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
      /**
       * Optional: mode bits used to set permissions on this file, must be an octal value
       * between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
       */
      path: string
      /**
       * Selects a resource of the container: only resources limits and requests
       * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
       */
      resourceFieldRef?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
    }

    /**
     * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
     */
    export interface RevisionSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
      /**
       * Version of the schema the FieldPath is written in terms of, defaults to "v1".
       */
      apiVersion?: string
      /**
       * Path of the field to select in the specified API version.
       */
      fieldPath: string
    }

    /**
     * Selects a resource of the container: only resources limits and requests
     * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
     */
    export interface RevisionSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
      /**
       * Container name: required for volumes, optional for env vars
       */
      containerName?: string
      /**
       * Specifies the output format of the exposed resources, defaults to "1"
       */
      divisor?: number | string
      /**
       * Required: resource to select
       */
      resource: string
    }

    /**
     * secret information about the secret data to project
     */
    export interface RevisionSpecVolumesProjectedSourcesSecret {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.RevisionSpecVolumesProjectedSourcesSecretItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional field specify whether the Secret or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface RevisionSpecVolumesProjectedSourcesSecretItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * serviceAccountToken is information about the serviceAccountToken data to project
     */
    export interface RevisionSpecVolumesProjectedSourcesServiceAccountToken {
      /**
       * audience is the intended audience of the token. A recipient of a token
       * must identify itself with an identifier specified in the audience of the
       * token, and otherwise should reject the token. The audience defaults to the
       * identifier of the apiserver.
       */
      audience?: string
      /**
       * expirationSeconds is the requested duration of validity of the service
       * account token. As the token approaches expiration, the kubelet volume
       * plugin will proactively rotate the service account token. The kubelet will
       * start trying to rotate the token if the token is older than 80 percent of
       * its time to live or if the token is older than 24 hours.Defaults to 1 hour
       * and must be at least 10 minutes.
       */
      expirationSeconds?: number
      /**
       * path is the path relative to the mount point of the file to project the
       * token into.
       */
      path: string
    }

    /**
     * secret represents a secret that should populate this volume.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    export interface RevisionSpecVolumesSecret {
      /**
       * defaultMode is Optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values
       * for mode bits. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * items If unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.RevisionSpecVolumesSecretItems[]
      /**
       * optional field specify whether the Secret or its keys must be defined
       */
      optional?: boolean
      /**
       * secretName is the name of the secret in the pod's namespace to use.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secretName?: string
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface RevisionSpecVolumesSecretItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * RevisionStatus communicates the observed state of the Revision (from the controller).
     */
    export interface RevisionStatus {
      /**
       * ActualReplicas reflects the amount of ready pods running this revision.
       */
      actualReplicas?: number
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.serving.v1.RevisionStatusConditions[]
      /**
       * ContainerStatuses is a slice of images present in .Spec.Container[*].Image
       * to their respective digests and their container name.
       * The digests are resolved during the creation of Revision.
       * ContainerStatuses holds the container name and image digests
       * for both serving and non serving containers.
       * ref: http://bit.ly/image-digests
       */
      containerStatuses?: outputs.serving.v1.RevisionStatusContainerStatuses[]
      /**
       * DesiredReplicas reflects the desired amount of pods running this revision.
       */
      desiredReplicas?: number
      /**
       * InitContainerStatuses is a slice of images present in .Spec.InitContainer[*].Image
       * to their respective digests and their container name.
       * The digests are resolved during the creation of Revision.
       * ContainerStatuses holds the container name and image digests
       * for both serving and non serving containers.
       * ref: http://bit.ly/image-digests
       */
      initContainerStatuses?: outputs.serving.v1.RevisionStatusInitContainerStatuses[]
      /**
       * LogURL specifies the generated logging url for this particular revision
       * based on the revision url template specified in the controller's config.
       */
      logUrl?: string
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface RevisionStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }

    /**
     * ContainerStatus holds the information of container name and image digest value
     */
    export interface RevisionStatusContainerStatuses {
      imageDigest?: string
      name?: string
    }

    /**
     * ContainerStatus holds the information of container name and image digest value
     */
    export interface RevisionStatusInitContainerStatuses {
      imageDigest?: string
      name?: string
    }

    /**
     * Spec holds the desired state of the Route (from the client).
     */
    export interface RouteSpec {
      /**
       * Traffic specifies how to distribute traffic over a collection of
       * revisions and configurations.
       */
      traffic?: outputs.serving.v1.RouteSpecTraffic[]
    }

    /**
     * TrafficTarget holds a single entry of the routing table for a Route.
     */
    export interface RouteSpecTraffic {
      /**
       * ConfigurationName of a configuration to whose latest revision we will send
       * this portion of traffic. When the "status.latestReadyRevisionName" of the
       * referenced configuration changes, we will automatically migrate traffic
       * from the prior "latest ready" revision to the new one.  This field is never
       * set in Route's status, only its spec.  This is mutually exclusive with
       * RevisionName.
       */
      configurationName?: string
      /**
       * LatestRevision may be optionally provided to indicate that the latest
       * ready Revision of the Configuration should be used for this traffic
       * target.  When provided LatestRevision must be true if RevisionName is
       * empty; it must be false when RevisionName is non-empty.
       */
      latestRevision?: boolean
      /**
       * Percent indicates that percentage based routing should be used and
       * the value indicates the percent of traffic that is be routed to this
       * Revision or Configuration. `0` (zero) mean no traffic, `100` means all
       * traffic.
       * When percentage based routing is being used the follow rules apply:
       * - the sum of all percent values must equal 100
       * - when not specified, the implied value for `percent` is zero for
       *   that particular Revision or Configuration
       */
      percent?: number
      /**
       * RevisionName of a specific revision to which to send this portion of
       * traffic.  This is mutually exclusive with ConfigurationName.
       */
      revisionName?: string
      /**
       * Tag is optionally used to expose a dedicated url for referencing
       * this target exclusively.
       */
      tag?: string
      /**
       * URL displays the URL for accessing named traffic targets. URL is displayed in
       * status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
       * a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
       */
      url?: string
    }

    /**
     * Status communicates the observed state of the Route (from the controller).
     */
    export interface RouteStatus {
      /**
       * Address holds the information needed for a Route to be the target of an event.
       */
      address?: outputs.serving.v1.RouteStatusAddress
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.serving.v1.RouteStatusConditions[]
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
      /**
       * Traffic holds the configured traffic distribution.
       * These entries will always contain RevisionName references.
       * When ConfigurationName appears in the spec, this will hold the
       * LatestReadyRevisionName that we last observed.
       */
      traffic?: outputs.serving.v1.RouteStatusTraffic[]
      /**
       * URL holds the url that will distribute traffic over the provided traffic targets.
       * It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
       */
      url?: string
    }

    /**
     * Address holds the information needed for a Route to be the target of an event.
     */
    export interface RouteStatusAddress {
      /**
       * CACerts is the Certification Authority (CA) certificates in PEM format
       * according to https://www.rfc-editor.org/rfc/rfc7468.
       */
      CACerts?: string
      /**
       * Audience is the OIDC audience for this address.
       */
      audience?: string
      /**
       * Name is the name of the address.
       */
      name?: string
      url?: string
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface RouteStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }

    /**
     * TrafficTarget holds a single entry of the routing table for a Route.
     */
    export interface RouteStatusTraffic {
      /**
       * ConfigurationName of a configuration to whose latest revision we will send
       * this portion of traffic. When the "status.latestReadyRevisionName" of the
       * referenced configuration changes, we will automatically migrate traffic
       * from the prior "latest ready" revision to the new one.  This field is never
       * set in Route's status, only its spec.  This is mutually exclusive with
       * RevisionName.
       */
      configurationName?: string
      /**
       * LatestRevision may be optionally provided to indicate that the latest
       * ready Revision of the Configuration should be used for this traffic
       * target.  When provided LatestRevision must be true if RevisionName is
       * empty; it must be false when RevisionName is non-empty.
       */
      latestRevision?: boolean
      /**
       * Percent indicates that percentage based routing should be used and
       * the value indicates the percent of traffic that is be routed to this
       * Revision or Configuration. `0` (zero) mean no traffic, `100` means all
       * traffic.
       * When percentage based routing is being used the follow rules apply:
       * - the sum of all percent values must equal 100
       * - when not specified, the implied value for `percent` is zero for
       *   that particular Revision or Configuration
       */
      percent?: number
      /**
       * RevisionName of a specific revision to which to send this portion of
       * traffic.  This is mutually exclusive with ConfigurationName.
       */
      revisionName?: string
      /**
       * Tag is optionally used to expose a dedicated url for referencing
       * this target exclusively.
       */
      tag?: string
      /**
       * URL displays the URL for accessing named traffic targets. URL is displayed in
       * status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
       * a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
       */
      url?: string
    }

    /**
     * ServiceSpec represents the configuration for the Service object.
     * A Service's specification is the union of the specifications for a Route
     * and Configuration.  The Service restricts what can be expressed in these
     * fields, e.g. the Route must reference the provided Configuration;
     * however, these limitations also enable friendlier defaulting,
     * e.g. Route never needs a Configuration name, and may be defaulted to
     * the appropriate "run latest" spec.
     */
    export interface ServiceSpec {
      /**
       * Template holds the latest specification for the Revision to be stamped out.
       */
      template?: outputs.serving.v1.ServiceSpecTemplate
      /**
       * Traffic specifies how to distribute traffic over a collection of
       * revisions and configurations.
       */
      traffic?: outputs.serving.v1.ServiceSpecTraffic[]
    }

    /**
     * Template holds the latest specification for the Revision to be stamped out.
     */
    export interface ServiceSpecTemplate {
      metadata?: { [key: string]: any }
      /**
       * RevisionSpec holds the desired state of the Revision (from the client).
       */
      spec?: outputs.serving.v1.ServiceSpecTemplateSpec
    }

    /**
     * RevisionSpec holds the desired state of the Revision (from the client).
     */
    export interface ServiceSpecTemplateSpec {
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-affinity
       */
      affinity?: { [key: string]: any }
      /**
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       */
      automountServiceAccountToken?: boolean
      /**
       * ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
       * requests per container of the Revision.  Defaults to `0` which means
       * concurrency to the application is not limited, and the system decides the
       * target concurrency for the autoscaler.
       */
      containerConcurrency?: number
      /**
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       */
      containers: outputs.serving.v1.ServiceSpecTemplateSpecContainers[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
       */
      dnsConfig?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
       */
      dnsPolicy?: string
      /**
       * EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
       */
      enableServiceLinks?: boolean
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-hostaliases
       */
      hostAliases?: { [key: string]: any }[]
      /**
       * IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
       * to stay open while not receiving any bytes from the user's application. If
       * unspecified, a system default will be provided.
       */
      idleTimeoutSeconds?: number
      /**
       * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
       */
      imagePullSecrets?: outputs.serving.v1.ServiceSpecTemplateSpecImagePullSecrets[]
      /**
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       */
      initContainers?: { [key: string]: any }[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-nodeselector
       */
      nodeSelector?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
       */
      priorityClassName?: { [key: string]: any }
      /**
       * ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
       * routing layer will wait for a request delivered to a container to begin
       * sending any network traffic.
       */
      responseStartTimeoutSeconds?: number
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
       */
      runtimeClassName?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-schedulername
       */
      schedulerName?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-securitycontext
       */
      securityContext?: { [key: string]: any }
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       */
      serviceAccountName?: string
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-shareproccessnamespace
       */
      shareProcessNamespace?: { [key: string]: any }
      /**
       * TimeoutSeconds is the maximum duration in seconds that the request instance
       * is allowed to respond to a request. If unspecified, a system default will
       * be provided.
       */
      timeoutSeconds?: number
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-tolerations
       */
      tolerations?: { [key: string]: any }[]
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
       */
      topologySpreadConstraints?: { [key: string]: any }[]
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       */
      volumes?: outputs.serving.v1.ServiceSpecTemplateSpecVolumes[]
    }

    /**
     * A single application container that you want to run within a pod.
     */
    export interface ServiceSpecTemplateSpecContainers {
      /**
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      args?: string[]
      /**
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      command?: string[]
      /**
       * List of environment variables to set in the container.
       * Cannot be updated.
       */
      env?: outputs.serving.v1.ServiceSpecTemplateSpecContainersEnv[]
      /**
       * List of sources to populate environment variables in the container.
       * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       * will be reported as an event when the container is starting. When a key exists in multiple
       * sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence.
       * Cannot be updated.
       */
      envFrom?: outputs.serving.v1.ServiceSpecTemplateSpecContainersEnvFrom[]
      /**
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       */
      image?: string
      /**
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       */
      imagePullPolicy?: string
      /**
       * Periodic probe of container liveness.
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      livenessProbe?: outputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbe
      /**
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       */
      name?: string
      /**
       * List of ports to expose from the container. Not specifying a port here
       * DOES NOT prevent that port from being exposed. Any port which is
       * listening on the default "0.0.0.0" address inside a container will be
       * accessible from the network.
       * Modifying this array with strategic merge patch may corrupt the data.
       * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
       * Cannot be updated.
       */
      ports?: outputs.serving.v1.ServiceSpecTemplateSpecContainersPorts[]
      /**
       * Periodic probe of container service readiness.
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      readinessProbe?: outputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbe
      /**
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      resources?: outputs.serving.v1.ServiceSpecTemplateSpecContainersResources
      /**
       * SecurityContext defines the security options the container should be run with.
       * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       */
      securityContext?: outputs.serving.v1.ServiceSpecTemplateSpecContainersSecurityContext
      /**
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       */
      terminationMessagePath?: string
      /**
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       */
      terminationMessagePolicy?: string
      /**
       * Pod volumes to mount into the container's filesystem.
       * Cannot be updated.
       */
      volumeMounts?: outputs.serving.v1.ServiceSpecTemplateSpecContainersVolumeMounts[]
      /**
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string
    }

    /**
     * EnvVar represents an environment variable present in a Container.
     */
    export interface ServiceSpecTemplateSpecContainersEnv {
      /**
       * Name of the environment variable. Must be a C_IDENTIFIER.
       */
      name: string
      /**
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       */
      value?: string
      /**
       * Source for the environment variable's value. Cannot be used if value is not empty.
       */
      valueFrom?: outputs.serving.v1.ServiceSpecTemplateSpecContainersEnvValueFrom
    }

    /**
     * EnvFromSource represents the source of a set of ConfigMaps
     */
    export interface ServiceSpecTemplateSpecContainersEnvFrom {
      /**
       * The ConfigMap to select from
       */
      configMapRef?: outputs.serving.v1.ServiceSpecTemplateSpecContainersEnvFromConfigMapRef
      /**
       * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
       */
      prefix?: string
      /**
       * The Secret to select from
       */
      secretRef?: outputs.serving.v1.ServiceSpecTemplateSpecContainersEnvFromSecretRef
    }

    /**
     * The ConfigMap to select from
     */
    export interface ServiceSpecTemplateSpecContainersEnvFromConfigMapRef {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean
    }

    /**
     * The Secret to select from
     */
    export interface ServiceSpecTemplateSpecContainersEnvFromSecretRef {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean
    }

    /**
     * Source for the environment variable's value. Cannot be used if value is not empty.
     */
    export interface ServiceSpecTemplateSpecContainersEnvValueFrom {
      /**
       * Selects a key of a ConfigMap.
       */
      configMapKeyRef?: outputs.serving.v1.ServiceSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      fieldRef?: { [key: string]: any }
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      resourceFieldRef?: { [key: string]: any }
      /**
       * Selects a key of a secret in the pod's namespace
       */
      secretKeyRef?: outputs.serving.v1.ServiceSpecTemplateSpecContainersEnvValueFromSecretKeyRef
    }

    /**
     * Selects a key of a ConfigMap.
     */
    export interface ServiceSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
      /**
       * The key to select.
       */
      key: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the ConfigMap or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Selects a key of a secret in the pod's namespace
     */
    export interface ServiceSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
      /**
       * The key of the secret to select from.  Must be a valid secret key.
       */
      key: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * Specify whether the Secret or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Periodic probe of container liveness.
     * Container will be restarted if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbe {
      /**
       * Exec specifies the action to take.
       */
      exec?: outputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeExec
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: number
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: outputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeGrpc
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: outputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeHttpGet
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: number
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: number
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: number
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: outputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeTcpSocket
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: number
    }

    /**
     * Exec specifies the action to take.
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeExec {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: string[]
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeGrpc {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: number
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: string
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeHttpGet {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: string
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: outputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[]
      /**
       * Path to access on the HTTP server.
       */
      path?: string
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: string
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: string
      /**
       * The header field value
       */
      value: string
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeTcpSocket {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: string
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
    }

    /**
     * ContainerPort represents a network port in a single container.
     */
    export interface ServiceSpecTemplateSpecContainersPorts {
      /**
       * Number of port to expose on the pod's IP address.
       * This must be a valid port number, 0 < x < 65536.
       */
      containerPort: number
      /**
       * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
       * named port in a pod must have a unique name. Name for the port that can be
       * referred to by services.
       */
      name?: string
      /**
       * Protocol for port. Must be UDP, TCP, or SCTP.
       * Defaults to "TCP".
       */
      protocol?: string
    }
    /**
     * serviceSpecTemplateSpecContainersPortsProvideDefaults sets the appropriate defaults for ServiceSpecTemplateSpecContainersPorts
     */
    export function serviceSpecTemplateSpecContainersPortsProvideDefaults(
      val: ServiceSpecTemplateSpecContainersPorts,
    ): ServiceSpecTemplateSpecContainersPorts {
      return {
        ...val,
        protocol: val.protocol ?? "TCP",
      }
    }

    /**
     * Periodic probe of container service readiness.
     * Container will be removed from service endpoints if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbe {
      /**
       * Exec specifies the action to take.
       */
      exec?: outputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeExec
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: number
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: outputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeGrpc
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: outputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeHttpGet
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: number
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: number
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: number
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: outputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeTcpSocket
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: number
    }

    /**
     * Exec specifies the action to take.
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeExec {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: string[]
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeGrpc {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: number
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: string
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeHttpGet {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: string
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: outputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[]
      /**
       * Path to access on the HTTP server.
       */
      path?: string
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: string
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: string
      /**
       * The header field value
       */
      value: string
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeTcpSocket {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: string
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: number | string
    }

    /**
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     */
    export interface ServiceSpecTemplateSpecContainersResources {
      /**
       * Claims lists the names of resources, defined in spec.resourceClaims,
       * that are used by this container.
       *
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       *
       * This field is immutable. It can only be set for containers.
       */
      claims?: outputs.serving.v1.ServiceSpecTemplateSpecContainersResourcesClaims[]
      /**
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      limits?: { [key: string]: number | string }
      /**
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      requests?: { [key: string]: number | string }
    }

    /**
     * ResourceClaim references one entry in PodSpec.ResourceClaims.
     */
    export interface ServiceSpecTemplateSpecContainersResourcesClaims {
      /**
       * Name must match the name of one entry in pod.spec.resourceClaims of
       * the Pod where this field is used. It makes that resource available
       * inside a container.
       */
      name: string
    }

    /**
     * SecurityContext defines the security options the container should be run with.
     * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     */
    export interface ServiceSpecTemplateSpecContainersSecurityContext {
      /**
       * AllowPrivilegeEscalation controls whether a process can gain more
       * privileges than its parent process. This bool directly controls if
       * the no_new_privs flag will be set on the container process.
       * AllowPrivilegeEscalation is true always when the container is:
       * 1) run as Privileged
       * 2) has CAP_SYS_ADMIN
       * Note that this field cannot be set when spec.os.name is windows.
       */
      allowPrivilegeEscalation?: boolean
      /**
       * The capabilities to add/drop when running containers.
       * Defaults to the default set of capabilities granted by the container runtime.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      capabilities?: outputs.serving.v1.ServiceSpecTemplateSpecContainersSecurityContextCapabilities
      /**
       * Whether this container has a read-only root filesystem.
       * Default is false.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      readOnlyRootFilesystem?: boolean
      /**
       * The GID to run the entrypoint of the container process.
       * Uses runtime default if unset.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsGroup?: number
      /**
       * Indicates that the container must run as a non-root user.
       * If true, the Kubelet will validate the image at runtime to ensure that it
       * does not run as UID 0 (root) and fail to start the container if it does.
       * If unset or false, no such validation will be performed.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean
      /**
       * The UID to run the entrypoint of the container process.
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsUser?: number
      /**
       * The seccomp options to use by this container. If seccomp options are
       * provided at both the pod & container level, the container options
       * override the pod options.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      seccompProfile?: outputs.serving.v1.ServiceSpecTemplateSpecContainersSecurityContextSeccompProfile
    }

    /**
     * The capabilities to add/drop when running containers.
     * Defaults to the default set of capabilities granted by the container runtime.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface ServiceSpecTemplateSpecContainersSecurityContextCapabilities {
      /**
       * This is accessible behind a feature flag - kubernetes.containerspec-addcapabilities
       */
      add?: string[]
      /**
       * Removed capabilities
       */
      drop?: string[]
    }

    /**
     * The seccomp options to use by this container. If seccomp options are
     * provided at both the pod & container level, the container options
     * override the pod options.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface ServiceSpecTemplateSpecContainersSecurityContextSeccompProfile {
      /**
       * localhostProfile indicates a profile defined in a file on the node should be used.
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must be set if type is "Localhost". Must NOT be set for any other type.
       */
      localhostProfile?: string
      /**
       * type indicates which kind of seccomp profile will be applied.
       * Valid options are:
       *
       *
       * Localhost - a profile defined in a file on the node should be used.
       * RuntimeDefault - the container runtime default profile should be used.
       * Unconfined - no profile should be applied.
       */
      type: string
    }

    /**
     * VolumeMount describes a mounting of a Volume within a container.
     */
    export interface ServiceSpecTemplateSpecContainersVolumeMounts {
      /**
       * Path within the container at which the volume should be mounted.  Must
       * not contain ':'.
       */
      mountPath: string
      /**
       * This must match the Name of a Volume.
       */
      name: string
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       * Defaults to false.
       */
      readOnly?: boolean
      /**
       * Path within the volume from which the container's volume should be mounted.
       * Defaults to "" (volume's root).
       */
      subPath?: string
    }

    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface ServiceSpecTemplateSpecImagePullSecrets {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
    }

    /**
     * Volume represents a named volume in a pod that may be accessed by any container in the pod.
     */
    export interface ServiceSpecTemplateSpecVolumes {
      /**
       * configMap represents a configMap that should populate this volume
       */
      configMap?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesConfigMap
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-emptydir
       */
      emptyDir?: { [key: string]: any }
      /**
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name: string
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-persistent-volume-claim
       */
      persistentVolumeClaim?: { [key: string]: any }
      /**
       * projected items for all in one resources secrets, configmaps, and downward API
       */
      projected?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjected
      /**
       * secret represents a secret that should populate this volume.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secret?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesSecret
    }

    /**
     * configMap represents a configMap that should populate this volume
     */
    export interface ServiceSpecTemplateSpecVolumesConfigMap {
      /**
       * defaultMode is optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesConfigMapItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ServiceSpecTemplateSpecVolumesConfigMapItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * projected items for all in one resources secrets, configmaps, and downward API
     */
    export interface ServiceSpecTemplateSpecVolumesProjected {
      /**
       * defaultMode are the mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * sources is the list of volume projections
       */
      sources?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSources[]
    }

    /**
     * Projection that may be projected along with other supported volume types
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSources {
      /**
       * configMap information about the configMap data to project
       */
      configMap?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesConfigMap
      /**
       * downwardAPI information about the downwardAPI data to project
       */
      downwardAPI?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApi
      /**
       * secret information about the secret data to project
       */
      secret?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesSecret
      /**
       * serviceAccountToken is information about the serviceAccountToken data to project
       */
      serviceAccountToken?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken
    }

    /**
     * configMap information about the configMap data to project
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesConfigMap {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesConfigMapItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * downwardAPI information about the downwardAPI data to project
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApi {
      /**
       * Items is a list of DownwardAPIVolume file
       */
      items?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems[]
    }

    /**
     * DownwardAPIVolumeFile represents information to create the file containing the pod field
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems {
      /**
       * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
       */
      fieldRef?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
      /**
       * Optional: mode bits used to set permissions on this file, must be an octal value
       * between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
       */
      path: string
      /**
       * Selects a resource of the container: only resources limits and requests
       * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
       */
      resourceFieldRef?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
    }

    /**
     * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
      /**
       * Version of the schema the FieldPath is written in terms of, defaults to "v1".
       */
      apiVersion?: string
      /**
       * Path of the field to select in the specified API version.
       */
      fieldPath: string
    }

    /**
     * Selects a resource of the container: only resources limits and requests
     * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
      /**
       * Container name: required for volumes, optional for env vars
       */
      containerName?: string
      /**
       * Specifies the output format of the exposed resources, defaults to "1"
       */
      divisor?: number | string
      /**
       * Required: resource to select
       */
      resource: string
    }

    /**
     * secret information about the secret data to project
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesSecret {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesSecretItems[]
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: string
      /**
       * optional field specify whether the Secret or its key must be defined
       */
      optional?: boolean
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesSecretItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * serviceAccountToken is information about the serviceAccountToken data to project
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
      /**
       * audience is the intended audience of the token. A recipient of a token
       * must identify itself with an identifier specified in the audience of the
       * token, and otherwise should reject the token. The audience defaults to the
       * identifier of the apiserver.
       */
      audience?: string
      /**
       * expirationSeconds is the requested duration of validity of the service
       * account token. As the token approaches expiration, the kubelet volume
       * plugin will proactively rotate the service account token. The kubelet will
       * start trying to rotate the token if the token is older than 80 percent of
       * its time to live or if the token is older than 24 hours.Defaults to 1 hour
       * and must be at least 10 minutes.
       */
      expirationSeconds?: number
      /**
       * path is the path relative to the mount point of the file to project the
       * token into.
       */
      path: string
    }

    /**
     * secret represents a secret that should populate this volume.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    export interface ServiceSpecTemplateSpecVolumesSecret {
      /**
       * defaultMode is Optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values
       * for mode bits. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number
      /**
       * items If unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: outputs.serving.v1.ServiceSpecTemplateSpecVolumesSecretItems[]
      /**
       * optional field specify whether the Secret or its keys must be defined
       */
      optional?: boolean
      /**
       * secretName is the name of the secret in the pod's namespace to use.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secretName?: string
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ServiceSpecTemplateSpecVolumesSecretItems {
      /**
       * key is the key to project.
       */
      key: string
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: number
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: string
    }

    /**
     * TrafficTarget holds a single entry of the routing table for a Route.
     */
    export interface ServiceSpecTraffic {
      /**
       * ConfigurationName of a configuration to whose latest revision we will send
       * this portion of traffic. When the "status.latestReadyRevisionName" of the
       * referenced configuration changes, we will automatically migrate traffic
       * from the prior "latest ready" revision to the new one.  This field is never
       * set in Route's status, only its spec.  This is mutually exclusive with
       * RevisionName.
       */
      configurationName?: string
      /**
       * LatestRevision may be optionally provided to indicate that the latest
       * ready Revision of the Configuration should be used for this traffic
       * target.  When provided LatestRevision must be true if RevisionName is
       * empty; it must be false when RevisionName is non-empty.
       */
      latestRevision?: boolean
      /**
       * Percent indicates that percentage based routing should be used and
       * the value indicates the percent of traffic that is be routed to this
       * Revision or Configuration. `0` (zero) mean no traffic, `100` means all
       * traffic.
       * When percentage based routing is being used the follow rules apply:
       * - the sum of all percent values must equal 100
       * - when not specified, the implied value for `percent` is zero for
       *   that particular Revision or Configuration
       */
      percent?: number
      /**
       * RevisionName of a specific revision to which to send this portion of
       * traffic.  This is mutually exclusive with ConfigurationName.
       */
      revisionName?: string
      /**
       * Tag is optionally used to expose a dedicated url for referencing
       * this target exclusively.
       */
      tag?: string
      /**
       * URL displays the URL for accessing named traffic targets. URL is displayed in
       * status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
       * a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
       */
      url?: string
    }

    /**
     * ServiceStatus represents the Status stanza of the Service resource.
     */
    export interface ServiceStatus {
      /**
       * Address holds the information needed for a Route to be the target of an event.
       */
      address?: outputs.serving.v1.ServiceStatusAddress
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.serving.v1.ServiceStatusConditions[]
      /**
       * LatestCreatedRevisionName is the last revision that was created from this
       * Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
       */
      latestCreatedRevisionName?: string
      /**
       * LatestReadyRevisionName holds the name of the latest Revision stamped out
       * from this Configuration that has had its "Ready" condition become "True".
       */
      latestReadyRevisionName?: string
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
      /**
       * Traffic holds the configured traffic distribution.
       * These entries will always contain RevisionName references.
       * When ConfigurationName appears in the spec, this will hold the
       * LatestReadyRevisionName that we last observed.
       */
      traffic?: outputs.serving.v1.ServiceStatusTraffic[]
      /**
       * URL holds the url that will distribute traffic over the provided traffic targets.
       * It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
       */
      url?: string
    }

    /**
     * Address holds the information needed for a Route to be the target of an event.
     */
    export interface ServiceStatusAddress {
      /**
       * CACerts is the Certification Authority (CA) certificates in PEM format
       * according to https://www.rfc-editor.org/rfc/rfc7468.
       */
      CACerts?: string
      /**
       * Audience is the OIDC audience for this address.
       */
      audience?: string
      /**
       * Name is the name of the address.
       */
      name?: string
      url?: string
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface ServiceStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }

    /**
     * TrafficTarget holds a single entry of the routing table for a Route.
     */
    export interface ServiceStatusTraffic {
      /**
       * ConfigurationName of a configuration to whose latest revision we will send
       * this portion of traffic. When the "status.latestReadyRevisionName" of the
       * referenced configuration changes, we will automatically migrate traffic
       * from the prior "latest ready" revision to the new one.  This field is never
       * set in Route's status, only its spec.  This is mutually exclusive with
       * RevisionName.
       */
      configurationName?: string
      /**
       * LatestRevision may be optionally provided to indicate that the latest
       * ready Revision of the Configuration should be used for this traffic
       * target.  When provided LatestRevision must be true if RevisionName is
       * empty; it must be false when RevisionName is non-empty.
       */
      latestRevision?: boolean
      /**
       * Percent indicates that percentage based routing should be used and
       * the value indicates the percent of traffic that is be routed to this
       * Revision or Configuration. `0` (zero) mean no traffic, `100` means all
       * traffic.
       * When percentage based routing is being used the follow rules apply:
       * - the sum of all percent values must equal 100
       * - when not specified, the implied value for `percent` is zero for
       *   that particular Revision or Configuration
       */
      percent?: number
      /**
       * RevisionName of a specific revision to which to send this portion of
       * traffic.  This is mutually exclusive with ConfigurationName.
       */
      revisionName?: string
      /**
       * Tag is optionally used to expose a dedicated url for referencing
       * this target exclusively.
       */
      tag?: string
      /**
       * URL displays the URL for accessing named traffic targets. URL is displayed in
       * status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
       * a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
       */
      url?: string
    }
  }

  export namespace v1beta1 {
    /**
     * Spec is the desired state of the DomainMapping.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface DomainMappingSpec {
      /**
       * Ref specifies the target of the Domain Mapping.
       *
       *
       * The object identified by the Ref must be an Addressable with a URL of the
       * form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain,
       * and `{name}` and `{namespace}` are the name and namespace of a Kubernetes
       * Service.
       *
       *
       * This contract is satisfied by Knative types such as Knative Services and
       * Knative Routes, and by Kubernetes Services.
       */
      ref: outputs.serving.v1beta1.DomainMappingSpecRef
      /**
       * TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
       */
      tls?: outputs.serving.v1beta1.DomainMappingSpecTls
    }

    /**
     * Ref specifies the target of the Domain Mapping.
     *
     *
     * The object identified by the Ref must be an Addressable with a URL of the
     * form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain,
     * and `{name}` and `{namespace}` are the name and namespace of a Kubernetes
     * Service.
     *
     *
     * This contract is satisfied by Knative types such as Knative Services and
     * Knative Routes, and by Kubernetes Services.
     */
    export interface DomainMappingSpecRef {
      /**
       * Address points to a specific Address Name.
       */
      address?: string
      /**
       * API version of the referent.
       */
      apiVersion?: string
      /**
       * Group of the API, without the version of the group. This can be used as an alternative to the APIVersion, and then resolved using ResolveGroup.
       * Note: This API is EXPERIMENTAL and might break anytime. For more details: https://github.com/knative/eventing/issues/5086
       */
      group?: string
      /**
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      kind: string
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name: string
      /**
       * Namespace of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
       * This is optional field, it gets defaulted to the object holding it if left out.
       */
      namespace?: string
    }

    /**
     * TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
     */
    export interface DomainMappingSpecTls {
      /**
       * SecretName is the name of the existing secret used to terminate TLS traffic.
       */
      secretName: string
    }

    /**
     * Status is the current state of the DomainMapping.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface DomainMappingStatus {
      /**
       * Address holds the information needed for a DomainMapping to be the target of an event.
       */
      address?: outputs.serving.v1beta1.DomainMappingStatusAddress
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: { [key: string]: string }
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: outputs.serving.v1beta1.DomainMappingStatusConditions[]
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: number
      /**
       * URL is the URL of this DomainMapping.
       */
      url?: string
    }

    /**
     * Address holds the information needed for a DomainMapping to be the target of an event.
     */
    export interface DomainMappingStatusAddress {
      /**
       * CACerts is the Certification Authority (CA) certificates in PEM format
       * according to https://www.rfc-editor.org/rfc/rfc7468.
       */
      CACerts?: string
      /**
       * Audience is the OIDC audience for this address.
       */
      audience?: string
      /**
       * Name is the name of the address.
       */
      name?: string
      url?: string
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface DomainMappingStatusConditions {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: string
      /**
       * A human readable message indicating details about the transition.
       */
      message?: string
      /**
       * The reason for the condition's last transition.
       */
      reason?: string
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: string
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: string
      /**
       * Type of condition.
       */
      type: string
    }
  }
}
