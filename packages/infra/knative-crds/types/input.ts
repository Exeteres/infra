// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi"
import * as inputs from "./input"
import * as outputs from "./output"

import * as utilities from "../utilities"

import { ObjectMeta } from "../meta/v1"

export namespace autoscaling {
  export namespace v1alpha1 {
    /**
     * Spec holds the desired state of the Metric (from the client).
     */
    export interface MetricSpecArgs {
      /**
       * PanicWindow is the aggregation window for metrics where quick reactions are needed.
       */
      panicWindow: pulumi.Input<number>
      /**
       * ScrapeTarget is the K8s service that publishes the metric endpoint.
       */
      scrapeTarget: pulumi.Input<string>
      /**
       * StableWindow is the aggregation window for metrics in a stable state.
       */
      stableWindow: pulumi.Input<number>
    }

    /**
     * Status communicates the observed state of the Metric (from the controller).
     */
    export interface MetricStatusArgs {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.autoscaling.v1alpha1.MetricStatusConditionsArgs>[]>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface MetricStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }

    /**
     * Spec holds the desired state of the PodAutoscaler (from the client).
     */
    export interface PodAutoscalerSpecArgs {
      /**
       * ContainerConcurrency specifies the maximum allowed
       * in-flight (concurrent) requests per container of the Revision.
       * Defaults to `0` which means unlimited concurrency.
       */
      containerConcurrency?: pulumi.Input<number>
      /**
       * The application-layer protocol. Matches `ProtocolType` inferred from the revision spec.
       */
      protocolType: pulumi.Input<string>
      /**
       * Reachability specifies whether or not the `ScaleTargetRef` can be reached (ie. has a route).
       * Defaults to `ReachabilityUnknown`
       */
      reachability?: pulumi.Input<string>
      /**
       * ScaleTargetRef defines the /scale-able resource that this PodAutoscaler
       * is responsible for quickly right-sizing.
       */
      scaleTargetRef: pulumi.Input<inputs.autoscaling.v1alpha1.PodAutoscalerSpecScaleTargetRefArgs>
    }

    /**
     * ScaleTargetRef defines the /scale-able resource that this PodAutoscaler
     * is responsible for quickly right-sizing.
     */
    export interface PodAutoscalerSpecScaleTargetRefArgs {
      /**
       * API version of the referent.
       */
      apiVersion?: pulumi.Input<string>
      /**
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      kind?: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name?: pulumi.Input<string>
    }

    /**
     * Status communicates the observed state of the PodAutoscaler (from the controller).
     */
    export interface PodAutoscalerStatusArgs {
      /**
       * ActualScale shows the actual number of replicas for the revision.
       */
      actualScale?: pulumi.Input<number>
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.autoscaling.v1alpha1.PodAutoscalerStatusConditionsArgs>[]>
      /**
       * DesiredScale shows the current desired number of replicas for the revision.
       */
      desiredScale?: pulumi.Input<number>
      /**
       * MetricsServiceName is the K8s Service name that provides revision metrics.
       * The service is managed by the PA object.
       */
      metricsServiceName: pulumi.Input<string>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
      /**
       * ServiceName is the K8s Service name that serves the revision, scaled by this PA.
       * The service is created and owned by the ServerlessService object owned by this PA.
       */
      serviceName: pulumi.Input<string>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface PodAutoscalerStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }
  }
}

export namespace caching {
  export namespace v1alpha1 {
    /**
     * Spec holds the desired state of the Image (from the client).
     */
    export interface ImageSpecArgs {
      /**
       * Image is the name of the container image url to cache across the cluster.
       */
      image: pulumi.Input<string>
      /**
       * ImagePullSecrets contains the names of the Kubernetes Secrets containing login
       * information used by the Pods which will run this container.
       */
      imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.caching.v1alpha1.ImageSpecImagePullSecretsArgs>[]>
      /**
       * ServiceAccountName is the name of the Kubernetes ServiceAccount as which the Pods
       * will run this container.  This is potentially used to authenticate the image pull
       * if the service account has attached pull secrets.  For more information:
       * https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account
       */
      serviceAccountName?: pulumi.Input<string>
    }

    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface ImageSpecImagePullSecretsArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
    }

    /**
     * Status communicates the observed state of the Image (from the controller).
     */
    export interface ImageStatusArgs {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.caching.v1alpha1.ImageStatusConditionsArgs>[]>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface ImageStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }
  }
}

export namespace networking {
  export namespace v1alpha1 {
    /**
     * Spec is the desired state of the Certificate.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface CertificateSpecArgs {
      /**
       * DNSNames is a list of DNS names the Certificate could support.
       * The wildcard format of DNSNames (e.g. *.default.example.com) is supported.
       */
      dnsNames: pulumi.Input<pulumi.Input<string>[]>
      /**
       * Domain is the top level domain of the values for DNSNames.
       */
      domain?: pulumi.Input<string>
      /**
       * SecretName is the name of the secret resource to store the SSL certificate in.
       */
      secretName: pulumi.Input<string>
    }

    /**
     * Status is the current state of the Certificate.
     * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface CertificateStatusArgs {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.CertificateStatusConditionsArgs>[]>
      /**
       * HTTP01Challenges is a list of HTTP01 challenges that need to be fulfilled
       * in order to get the TLS certificate..
       */
      http01Challenges?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.CertificateStatusHttp01ChallengesArgs>[]>
      /**
       * The expiration time of the TLS certificate stored in the secret named
       * by this resource in spec.secretName.
       */
      notAfter?: pulumi.Input<string>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface CertificateStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }

    /**
     * HTTP01Challenge defines the status of a HTTP01 challenge that a certificate needs
     * to fulfill.
     */
    export interface CertificateStatusHttp01ChallengesArgs {
      /**
       * ServiceName is the name of the service to serve HTTP01 challenge requests.
       */
      serviceName?: pulumi.Input<string>
      /**
       * ServiceNamespace is the namespace of the service to serve HTTP01 challenge requests.
       */
      serviceNamespace?: pulumi.Input<string>
      /**
       * ServicePort is the port of the service to serve HTTP01 challenge requests.
       */
      servicePort?: pulumi.Input<number | string>
      /**
       * URL is the URL that the HTTP01 challenge is expected to serve on.
       */
      url?: pulumi.Input<string>
    }

    /**
     * Spec is the desired state of the ClusterDomainClaim.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface ClusterDomainClaimSpecArgs {
      /**
       * Namespace is the namespace which is allowed to create a DomainMapping
       * using this ClusterDomainClaim's name.
       */
      namespace: pulumi.Input<string>
    }

    /**
     * Spec is the desired state of the Ingress.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface IngressSpecArgs {
      /**
       * HTTPOption is the option of HTTP. It has the following two values:
       * `HTTPOptionEnabled`, `HTTPOptionRedirected`
       */
      httpOption?: pulumi.Input<string>
      /**
       * A list of host rules used to configure the Ingress.
       */
      rules?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.IngressSpecRulesArgs>[]>
      /**
       * TLS configuration. Currently Ingress only supports a single TLS
       * port: 443. If multiple members of this list specify different hosts, they
       * will be multiplexed on the same port according to the hostname specified
       * through the SNI TLS extension, if the ingress controller fulfilling the
       * ingress supports SNI.
       */
      tls?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.IngressSpecTlsArgs>[]>
    }

    /**
     * IngressRule represents the rules mapping the paths under a specified host to
     * the related backend services. Incoming requests are first evaluated for a host
     * match, then routed to the backend associated with the matching IngressRuleValue.
     */
    export interface IngressSpecRulesArgs {
      /**
       * Host is the fully qualified domain name of a network host, as defined
       * by RFC 3986. Note the following deviations from the "host" part of the
       * URI as defined in the RFC:
       * 1. IPs are not allowed. Currently a rule value can only apply to the
       * 	  IP in the Spec of the parent .
       * 2. The `:` delimiter is not respected because ports are not allowed.
       * 	  Currently the port of an Ingress is implicitly :80 for http and
       * 	  :443 for https.
       * Both these may change in the future.
       * If the host is unspecified, the Ingress routes all traffic based on the
       * specified IngressRuleValue.
       * If multiple matching Hosts were provided, the first rule will take precedent.
       */
      hosts?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * HTTP represents a rule to apply against incoming requests. If the
       * rule is satisfied, the request is routed to the specified backend.
       */
      http?: pulumi.Input<inputs.networking.v1alpha1.IngressSpecRulesHttpArgs>
      /**
       * Visibility signifies whether this rule should `ClusterLocal`. If it's not
       * specified then it defaults to `ExternalIP`.
       */
      visibility?: pulumi.Input<string>
    }

    /**
     * HTTP represents a rule to apply against incoming requests. If the
     * rule is satisfied, the request is routed to the specified backend.
     */
    export interface IngressSpecRulesHttpArgs {
      /**
       * A collection of paths that map requests to backends.
       *
       *
       * If they are multiple matching paths, the first match takes precedence.
       */
      paths: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.IngressSpecRulesHttpPathsArgs>[]>
    }

    /**
     * HTTPIngressPath associates a path regex with a backend. Incoming URLs matching
     * the path are forwarded to the backend.
     */
    export interface IngressSpecRulesHttpPathsArgs {
      /**
       * AppendHeaders allow specifying additional HTTP headers to add
       * before forwarding a request to the destination service.
       *
       *
       * NOTE: This differs from K8s Ingress which doesn't allow header appending.
       */
      appendHeaders?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Headers defines header matching rules which is a map from a header name
       * to HeaderMatch which specify a matching condition.
       * When a request matched with all the header matching rules,
       * the request is routed by the corresponding ingress rule.
       * If it is empty, the headers are not used for matching
       */
      headers?: pulumi.Input<{
        [key: string]: pulumi.Input<inputs.networking.v1alpha1.IngressSpecRulesHttpPathsHeadersArgs>
      }>
      /**
       * Path represents a literal prefix to which this rule should apply.
       * Currently it can contain characters disallowed from the conventional
       * "path" part of a URL as defined by RFC 3986. Paths must begin with
       * a '/'. If unspecified, the path defaults to a catch all sending
       * traffic to the backend.
       */
      path?: pulumi.Input<string>
      /**
       * RewriteHost rewrites the incoming request's host header.
       *
       *
       * This field is currently experimental and not supported by all Ingress
       * implementations.
       */
      rewriteHost?: pulumi.Input<string>
      /**
       * Splits defines the referenced service endpoints to which the traffic
       * will be forwarded to.
       */
      splits: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.IngressSpecRulesHttpPathsSplitsArgs>[]>
    }

    /**
     * HeaderMatch represents a matching value of Headers in HTTPIngressPath.
     * Currently, only the exact matching is supported.
     */
    export interface IngressSpecRulesHttpPathsHeadersArgs {
      exact: pulumi.Input<string>
    }

    /**
     * IngressBackendSplit describes all endpoints for a given service and port.
     */
    export interface IngressSpecRulesHttpPathsSplitsArgs {
      /**
       * AppendHeaders allow specifying additional HTTP headers to add
       * before forwarding a request to the destination service.
       *
       *
       * NOTE: This differs from K8s Ingress which doesn't allow header appending.
       */
      appendHeaders?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Specifies the split percentage, a number between 0 and 100.  If
       * only one split is specified, we default to 100.
       *
       *
       * NOTE: This differs from K8s Ingress to allow percentage split.
       */
      percent?: pulumi.Input<number>
      /**
       * Specifies the name of the referenced service.
       */
      serviceName: pulumi.Input<string>
      /**
       * Specifies the namespace of the referenced service.
       *
       *
       * NOTE: This differs from K8s Ingress to allow routing to different namespaces.
       */
      serviceNamespace: pulumi.Input<string>
      /**
       * Specifies the port of the referenced service.
       */
      servicePort: pulumi.Input<number | string>
    }

    /**
     * IngressTLS describes the transport layer security associated with an Ingress.
     */
    export interface IngressSpecTlsArgs {
      /**
       * Hosts is a list of hosts included in the TLS certificate. The values in
       * this list must match the name/s used in the tlsSecret. Defaults to the
       * wildcard host setting for the loadbalancer controller fulfilling this
       * Ingress, if left unspecified.
       */
      hosts?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * SecretName is the name of the secret used to terminate SSL traffic.
       */
      secretName?: pulumi.Input<string>
      /**
       * SecretNamespace is the namespace of the secret used to terminate SSL traffic.
       * If not set the namespace should be assumed to be the same as the Ingress.
       * If set the secret should have the same namespace as the Ingress otherwise
       * the behaviour is undefined and not supported.
       */
      secretNamespace?: pulumi.Input<string>
    }

    /**
     * Status is the current state of the Ingress.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface IngressStatusArgs {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.IngressStatusConditionsArgs>[]>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
      /**
       * PrivateLoadBalancer contains the current status of the load-balancer.
       */
      privateLoadBalancer?: pulumi.Input<inputs.networking.v1alpha1.IngressStatusPrivateLoadBalancerArgs>
      /**
       * PublicLoadBalancer contains the current status of the load-balancer.
       */
      publicLoadBalancer?: pulumi.Input<inputs.networking.v1alpha1.IngressStatusPublicLoadBalancerArgs>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface IngressStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }

    /**
     * PrivateLoadBalancer contains the current status of the load-balancer.
     */
    export interface IngressStatusPrivateLoadBalancerArgs {
      /**
       * Ingress is a list containing ingress points for the load-balancer.
       * Traffic intended for the service should be sent to these ingress points.
       */
      ingress?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.IngressStatusPrivateLoadBalancerIngressArgs>[]>
    }

    /**
     * LoadBalancerIngressStatus represents the status of a load-balancer ingress point:
     * traffic intended for the service should be sent to an ingress point.
     */
    export interface IngressStatusPrivateLoadBalancerIngressArgs {
      /**
       * Domain is set for load-balancer ingress points that are DNS based
       * (typically AWS load-balancers)
       */
      domain?: pulumi.Input<string>
      /**
       * DomainInternal is set if there is a cluster-local DNS name to access the Ingress.
       *
       *
       * NOTE: This differs from K8s Ingress, since we also desire to have a cluster-local
       *       DNS name to allow routing in case of not having a mesh.
       */
      domainInternal?: pulumi.Input<string>
      /**
       * IP is set for load-balancer ingress points that are IP based
       * (typically GCE or OpenStack load-balancers)
       */
      ip?: pulumi.Input<string>
      /**
       * MeshOnly is set if the Ingress is only load-balanced through a Service mesh.
       */
      meshOnly?: pulumi.Input<boolean>
    }

    /**
     * PublicLoadBalancer contains the current status of the load-balancer.
     */
    export interface IngressStatusPublicLoadBalancerArgs {
      /**
       * Ingress is a list containing ingress points for the load-balancer.
       * Traffic intended for the service should be sent to these ingress points.
       */
      ingress?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.IngressStatusPublicLoadBalancerIngressArgs>[]>
    }

    /**
     * LoadBalancerIngressStatus represents the status of a load-balancer ingress point:
     * traffic intended for the service should be sent to an ingress point.
     */
    export interface IngressStatusPublicLoadBalancerIngressArgs {
      /**
       * Domain is set for load-balancer ingress points that are DNS based
       * (typically AWS load-balancers)
       */
      domain?: pulumi.Input<string>
      /**
       * DomainInternal is set if there is a cluster-local DNS name to access the Ingress.
       *
       *
       * NOTE: This differs from K8s Ingress, since we also desire to have a cluster-local
       *       DNS name to allow routing in case of not having a mesh.
       */
      domainInternal?: pulumi.Input<string>
      /**
       * IP is set for load-balancer ingress points that are IP based
       * (typically GCE or OpenStack load-balancers)
       */
      ip?: pulumi.Input<string>
      /**
       * MeshOnly is set if the Ingress is only load-balanced through a Service mesh.
       */
      meshOnly?: pulumi.Input<boolean>
    }

    /**
     * Spec is the desired state of the ServerlessService.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface ServerlessServiceSpecArgs {
      /**
       * Mode describes the mode of operation of the ServerlessService.
       */
      mode?: pulumi.Input<string>
      /**
       * NumActivators contains number of Activators that this revision should be
       * assigned.
       * O means â€” assign all.
       */
      numActivators?: pulumi.Input<number>
      /**
       * ObjectRef defines the resource that this ServerlessService
       * is responsible for making "serverless".
       */
      objectRef: pulumi.Input<inputs.networking.v1alpha1.ServerlessServiceSpecObjectRefArgs>
      /**
       * The application-layer protocol. Matches `RevisionProtocolType` set on the owning pa/revision.
       * serving imports networking, so just use string.
       */
      protocolType: pulumi.Input<string>
    }

    /**
     * ObjectRef defines the resource that this ServerlessService
     * is responsible for making "serverless".
     */
    export interface ServerlessServiceSpecObjectRefArgs {
      /**
       * API version of the referent.
       */
      apiVersion?: pulumi.Input<string>
      /**
       * If referring to a piece of an object instead of an entire object, this string
       * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
       * For example, if the object reference is to a container within a pod, this would take on a value like:
       * "spec.containers{name}" (where "name" refers to the name of the container that triggered
       * the event) or if no container name is specified "spec.containers[2]" (container with
       * index 2 in this pod). This syntax is chosen only to have some well-defined way of
       * referencing a part of an object.
       * TODO: this design is not final and this field is subject to change in the future.
       */
      fieldPath?: pulumi.Input<string>
      /**
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      kind?: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name?: pulumi.Input<string>
      /**
       * Namespace of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
       */
      namespace?: pulumi.Input<string>
      /**
       * Specific resourceVersion to which this reference is made, if any.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       */
      resourceVersion?: pulumi.Input<string>
      /**
       * UID of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
       */
      uid?: pulumi.Input<string>
    }

    /**
     * Status is the current state of the ServerlessService.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface ServerlessServiceStatusArgs {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.networking.v1alpha1.ServerlessServiceStatusConditionsArgs>[]>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
      /**
       * PrivateServiceName holds the name of a core K8s Service resource that
       * load balances over the user service pods backing this Revision.
       */
      privateServiceName?: pulumi.Input<string>
      /**
       * ServiceName holds the name of a core K8s Service resource that
       * load balances over the pods backing this Revision (activator or revision).
       */
      serviceName?: pulumi.Input<string>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface ServerlessServiceStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }
  }
}

export namespace serving {
  export namespace v1 {
    /**
     * ConfigurationSpec holds the desired state of the Configuration (from the client).
     */
    export interface ConfigurationSpecArgs {
      /**
       * Template holds the latest specification for the Revision to be stamped out.
       */
      template?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateArgs>
    }

    /**
     * Template holds the latest specification for the Revision to be stamped out.
     */
    export interface ConfigurationSpecTemplateArgs {
      metadata?: pulumi.Input<{ [key: string]: any }>
      /**
       * RevisionSpec holds the desired state of the Revision (from the client).
       */
      spec?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecArgs>
    }

    /**
     * RevisionSpec holds the desired state of the Revision (from the client).
     */
    export interface ConfigurationSpecTemplateSpecArgs {
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-affinity
       */
      affinity?: pulumi.Input<{ [key: string]: any }>
      /**
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       */
      automountServiceAccountToken?: pulumi.Input<boolean>
      /**
       * ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
       * requests per container of the Revision.  Defaults to `0` which means
       * concurrency to the application is not limited, and the system decides the
       * target concurrency for the autoscaler.
       */
      containerConcurrency?: pulumi.Input<number>
      /**
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       */
      containers: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersArgs>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
       */
      dnsConfig?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
       */
      dnsPolicy?: pulumi.Input<string>
      /**
       * EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
       */
      enableServiceLinks?: pulumi.Input<boolean>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-hostaliases
       */
      hostAliases?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
       * to stay open while not receiving any bytes from the user's application. If
       * unspecified, a system default will be provided.
       */
      idleTimeoutSeconds?: pulumi.Input<number>
      /**
       * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
       */
      imagePullSecrets?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecImagePullSecretsArgs>[]
      >
      /**
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       */
      initContainers?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-nodeselector
       */
      nodeSelector?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
       */
      priorityClassName?: pulumi.Input<{ [key: string]: any }>
      /**
       * ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
       * routing layer will wait for a request delivered to a container to begin
       * sending any network traffic.
       */
      responseStartTimeoutSeconds?: pulumi.Input<number>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
       */
      runtimeClassName?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-schedulername
       */
      schedulerName?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-securitycontext
       */
      securityContext?: pulumi.Input<{ [key: string]: any }>
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       */
      serviceAccountName?: pulumi.Input<string>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-shareproccessnamespace
       */
      shareProcessNamespace?: pulumi.Input<{ [key: string]: any }>
      /**
       * TimeoutSeconds is the maximum duration in seconds that the request instance
       * is allowed to respond to a request. If unspecified, a system default will
       * be provided.
       */
      timeoutSeconds?: pulumi.Input<number>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-tolerations
       */
      tolerations?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
       */
      topologySpreadConstraints?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       */
      volumes?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesArgs>[]>
    }

    /**
     * A single application container that you want to run within a pod.
     */
    export interface ConfigurationSpecTemplateSpecContainersArgs {
      /**
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      args?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * List of environment variables to set in the container.
       * Cannot be updated.
       */
      env?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvArgs>[]>
      /**
       * List of sources to populate environment variables in the container.
       * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       * will be reported as an event when the container is starting. When a key exists in multiple
       * sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence.
       * Cannot be updated.
       */
      envFrom?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvFromArgs>[]>
      /**
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       */
      image?: pulumi.Input<string>
      /**
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       */
      imagePullPolicy?: pulumi.Input<string>
      /**
       * Periodic probe of container liveness.
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      livenessProbe?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeArgs>
      /**
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       */
      name?: pulumi.Input<string>
      /**
       * List of ports to expose from the container. Not specifying a port here
       * DOES NOT prevent that port from being exposed. Any port which is
       * listening on the default "0.0.0.0" address inside a container will be
       * accessible from the network.
       * Modifying this array with strategic merge patch may corrupt the data.
       * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
       * Cannot be updated.
       */
      ports?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersPortsArgs>[]>
      /**
       * Periodic probe of container service readiness.
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      readinessProbe?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeArgs>
      /**
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      resources?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersResourcesArgs>
      /**
       * SecurityContext defines the security options the container should be run with.
       * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       */
      securityContext?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersSecurityContextArgs>
      /**
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       */
      terminationMessagePath?: pulumi.Input<string>
      /**
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       */
      terminationMessagePolicy?: pulumi.Input<string>
      /**
       * Pod volumes to mount into the container's filesystem.
       * Cannot be updated.
       */
      volumeMounts?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersVolumeMountsArgs>[]
      >
      /**
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: pulumi.Input<string>
    }

    /**
     * EnvVar represents an environment variable present in a Container.
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvArgs {
      /**
       * Name of the environment variable. Must be a C_IDENTIFIER.
       */
      name: pulumi.Input<string>
      /**
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       */
      value?: pulumi.Input<string>
      /**
       * Source for the environment variable's value. Cannot be used if value is not empty.
       */
      valueFrom?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvValueFromArgs>
    }

    /**
     * EnvFromSource represents the source of a set of ConfigMaps
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvFromArgs {
      /**
       * The ConfigMap to select from
       */
      configMapRef?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvFromConfigMapRefArgs>
      /**
       * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
       */
      prefix?: pulumi.Input<string>
      /**
       * The Secret to select from
       */
      secretRef?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvFromSecretRefArgs>
    }

    /**
     * The ConfigMap to select from
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvFromConfigMapRefArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * The Secret to select from
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvFromSecretRefArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the Secret must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Source for the environment variable's value. Cannot be used if value is not empty.
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvValueFromArgs {
      /**
       * Selects a key of a ConfigMap.
       */
      configMapKeyRef?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvValueFromConfigMapKeyRefArgs>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      fieldRef?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      resourceFieldRef?: pulumi.Input<{ [key: string]: any }>
      /**
       * Selects a key of a secret in the pod's namespace
       */
      secretKeyRef?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersEnvValueFromSecretKeyRefArgs>
    }

    /**
     * Selects a key of a ConfigMap.
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvValueFromConfigMapKeyRefArgs {
      /**
       * The key to select.
       */
      key: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the ConfigMap or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Selects a key of a secret in the pod's namespace
     */
    export interface ConfigurationSpecTemplateSpecContainersEnvValueFromSecretKeyRefArgs {
      /**
       * The key of the secret to select from.  Must be a valid secret key.
       */
      key: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the Secret or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Periodic probe of container liveness.
     * Container will be restarted if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeArgs {
      /**
       * Exec specifies the action to take.
       */
      exec?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeExecArgs>
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: pulumi.Input<number>
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeGrpcArgs>
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeHttpGetArgs>
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: pulumi.Input<number>
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: pulumi.Input<number>
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: pulumi.Input<number>
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeTcpSocketArgs>
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: pulumi.Input<number>
    }

    /**
     * Exec specifies the action to take.
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeExecArgs {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeGrpcArgs {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: pulumi.Input<number>
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: pulumi.Input<string>
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeHttpGetArgs {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: pulumi.Input<string>
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersArgs>[]
      >
      /**
       * Path to access on the HTTP server.
       */
      path?: pulumi.Input<string>
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: pulumi.Input<string>
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersArgs {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: pulumi.Input<string>
      /**
       * The header field value
       */
      value: pulumi.Input<string>
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface ConfigurationSpecTemplateSpecContainersLivenessProbeTcpSocketArgs {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: pulumi.Input<string>
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
    }

    /**
     * ContainerPort represents a network port in a single container.
     */
    export interface ConfigurationSpecTemplateSpecContainersPortsArgs {
      /**
       * Number of port to expose on the pod's IP address.
       * This must be a valid port number, 0 < x < 65536.
       */
      containerPort: pulumi.Input<number>
      /**
       * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
       * named port in a pod must have a unique name. Name for the port that can be
       * referred to by services.
       */
      name?: pulumi.Input<string>
      /**
       * Protocol for port. Must be UDP, TCP, or SCTP.
       * Defaults to "TCP".
       */
      protocol?: pulumi.Input<string>
    }
    /**
     * configurationSpecTemplateSpecContainersPortsArgsProvideDefaults sets the appropriate defaults for ConfigurationSpecTemplateSpecContainersPortsArgs
     */
    export function configurationSpecTemplateSpecContainersPortsArgsProvideDefaults(
      val: ConfigurationSpecTemplateSpecContainersPortsArgs,
    ): ConfigurationSpecTemplateSpecContainersPortsArgs {
      return {
        ...val,
        protocol: val.protocol ?? "TCP",
      }
    }

    /**
     * Periodic probe of container service readiness.
     * Container will be removed from service endpoints if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeArgs {
      /**
       * Exec specifies the action to take.
       */
      exec?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeExecArgs>
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: pulumi.Input<number>
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeGrpcArgs>
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeHttpGetArgs>
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: pulumi.Input<number>
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: pulumi.Input<number>
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: pulumi.Input<number>
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeTcpSocketArgs>
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: pulumi.Input<number>
    }

    /**
     * Exec specifies the action to take.
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeExecArgs {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeGrpcArgs {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: pulumi.Input<number>
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: pulumi.Input<string>
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeHttpGetArgs {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: pulumi.Input<string>
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeadersArgs>[]
      >
      /**
       * Path to access on the HTTP server.
       */
      path?: pulumi.Input<string>
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: pulumi.Input<string>
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeadersArgs {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: pulumi.Input<string>
      /**
       * The header field value
       */
      value: pulumi.Input<string>
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface ConfigurationSpecTemplateSpecContainersReadinessProbeTcpSocketArgs {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: pulumi.Input<string>
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
    }

    /**
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     */
    export interface ConfigurationSpecTemplateSpecContainersResourcesArgs {
      /**
       * Claims lists the names of resources, defined in spec.resourceClaims,
       * that are used by this container.
       *
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       *
       * This field is immutable. It can only be set for containers.
       */
      claims?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersResourcesClaimsArgs>[]
      >
      /**
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      limits?: pulumi.Input<{ [key: string]: pulumi.Input<number | string> }>
      /**
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      requests?: pulumi.Input<{ [key: string]: pulumi.Input<number | string> }>
    }

    /**
     * ResourceClaim references one entry in PodSpec.ResourceClaims.
     */
    export interface ConfigurationSpecTemplateSpecContainersResourcesClaimsArgs {
      /**
       * Name must match the name of one entry in pod.spec.resourceClaims of
       * the Pod where this field is used. It makes that resource available
       * inside a container.
       */
      name: pulumi.Input<string>
    }

    /**
     * SecurityContext defines the security options the container should be run with.
     * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     */
    export interface ConfigurationSpecTemplateSpecContainersSecurityContextArgs {
      /**
       * AllowPrivilegeEscalation controls whether a process can gain more
       * privileges than its parent process. This bool directly controls if
       * the no_new_privs flag will be set on the container process.
       * AllowPrivilegeEscalation is true always when the container is:
       * 1) run as Privileged
       * 2) has CAP_SYS_ADMIN
       * Note that this field cannot be set when spec.os.name is windows.
       */
      allowPrivilegeEscalation?: pulumi.Input<boolean>
      /**
       * The capabilities to add/drop when running containers.
       * Defaults to the default set of capabilities granted by the container runtime.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      capabilities?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersSecurityContextCapabilitiesArgs>
      /**
       * Whether this container has a read-only root filesystem.
       * Default is false.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      readOnlyRootFilesystem?: pulumi.Input<boolean>
      /**
       * The GID to run the entrypoint of the container process.
       * Uses runtime default if unset.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsGroup?: pulumi.Input<number>
      /**
       * Indicates that the container must run as a non-root user.
       * If true, the Kubelet will validate the image at runtime to ensure that it
       * does not run as UID 0 (root) and fail to start the container if it does.
       * If unset or false, no such validation will be performed.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: pulumi.Input<boolean>
      /**
       * The UID to run the entrypoint of the container process.
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsUser?: pulumi.Input<number>
      /**
       * The seccomp options to use by this container. If seccomp options are
       * provided at both the pod & container level, the container options
       * override the pod options.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      seccompProfile?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecContainersSecurityContextSeccompProfileArgs>
    }

    /**
     * The capabilities to add/drop when running containers.
     * Defaults to the default set of capabilities granted by the container runtime.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface ConfigurationSpecTemplateSpecContainersSecurityContextCapabilitiesArgs {
      /**
       * This is accessible behind a feature flag - kubernetes.containerspec-addcapabilities
       */
      add?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * Removed capabilities
       */
      drop?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * The seccomp options to use by this container. If seccomp options are
     * provided at both the pod & container level, the container options
     * override the pod options.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface ConfigurationSpecTemplateSpecContainersSecurityContextSeccompProfileArgs {
      /**
       * localhostProfile indicates a profile defined in a file on the node should be used.
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must be set if type is "Localhost". Must NOT be set for any other type.
       */
      localhostProfile?: pulumi.Input<string>
      /**
       * type indicates which kind of seccomp profile will be applied.
       * Valid options are:
       *
       *
       * Localhost - a profile defined in a file on the node should be used.
       * RuntimeDefault - the container runtime default profile should be used.
       * Unconfined - no profile should be applied.
       */
      type: pulumi.Input<string>
    }

    /**
     * VolumeMount describes a mounting of a Volume within a container.
     */
    export interface ConfigurationSpecTemplateSpecContainersVolumeMountsArgs {
      /**
       * Path within the container at which the volume should be mounted.  Must
       * not contain ':'.
       */
      mountPath: pulumi.Input<string>
      /**
       * This must match the Name of a Volume.
       */
      name: pulumi.Input<string>
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       * Defaults to false.
       */
      readOnly?: pulumi.Input<boolean>
      /**
       * Path within the volume from which the container's volume should be mounted.
       * Defaults to "" (volume's root).
       */
      subPath?: pulumi.Input<string>
    }

    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface ConfigurationSpecTemplateSpecImagePullSecretsArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
    }

    /**
     * Volume represents a named volume in a pod that may be accessed by any container in the pod.
     */
    export interface ConfigurationSpecTemplateSpecVolumesArgs {
      /**
       * configMap represents a configMap that should populate this volume
       */
      configMap?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesConfigMapArgs>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-emptydir
       */
      emptyDir?: pulumi.Input<{ [key: string]: any }>
      /**
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name: pulumi.Input<string>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-persistent-volume-claim
       */
      persistentVolumeClaim?: pulumi.Input<{ [key: string]: any }>
      /**
       * projected items for all in one resources secrets, configmaps, and downward API
       */
      projected?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedArgs>
      /**
       * secret represents a secret that should populate this volume.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secret?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesSecretArgs>
    }

    /**
     * configMap represents a configMap that should populate this volume
     */
    export interface ConfigurationSpecTemplateSpecVolumesConfigMapArgs {
      /**
       * defaultMode is optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesConfigMapItemsArgs>[]>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ConfigurationSpecTemplateSpecVolumesConfigMapItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * projected items for all in one resources secrets, configmaps, and downward API
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedArgs {
      /**
       * defaultMode are the mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * sources is the list of volume projections
       */
      sources?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesArgs>[]>
    }

    /**
     * Projection that may be projected along with other supported volume types
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesArgs {
      /**
       * configMap information about the configMap data to project
       */
      configMap?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesConfigMapArgs>
      /**
       * downwardAPI information about the downwardAPI data to project
       */
      downwardAPI?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiArgs>
      /**
       * secret information about the secret data to project
       */
      secret?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesSecretArgs>
      /**
       * serviceAccountToken is information about the serviceAccountToken data to project
       */
      serviceAccountToken?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesServiceAccountTokenArgs>
    }

    /**
     * configMap information about the configMap data to project
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesConfigMapArgs {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesConfigMapItemsArgs>[]
      >
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesConfigMapItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * downwardAPI information about the downwardAPI data to project
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiArgs {
      /**
       * Items is a list of DownwardAPIVolume file
       */
      items?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsArgs>[]
      >
    }

    /**
     * DownwardAPIVolumeFile represents information to create the file containing the pod field
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsArgs {
      /**
       * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
       */
      fieldRef?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRefArgs>
      /**
       * Optional: mode bits used to set permissions on this file, must be an octal value
       * between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
       */
      path: pulumi.Input<string>
      /**
       * Selects a resource of the container: only resources limits and requests
       * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
       */
      resourceFieldRef?: pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefArgs>
    }

    /**
     * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRefArgs {
      /**
       * Version of the schema the FieldPath is written in terms of, defaults to "v1".
       */
      apiVersion?: pulumi.Input<string>
      /**
       * Path of the field to select in the specified API version.
       */
      fieldPath: pulumi.Input<string>
    }

    /**
     * Selects a resource of the container: only resources limits and requests
     * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefArgs {
      /**
       * Container name: required for volumes, optional for env vars
       */
      containerName?: pulumi.Input<string>
      /**
       * Specifies the output format of the exposed resources, defaults to "1"
       */
      divisor?: pulumi.Input<number | string>
      /**
       * Required: resource to select
       */
      resource: pulumi.Input<string>
    }

    /**
     * secret information about the secret data to project
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesSecretArgs {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesProjectedSourcesSecretItemsArgs>[]
      >
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional field specify whether the Secret or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesSecretItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * serviceAccountToken is information about the serviceAccountToken data to project
     */
    export interface ConfigurationSpecTemplateSpecVolumesProjectedSourcesServiceAccountTokenArgs {
      /**
       * audience is the intended audience of the token. A recipient of a token
       * must identify itself with an identifier specified in the audience of the
       * token, and otherwise should reject the token. The audience defaults to the
       * identifier of the apiserver.
       */
      audience?: pulumi.Input<string>
      /**
       * expirationSeconds is the requested duration of validity of the service
       * account token. As the token approaches expiration, the kubelet volume
       * plugin will proactively rotate the service account token. The kubelet will
       * start trying to rotate the token if the token is older than 80 percent of
       * its time to live or if the token is older than 24 hours.Defaults to 1 hour
       * and must be at least 10 minutes.
       */
      expirationSeconds?: pulumi.Input<number>
      /**
       * path is the path relative to the mount point of the file to project the
       * token into.
       */
      path: pulumi.Input<string>
    }

    /**
     * secret represents a secret that should populate this volume.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    export interface ConfigurationSpecTemplateSpecVolumesSecretArgs {
      /**
       * defaultMode is Optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values
       * for mode bits. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * items If unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationSpecTemplateSpecVolumesSecretItemsArgs>[]>
      /**
       * optional field specify whether the Secret or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
      /**
       * secretName is the name of the secret in the pod's namespace to use.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secretName?: pulumi.Input<string>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ConfigurationSpecTemplateSpecVolumesSecretItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * ConfigurationStatus communicates the observed state of the Configuration (from the controller).
     */
    export interface ConfigurationStatusArgs {
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1.ConfigurationStatusConditionsArgs>[]>
      /**
       * LatestCreatedRevisionName is the last revision that was created from this
       * Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
       */
      latestCreatedRevisionName?: pulumi.Input<string>
      /**
       * LatestReadyRevisionName holds the name of the latest Revision stamped out
       * from this Configuration that has had its "Ready" condition become "True".
       */
      latestReadyRevisionName?: pulumi.Input<string>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface ConfigurationStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }

    /**
     * RevisionSpec holds the desired state of the Revision (from the client).
     */
    export interface RevisionSpecArgs {
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-affinity
       */
      affinity?: pulumi.Input<{ [key: string]: any }>
      /**
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       */
      automountServiceAccountToken?: pulumi.Input<boolean>
      /**
       * ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
       * requests per container of the Revision.  Defaults to `0` which means
       * concurrency to the application is not limited, and the system decides the
       * target concurrency for the autoscaler.
       */
      containerConcurrency?: pulumi.Input<number>
      /**
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       */
      containers: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecContainersArgs>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
       */
      dnsConfig?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
       */
      dnsPolicy?: pulumi.Input<string>
      /**
       * EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
       */
      enableServiceLinks?: pulumi.Input<boolean>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-hostaliases
       */
      hostAliases?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
       * to stay open while not receiving any bytes from the user's application. If
       * unspecified, a system default will be provided.
       */
      idleTimeoutSeconds?: pulumi.Input<number>
      /**
       * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
       */
      imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecImagePullSecretsArgs>[]>
      /**
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       */
      initContainers?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-nodeselector
       */
      nodeSelector?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
       */
      priorityClassName?: pulumi.Input<{ [key: string]: any }>
      /**
       * ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
       * routing layer will wait for a request delivered to a container to begin
       * sending any network traffic.
       */
      responseStartTimeoutSeconds?: pulumi.Input<number>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
       */
      runtimeClassName?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-schedulername
       */
      schedulerName?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-securitycontext
       */
      securityContext?: pulumi.Input<{ [key: string]: any }>
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       */
      serviceAccountName?: pulumi.Input<string>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-shareproccessnamespace
       */
      shareProcessNamespace?: pulumi.Input<{ [key: string]: any }>
      /**
       * TimeoutSeconds is the maximum duration in seconds that the request instance
       * is allowed to respond to a request. If unspecified, a system default will
       * be provided.
       */
      timeoutSeconds?: pulumi.Input<number>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-tolerations
       */
      tolerations?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
       */
      topologySpreadConstraints?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       */
      volumes?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecVolumesArgs>[]>
    }

    /**
     * A single application container that you want to run within a pod.
     */
    export interface RevisionSpecContainersArgs {
      /**
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      args?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * List of environment variables to set in the container.
       * Cannot be updated.
       */
      env?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecContainersEnvArgs>[]>
      /**
       * List of sources to populate environment variables in the container.
       * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       * will be reported as an event when the container is starting. When a key exists in multiple
       * sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence.
       * Cannot be updated.
       */
      envFrom?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecContainersEnvFromArgs>[]>
      /**
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       */
      image?: pulumi.Input<string>
      /**
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       */
      imagePullPolicy?: pulumi.Input<string>
      /**
       * Periodic probe of container liveness.
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      livenessProbe?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersLivenessProbeArgs>
      /**
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       */
      name?: pulumi.Input<string>
      /**
       * List of ports to expose from the container. Not specifying a port here
       * DOES NOT prevent that port from being exposed. Any port which is
       * listening on the default "0.0.0.0" address inside a container will be
       * accessible from the network.
       * Modifying this array with strategic merge patch may corrupt the data.
       * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
       * Cannot be updated.
       */
      ports?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecContainersPortsArgs>[]>
      /**
       * Periodic probe of container service readiness.
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      readinessProbe?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersReadinessProbeArgs>
      /**
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      resources?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersResourcesArgs>
      /**
       * SecurityContext defines the security options the container should be run with.
       * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       */
      securityContext?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersSecurityContextArgs>
      /**
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       */
      terminationMessagePath?: pulumi.Input<string>
      /**
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       */
      terminationMessagePolicy?: pulumi.Input<string>
      /**
       * Pod volumes to mount into the container's filesystem.
       * Cannot be updated.
       */
      volumeMounts?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecContainersVolumeMountsArgs>[]>
      /**
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: pulumi.Input<string>
    }

    /**
     * EnvVar represents an environment variable present in a Container.
     */
    export interface RevisionSpecContainersEnvArgs {
      /**
       * Name of the environment variable. Must be a C_IDENTIFIER.
       */
      name: pulumi.Input<string>
      /**
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       */
      value?: pulumi.Input<string>
      /**
       * Source for the environment variable's value. Cannot be used if value is not empty.
       */
      valueFrom?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersEnvValueFromArgs>
    }

    /**
     * EnvFromSource represents the source of a set of ConfigMaps
     */
    export interface RevisionSpecContainersEnvFromArgs {
      /**
       * The ConfigMap to select from
       */
      configMapRef?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersEnvFromConfigMapRefArgs>
      /**
       * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
       */
      prefix?: pulumi.Input<string>
      /**
       * The Secret to select from
       */
      secretRef?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersEnvFromSecretRefArgs>
    }

    /**
     * The ConfigMap to select from
     */
    export interface RevisionSpecContainersEnvFromConfigMapRefArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * The Secret to select from
     */
    export interface RevisionSpecContainersEnvFromSecretRefArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the Secret must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Source for the environment variable's value. Cannot be used if value is not empty.
     */
    export interface RevisionSpecContainersEnvValueFromArgs {
      /**
       * Selects a key of a ConfigMap.
       */
      configMapKeyRef?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersEnvValueFromConfigMapKeyRefArgs>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      fieldRef?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      resourceFieldRef?: pulumi.Input<{ [key: string]: any }>
      /**
       * Selects a key of a secret in the pod's namespace
       */
      secretKeyRef?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersEnvValueFromSecretKeyRefArgs>
    }

    /**
     * Selects a key of a ConfigMap.
     */
    export interface RevisionSpecContainersEnvValueFromConfigMapKeyRefArgs {
      /**
       * The key to select.
       */
      key: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the ConfigMap or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Selects a key of a secret in the pod's namespace
     */
    export interface RevisionSpecContainersEnvValueFromSecretKeyRefArgs {
      /**
       * The key of the secret to select from.  Must be a valid secret key.
       */
      key: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the Secret or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Periodic probe of container liveness.
     * Container will be restarted if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface RevisionSpecContainersLivenessProbeArgs {
      /**
       * Exec specifies the action to take.
       */
      exec?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersLivenessProbeExecArgs>
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: pulumi.Input<number>
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersLivenessProbeGrpcArgs>
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersLivenessProbeHttpGetArgs>
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: pulumi.Input<number>
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: pulumi.Input<number>
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: pulumi.Input<number>
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersLivenessProbeTcpSocketArgs>
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: pulumi.Input<number>
    }

    /**
     * Exec specifies the action to take.
     */
    export interface RevisionSpecContainersLivenessProbeExecArgs {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface RevisionSpecContainersLivenessProbeGrpcArgs {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: pulumi.Input<number>
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: pulumi.Input<string>
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface RevisionSpecContainersLivenessProbeHttpGetArgs {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: pulumi.Input<string>
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.RevisionSpecContainersLivenessProbeHttpGetHttpHeadersArgs>[]
      >
      /**
       * Path to access on the HTTP server.
       */
      path?: pulumi.Input<string>
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: pulumi.Input<string>
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface RevisionSpecContainersLivenessProbeHttpGetHttpHeadersArgs {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: pulumi.Input<string>
      /**
       * The header field value
       */
      value: pulumi.Input<string>
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface RevisionSpecContainersLivenessProbeTcpSocketArgs {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: pulumi.Input<string>
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
    }

    /**
     * ContainerPort represents a network port in a single container.
     */
    export interface RevisionSpecContainersPortsArgs {
      /**
       * Number of port to expose on the pod's IP address.
       * This must be a valid port number, 0 < x < 65536.
       */
      containerPort: pulumi.Input<number>
      /**
       * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
       * named port in a pod must have a unique name. Name for the port that can be
       * referred to by services.
       */
      name?: pulumi.Input<string>
      /**
       * Protocol for port. Must be UDP, TCP, or SCTP.
       * Defaults to "TCP".
       */
      protocol?: pulumi.Input<string>
    }
    /**
     * revisionSpecContainersPortsArgsProvideDefaults sets the appropriate defaults for RevisionSpecContainersPortsArgs
     */
    export function revisionSpecContainersPortsArgsProvideDefaults(
      val: RevisionSpecContainersPortsArgs,
    ): RevisionSpecContainersPortsArgs {
      return {
        ...val,
        protocol: val.protocol ?? "TCP",
      }
    }

    /**
     * Periodic probe of container service readiness.
     * Container will be removed from service endpoints if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface RevisionSpecContainersReadinessProbeArgs {
      /**
       * Exec specifies the action to take.
       */
      exec?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersReadinessProbeExecArgs>
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: pulumi.Input<number>
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersReadinessProbeGrpcArgs>
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersReadinessProbeHttpGetArgs>
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: pulumi.Input<number>
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: pulumi.Input<number>
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: pulumi.Input<number>
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersReadinessProbeTcpSocketArgs>
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: pulumi.Input<number>
    }

    /**
     * Exec specifies the action to take.
     */
    export interface RevisionSpecContainersReadinessProbeExecArgs {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface RevisionSpecContainersReadinessProbeGrpcArgs {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: pulumi.Input<number>
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: pulumi.Input<string>
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface RevisionSpecContainersReadinessProbeHttpGetArgs {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: pulumi.Input<string>
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.RevisionSpecContainersReadinessProbeHttpGetHttpHeadersArgs>[]
      >
      /**
       * Path to access on the HTTP server.
       */
      path?: pulumi.Input<string>
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: pulumi.Input<string>
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface RevisionSpecContainersReadinessProbeHttpGetHttpHeadersArgs {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: pulumi.Input<string>
      /**
       * The header field value
       */
      value: pulumi.Input<string>
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface RevisionSpecContainersReadinessProbeTcpSocketArgs {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: pulumi.Input<string>
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
    }

    /**
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     */
    export interface RevisionSpecContainersResourcesArgs {
      /**
       * Claims lists the names of resources, defined in spec.resourceClaims,
       * that are used by this container.
       *
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       *
       * This field is immutable. It can only be set for containers.
       */
      claims?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecContainersResourcesClaimsArgs>[]>
      /**
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      limits?: pulumi.Input<{ [key: string]: pulumi.Input<number | string> }>
      /**
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      requests?: pulumi.Input<{ [key: string]: pulumi.Input<number | string> }>
    }

    /**
     * ResourceClaim references one entry in PodSpec.ResourceClaims.
     */
    export interface RevisionSpecContainersResourcesClaimsArgs {
      /**
       * Name must match the name of one entry in pod.spec.resourceClaims of
       * the Pod where this field is used. It makes that resource available
       * inside a container.
       */
      name: pulumi.Input<string>
    }

    /**
     * SecurityContext defines the security options the container should be run with.
     * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     */
    export interface RevisionSpecContainersSecurityContextArgs {
      /**
       * AllowPrivilegeEscalation controls whether a process can gain more
       * privileges than its parent process. This bool directly controls if
       * the no_new_privs flag will be set on the container process.
       * AllowPrivilegeEscalation is true always when the container is:
       * 1) run as Privileged
       * 2) has CAP_SYS_ADMIN
       * Note that this field cannot be set when spec.os.name is windows.
       */
      allowPrivilegeEscalation?: pulumi.Input<boolean>
      /**
       * The capabilities to add/drop when running containers.
       * Defaults to the default set of capabilities granted by the container runtime.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      capabilities?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersSecurityContextCapabilitiesArgs>
      /**
       * Whether this container has a read-only root filesystem.
       * Default is false.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      readOnlyRootFilesystem?: pulumi.Input<boolean>
      /**
       * The GID to run the entrypoint of the container process.
       * Uses runtime default if unset.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsGroup?: pulumi.Input<number>
      /**
       * Indicates that the container must run as a non-root user.
       * If true, the Kubelet will validate the image at runtime to ensure that it
       * does not run as UID 0 (root) and fail to start the container if it does.
       * If unset or false, no such validation will be performed.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: pulumi.Input<boolean>
      /**
       * The UID to run the entrypoint of the container process.
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsUser?: pulumi.Input<number>
      /**
       * The seccomp options to use by this container. If seccomp options are
       * provided at both the pod & container level, the container options
       * override the pod options.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      seccompProfile?: pulumi.Input<inputs.serving.v1.RevisionSpecContainersSecurityContextSeccompProfileArgs>
    }

    /**
     * The capabilities to add/drop when running containers.
     * Defaults to the default set of capabilities granted by the container runtime.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface RevisionSpecContainersSecurityContextCapabilitiesArgs {
      /**
       * This is accessible behind a feature flag - kubernetes.containerspec-addcapabilities
       */
      add?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * Removed capabilities
       */
      drop?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * The seccomp options to use by this container. If seccomp options are
     * provided at both the pod & container level, the container options
     * override the pod options.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface RevisionSpecContainersSecurityContextSeccompProfileArgs {
      /**
       * localhostProfile indicates a profile defined in a file on the node should be used.
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must be set if type is "Localhost". Must NOT be set for any other type.
       */
      localhostProfile?: pulumi.Input<string>
      /**
       * type indicates which kind of seccomp profile will be applied.
       * Valid options are:
       *
       *
       * Localhost - a profile defined in a file on the node should be used.
       * RuntimeDefault - the container runtime default profile should be used.
       * Unconfined - no profile should be applied.
       */
      type: pulumi.Input<string>
    }

    /**
     * VolumeMount describes a mounting of a Volume within a container.
     */
    export interface RevisionSpecContainersVolumeMountsArgs {
      /**
       * Path within the container at which the volume should be mounted.  Must
       * not contain ':'.
       */
      mountPath: pulumi.Input<string>
      /**
       * This must match the Name of a Volume.
       */
      name: pulumi.Input<string>
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       * Defaults to false.
       */
      readOnly?: pulumi.Input<boolean>
      /**
       * Path within the volume from which the container's volume should be mounted.
       * Defaults to "" (volume's root).
       */
      subPath?: pulumi.Input<string>
    }

    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface RevisionSpecImagePullSecretsArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
    }

    /**
     * Volume represents a named volume in a pod that may be accessed by any container in the pod.
     */
    export interface RevisionSpecVolumesArgs {
      /**
       * configMap represents a configMap that should populate this volume
       */
      configMap?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesConfigMapArgs>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-emptydir
       */
      emptyDir?: pulumi.Input<{ [key: string]: any }>
      /**
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name: pulumi.Input<string>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-persistent-volume-claim
       */
      persistentVolumeClaim?: pulumi.Input<{ [key: string]: any }>
      /**
       * projected items for all in one resources secrets, configmaps, and downward API
       */
      projected?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedArgs>
      /**
       * secret represents a secret that should populate this volume.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secret?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesSecretArgs>
    }

    /**
     * configMap represents a configMap that should populate this volume
     */
    export interface RevisionSpecVolumesConfigMapArgs {
      /**
       * defaultMode is optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecVolumesConfigMapItemsArgs>[]>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface RevisionSpecVolumesConfigMapItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * projected items for all in one resources secrets, configmaps, and downward API
     */
    export interface RevisionSpecVolumesProjectedArgs {
      /**
       * defaultMode are the mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * sources is the list of volume projections
       */
      sources?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesArgs>[]>
    }

    /**
     * Projection that may be projected along with other supported volume types
     */
    export interface RevisionSpecVolumesProjectedSourcesArgs {
      /**
       * configMap information about the configMap data to project
       */
      configMap?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesConfigMapArgs>
      /**
       * downwardAPI information about the downwardAPI data to project
       */
      downwardAPI?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesDownwardApiArgs>
      /**
       * secret information about the secret data to project
       */
      secret?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesSecretArgs>
      /**
       * serviceAccountToken is information about the serviceAccountToken data to project
       */
      serviceAccountToken?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesServiceAccountTokenArgs>
    }

    /**
     * configMap information about the configMap data to project
     */
    export interface RevisionSpecVolumesProjectedSourcesConfigMapArgs {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesConfigMapItemsArgs>[]>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface RevisionSpecVolumesProjectedSourcesConfigMapItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * downwardAPI information about the downwardAPI data to project
     */
    export interface RevisionSpecVolumesProjectedSourcesDownwardApiArgs {
      /**
       * Items is a list of DownwardAPIVolume file
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesDownwardApiItemsArgs>[]>
    }

    /**
     * DownwardAPIVolumeFile represents information to create the file containing the pod field
     */
    export interface RevisionSpecVolumesProjectedSourcesDownwardApiItemsArgs {
      /**
       * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
       */
      fieldRef?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesDownwardApiItemsFieldRefArgs>
      /**
       * Optional: mode bits used to set permissions on this file, must be an octal value
       * between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
       */
      path: pulumi.Input<string>
      /**
       * Selects a resource of the container: only resources limits and requests
       * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
       */
      resourceFieldRef?: pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefArgs>
    }

    /**
     * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
     */
    export interface RevisionSpecVolumesProjectedSourcesDownwardApiItemsFieldRefArgs {
      /**
       * Version of the schema the FieldPath is written in terms of, defaults to "v1".
       */
      apiVersion?: pulumi.Input<string>
      /**
       * Path of the field to select in the specified API version.
       */
      fieldPath: pulumi.Input<string>
    }

    /**
     * Selects a resource of the container: only resources limits and requests
     * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
     */
    export interface RevisionSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefArgs {
      /**
       * Container name: required for volumes, optional for env vars
       */
      containerName?: pulumi.Input<string>
      /**
       * Specifies the output format of the exposed resources, defaults to "1"
       */
      divisor?: pulumi.Input<number | string>
      /**
       * Required: resource to select
       */
      resource: pulumi.Input<string>
    }

    /**
     * secret information about the secret data to project
     */
    export interface RevisionSpecVolumesProjectedSourcesSecretArgs {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecVolumesProjectedSourcesSecretItemsArgs>[]>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional field specify whether the Secret or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface RevisionSpecVolumesProjectedSourcesSecretItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * serviceAccountToken is information about the serviceAccountToken data to project
     */
    export interface RevisionSpecVolumesProjectedSourcesServiceAccountTokenArgs {
      /**
       * audience is the intended audience of the token. A recipient of a token
       * must identify itself with an identifier specified in the audience of the
       * token, and otherwise should reject the token. The audience defaults to the
       * identifier of the apiserver.
       */
      audience?: pulumi.Input<string>
      /**
       * expirationSeconds is the requested duration of validity of the service
       * account token. As the token approaches expiration, the kubelet volume
       * plugin will proactively rotate the service account token. The kubelet will
       * start trying to rotate the token if the token is older than 80 percent of
       * its time to live or if the token is older than 24 hours.Defaults to 1 hour
       * and must be at least 10 minutes.
       */
      expirationSeconds?: pulumi.Input<number>
      /**
       * path is the path relative to the mount point of the file to project the
       * token into.
       */
      path: pulumi.Input<string>
    }

    /**
     * secret represents a secret that should populate this volume.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    export interface RevisionSpecVolumesSecretArgs {
      /**
       * defaultMode is Optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values
       * for mode bits. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * items If unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionSpecVolumesSecretItemsArgs>[]>
      /**
       * optional field specify whether the Secret or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
      /**
       * secretName is the name of the secret in the pod's namespace to use.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secretName?: pulumi.Input<string>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface RevisionSpecVolumesSecretItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * RevisionStatus communicates the observed state of the Revision (from the controller).
     */
    export interface RevisionStatusArgs {
      /**
       * ActualReplicas reflects the amount of ready pods running this revision.
       */
      actualReplicas?: pulumi.Input<number>
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionStatusConditionsArgs>[]>
      /**
       * ContainerStatuses is a slice of images present in .Spec.Container[*].Image
       * to their respective digests and their container name.
       * The digests are resolved during the creation of Revision.
       * ContainerStatuses holds the container name and image digests
       * for both serving and non serving containers.
       * ref: http://bit.ly/image-digests
       */
      containerStatuses?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionStatusContainerStatusesArgs>[]>
      /**
       * DesiredReplicas reflects the desired amount of pods running this revision.
       */
      desiredReplicas?: pulumi.Input<number>
      /**
       * InitContainerStatuses is a slice of images present in .Spec.InitContainer[*].Image
       * to their respective digests and their container name.
       * The digests are resolved during the creation of Revision.
       * ContainerStatuses holds the container name and image digests
       * for both serving and non serving containers.
       * ref: http://bit.ly/image-digests
       */
      initContainerStatuses?: pulumi.Input<pulumi.Input<inputs.serving.v1.RevisionStatusInitContainerStatusesArgs>[]>
      /**
       * LogURL specifies the generated logging url for this particular revision
       * based on the revision url template specified in the controller's config.
       */
      logUrl?: pulumi.Input<string>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface RevisionStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }

    /**
     * ContainerStatus holds the information of container name and image digest value
     */
    export interface RevisionStatusContainerStatusesArgs {
      imageDigest?: pulumi.Input<string>
      name?: pulumi.Input<string>
    }

    /**
     * ContainerStatus holds the information of container name and image digest value
     */
    export interface RevisionStatusInitContainerStatusesArgs {
      imageDigest?: pulumi.Input<string>
      name?: pulumi.Input<string>
    }

    /**
     * Spec holds the desired state of the Route (from the client).
     */
    export interface RouteSpecArgs {
      /**
       * Traffic specifies how to distribute traffic over a collection of
       * revisions and configurations.
       */
      traffic?: pulumi.Input<pulumi.Input<inputs.serving.v1.RouteSpecTrafficArgs>[]>
    }

    /**
     * TrafficTarget holds a single entry of the routing table for a Route.
     */
    export interface RouteSpecTrafficArgs {
      /**
       * ConfigurationName of a configuration to whose latest revision we will send
       * this portion of traffic. When the "status.latestReadyRevisionName" of the
       * referenced configuration changes, we will automatically migrate traffic
       * from the prior "latest ready" revision to the new one.  This field is never
       * set in Route's status, only its spec.  This is mutually exclusive with
       * RevisionName.
       */
      configurationName?: pulumi.Input<string>
      /**
       * LatestRevision may be optionally provided to indicate that the latest
       * ready Revision of the Configuration should be used for this traffic
       * target.  When provided LatestRevision must be true if RevisionName is
       * empty; it must be false when RevisionName is non-empty.
       */
      latestRevision?: pulumi.Input<boolean>
      /**
       * Percent indicates that percentage based routing should be used and
       * the value indicates the percent of traffic that is be routed to this
       * Revision or Configuration. `0` (zero) mean no traffic, `100` means all
       * traffic.
       * When percentage based routing is being used the follow rules apply:
       * - the sum of all percent values must equal 100
       * - when not specified, the implied value for `percent` is zero for
       *   that particular Revision or Configuration
       */
      percent?: pulumi.Input<number>
      /**
       * RevisionName of a specific revision to which to send this portion of
       * traffic.  This is mutually exclusive with ConfigurationName.
       */
      revisionName?: pulumi.Input<string>
      /**
       * Tag is optionally used to expose a dedicated url for referencing
       * this target exclusively.
       */
      tag?: pulumi.Input<string>
      /**
       * URL displays the URL for accessing named traffic targets. URL is displayed in
       * status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
       * a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
       */
      url?: pulumi.Input<string>
    }

    /**
     * Status communicates the observed state of the Route (from the controller).
     */
    export interface RouteStatusArgs {
      /**
       * Address holds the information needed for a Route to be the target of an event.
       */
      address?: pulumi.Input<inputs.serving.v1.RouteStatusAddressArgs>
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1.RouteStatusConditionsArgs>[]>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
      /**
       * Traffic holds the configured traffic distribution.
       * These entries will always contain RevisionName references.
       * When ConfigurationName appears in the spec, this will hold the
       * LatestReadyRevisionName that we last observed.
       */
      traffic?: pulumi.Input<pulumi.Input<inputs.serving.v1.RouteStatusTrafficArgs>[]>
      /**
       * URL holds the url that will distribute traffic over the provided traffic targets.
       * It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
       */
      url?: pulumi.Input<string>
    }

    /**
     * Address holds the information needed for a Route to be the target of an event.
     */
    export interface RouteStatusAddressArgs {
      /**
       * CACerts is the Certification Authority (CA) certificates in PEM format
       * according to https://www.rfc-editor.org/rfc/rfc7468.
       */
      CACerts?: pulumi.Input<string>
      /**
       * Audience is the OIDC audience for this address.
       */
      audience?: pulumi.Input<string>
      /**
       * Name is the name of the address.
       */
      name?: pulumi.Input<string>
      url?: pulumi.Input<string>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface RouteStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }

    /**
     * TrafficTarget holds a single entry of the routing table for a Route.
     */
    export interface RouteStatusTrafficArgs {
      /**
       * ConfigurationName of a configuration to whose latest revision we will send
       * this portion of traffic. When the "status.latestReadyRevisionName" of the
       * referenced configuration changes, we will automatically migrate traffic
       * from the prior "latest ready" revision to the new one.  This field is never
       * set in Route's status, only its spec.  This is mutually exclusive with
       * RevisionName.
       */
      configurationName?: pulumi.Input<string>
      /**
       * LatestRevision may be optionally provided to indicate that the latest
       * ready Revision of the Configuration should be used for this traffic
       * target.  When provided LatestRevision must be true if RevisionName is
       * empty; it must be false when RevisionName is non-empty.
       */
      latestRevision?: pulumi.Input<boolean>
      /**
       * Percent indicates that percentage based routing should be used and
       * the value indicates the percent of traffic that is be routed to this
       * Revision or Configuration. `0` (zero) mean no traffic, `100` means all
       * traffic.
       * When percentage based routing is being used the follow rules apply:
       * - the sum of all percent values must equal 100
       * - when not specified, the implied value for `percent` is zero for
       *   that particular Revision or Configuration
       */
      percent?: pulumi.Input<number>
      /**
       * RevisionName of a specific revision to which to send this portion of
       * traffic.  This is mutually exclusive with ConfigurationName.
       */
      revisionName?: pulumi.Input<string>
      /**
       * Tag is optionally used to expose a dedicated url for referencing
       * this target exclusively.
       */
      tag?: pulumi.Input<string>
      /**
       * URL displays the URL for accessing named traffic targets. URL is displayed in
       * status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
       * a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
       */
      url?: pulumi.Input<string>
    }

    /**
     * ServiceSpec represents the configuration for the Service object.
     * A Service's specification is the union of the specifications for a Route
     * and Configuration.  The Service restricts what can be expressed in these
     * fields, e.g. the Route must reference the provided Configuration;
     * however, these limitations also enable friendlier defaulting,
     * e.g. Route never needs a Configuration name, and may be defaulted to
     * the appropriate "run latest" spec.
     */
    export interface ServiceSpecArgs {
      /**
       * Template holds the latest specification for the Revision to be stamped out.
       */
      template?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateArgs>
      /**
       * Traffic specifies how to distribute traffic over a collection of
       * revisions and configurations.
       */
      traffic?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTrafficArgs>[]>
    }

    /**
     * Template holds the latest specification for the Revision to be stamped out.
     */
    export interface ServiceSpecTemplateArgs {
      metadata?: pulumi.Input<{ [key: string]: any }>
      /**
       * RevisionSpec holds the desired state of the Revision (from the client).
       */
      spec?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecArgs>
    }

    /**
     * RevisionSpec holds the desired state of the Revision (from the client).
     */
    export interface ServiceSpecTemplateSpecArgs {
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-affinity
       */
      affinity?: pulumi.Input<{ [key: string]: any }>
      /**
       * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
       */
      automountServiceAccountToken?: pulumi.Input<boolean>
      /**
       * ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
       * requests per container of the Revision.  Defaults to `0` which means
       * concurrency to the application is not limited, and the system decides the
       * target concurrency for the autoscaler.
       */
      containerConcurrency?: pulumi.Input<number>
      /**
       * List of containers belonging to the pod.
       * Containers cannot currently be added or removed.
       * There must be at least one container in a Pod.
       * Cannot be updated.
       */
      containers: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersArgs>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
       */
      dnsConfig?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
       */
      dnsPolicy?: pulumi.Input<string>
      /**
       * EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
       */
      enableServiceLinks?: pulumi.Input<boolean>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-hostaliases
       */
      hostAliases?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
       * to stay open while not receiving any bytes from the user's application. If
       * unspecified, a system default will be provided.
       */
      idleTimeoutSeconds?: pulumi.Input<number>
      /**
       * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
       */
      imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecImagePullSecretsArgs>[]>
      /**
       * List of initialization containers belonging to the pod.
       * Init containers are executed in order prior to containers being started. If any
       * init container fails, the pod is considered to have failed and is handled according
       * to its restartPolicy. The name for an init container or normal container must be
       * unique among all containers.
       * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
       * The resourceRequirements of an init container are taken into account during scheduling
       * by finding the highest request/limit for each resource type, and then using the max of
       * of that value or the sum of the normal containers. Limits are applied to init containers
       * in a similar fashion.
       * Init containers cannot currently be added or removed.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
       */
      initContainers?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-nodeselector
       */
      nodeSelector?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
       */
      priorityClassName?: pulumi.Input<{ [key: string]: any }>
      /**
       * ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
       * routing layer will wait for a request delivered to a container to begin
       * sending any network traffic.
       */
      responseStartTimeoutSeconds?: pulumi.Input<number>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
       */
      runtimeClassName?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-schedulername
       */
      schedulerName?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-securitycontext
       */
      securityContext?: pulumi.Input<{ [key: string]: any }>
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
       */
      serviceAccountName?: pulumi.Input<string>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-shareproccessnamespace
       */
      shareProcessNamespace?: pulumi.Input<{ [key: string]: any }>
      /**
       * TimeoutSeconds is the maximum duration in seconds that the request instance
       * is allowed to respond to a request. If unspecified, a system default will
       * be provided.
       */
      timeoutSeconds?: pulumi.Input<number>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-tolerations
       */
      tolerations?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
       */
      topologySpreadConstraints?: pulumi.Input<pulumi.Input<{ [key: string]: any }>[]>
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes
       */
      volumes?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesArgs>[]>
    }

    /**
     * A single application container that you want to run within a pod.
     */
    export interface ServiceSpecTemplateSpecContainersArgs {
      /**
       * Arguments to the entrypoint.
       * The container image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      args?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * Entrypoint array. Not executed within a shell.
       * The container image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
       * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
       * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
       * of whether the variable exists or not. Cannot be updated.
       * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * List of environment variables to set in the container.
       * Cannot be updated.
       */
      env?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersEnvArgs>[]>
      /**
       * List of sources to populate environment variables in the container.
       * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
       * will be reported as an event when the container is starting. When a key exists in multiple
       * sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence.
       * Cannot be updated.
       */
      envFrom?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersEnvFromArgs>[]>
      /**
       * Container image name.
       * More info: https://kubernetes.io/docs/concepts/containers/images
       * This field is optional to allow higher level config management to default or override
       * container images in workload controllers like Deployments and StatefulSets.
       */
      image?: pulumi.Input<string>
      /**
       * Image pull policy.
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
       */
      imagePullPolicy?: pulumi.Input<string>
      /**
       * Periodic probe of container liveness.
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      livenessProbe?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeArgs>
      /**
       * Name of the container specified as a DNS_LABEL.
       * Each container in a pod must have a unique name (DNS_LABEL).
       * Cannot be updated.
       */
      name?: pulumi.Input<string>
      /**
       * List of ports to expose from the container. Not specifying a port here
       * DOES NOT prevent that port from being exposed. Any port which is
       * listening on the default "0.0.0.0" address inside a container will be
       * accessible from the network.
       * Modifying this array with strategic merge patch may corrupt the data.
       * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
       * Cannot be updated.
       */
      ports?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersPortsArgs>[]>
      /**
       * Periodic probe of container service readiness.
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      readinessProbe?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeArgs>
      /**
       * Compute Resources required by this container.
       * Cannot be updated.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      resources?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersResourcesArgs>
      /**
       * SecurityContext defines the security options the container should be run with.
       * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
       * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
       */
      securityContext?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersSecurityContextArgs>
      /**
       * Optional: Path at which the file to which the container's termination message
       * will be written is mounted into the container's filesystem.
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes. The total message length across
       * all containers will be limited to 12kb.
       * Defaults to /dev/termination-log.
       * Cannot be updated.
       */
      terminationMessagePath?: pulumi.Input<string>
      /**
       * Indicate how the termination message should be populated. File will use the contents of
       * terminationMessagePath to populate the container status message on both success and failure.
       * FallbackToLogsOnError will use the last chunk of container log output if the termination
       * message file is empty and the container exited with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       */
      terminationMessagePolicy?: pulumi.Input<string>
      /**
       * Pod volumes to mount into the container's filesystem.
       * Cannot be updated.
       */
      volumeMounts?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersVolumeMountsArgs>[]>
      /**
       * Container's working directory.
       * If not specified, the container runtime's default will be used, which
       * might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: pulumi.Input<string>
    }

    /**
     * EnvVar represents an environment variable present in a Container.
     */
    export interface ServiceSpecTemplateSpecContainersEnvArgs {
      /**
       * Name of the environment variable. Must be a C_IDENTIFIER.
       */
      name: pulumi.Input<string>
      /**
       * Variable references $(VAR_NAME) are expanded
       * using the previously defined environment variables in the container and
       * any service environment variables. If a variable cannot be resolved,
       * the reference in the input string will be unchanged. Double $$ are reduced
       * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
       * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
       * Escaped references will never be expanded, regardless of whether the variable
       * exists or not.
       * Defaults to "".
       */
      value?: pulumi.Input<string>
      /**
       * Source for the environment variable's value. Cannot be used if value is not empty.
       */
      valueFrom?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersEnvValueFromArgs>
    }

    /**
     * EnvFromSource represents the source of a set of ConfigMaps
     */
    export interface ServiceSpecTemplateSpecContainersEnvFromArgs {
      /**
       * The ConfigMap to select from
       */
      configMapRef?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersEnvFromConfigMapRefArgs>
      /**
       * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
       */
      prefix?: pulumi.Input<string>
      /**
       * The Secret to select from
       */
      secretRef?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersEnvFromSecretRefArgs>
    }

    /**
     * The ConfigMap to select from
     */
    export interface ServiceSpecTemplateSpecContainersEnvFromConfigMapRefArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * The Secret to select from
     */
    export interface ServiceSpecTemplateSpecContainersEnvFromSecretRefArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the Secret must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Source for the environment variable's value. Cannot be used if value is not empty.
     */
    export interface ServiceSpecTemplateSpecContainersEnvValueFromArgs {
      /**
       * Selects a key of a ConfigMap.
       */
      configMapKeyRef?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersEnvValueFromConfigMapKeyRefArgs>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      fieldRef?: pulumi.Input<{ [key: string]: any }>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-fieldref
       */
      resourceFieldRef?: pulumi.Input<{ [key: string]: any }>
      /**
       * Selects a key of a secret in the pod's namespace
       */
      secretKeyRef?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersEnvValueFromSecretKeyRefArgs>
    }

    /**
     * Selects a key of a ConfigMap.
     */
    export interface ServiceSpecTemplateSpecContainersEnvValueFromConfigMapKeyRefArgs {
      /**
       * The key to select.
       */
      key: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the ConfigMap or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Selects a key of a secret in the pod's namespace
     */
    export interface ServiceSpecTemplateSpecContainersEnvValueFromSecretKeyRefArgs {
      /**
       * The key of the secret to select from.  Must be a valid secret key.
       */
      key: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * Specify whether the Secret or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Periodic probe of container liveness.
     * Container will be restarted if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeArgs {
      /**
       * Exec specifies the action to take.
       */
      exec?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeExecArgs>
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: pulumi.Input<number>
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeGrpcArgs>
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeHttpGetArgs>
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: pulumi.Input<number>
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: pulumi.Input<number>
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: pulumi.Input<number>
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeTcpSocketArgs>
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: pulumi.Input<number>
    }

    /**
     * Exec specifies the action to take.
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeExecArgs {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeGrpcArgs {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: pulumi.Input<number>
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: pulumi.Input<string>
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeHttpGetArgs {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: pulumi.Input<string>
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersArgs>[]
      >
      /**
       * Path to access on the HTTP server.
       */
      path?: pulumi.Input<string>
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: pulumi.Input<string>
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersArgs {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: pulumi.Input<string>
      /**
       * The header field value
       */
      value: pulumi.Input<string>
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface ServiceSpecTemplateSpecContainersLivenessProbeTcpSocketArgs {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: pulumi.Input<string>
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
    }

    /**
     * ContainerPort represents a network port in a single container.
     */
    export interface ServiceSpecTemplateSpecContainersPortsArgs {
      /**
       * Number of port to expose on the pod's IP address.
       * This must be a valid port number, 0 < x < 65536.
       */
      containerPort: pulumi.Input<number>
      /**
       * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
       * named port in a pod must have a unique name. Name for the port that can be
       * referred to by services.
       */
      name?: pulumi.Input<string>
      /**
       * Protocol for port. Must be UDP, TCP, or SCTP.
       * Defaults to "TCP".
       */
      protocol?: pulumi.Input<string>
    }
    /**
     * serviceSpecTemplateSpecContainersPortsArgsProvideDefaults sets the appropriate defaults for ServiceSpecTemplateSpecContainersPortsArgs
     */
    export function serviceSpecTemplateSpecContainersPortsArgsProvideDefaults(
      val: ServiceSpecTemplateSpecContainersPortsArgs,
    ): ServiceSpecTemplateSpecContainersPortsArgs {
      return {
        ...val,
        protocol: val.protocol ?? "TCP",
      }
    }

    /**
     * Periodic probe of container service readiness.
     * Container will be removed from service endpoints if the probe fails.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeArgs {
      /**
       * Exec specifies the action to take.
       */
      exec?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeExecArgs>
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       * Defaults to 3. Minimum value is 1.
       */
      failureThreshold?: pulumi.Input<number>
      /**
       * GRPC specifies an action involving a GRPC port.
       */
      grpc?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeGrpcArgs>
      /**
       * HTTPGet specifies the http request to perform.
       */
      httpGet?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeHttpGetArgs>
      /**
       * Number of seconds after the container has started before liveness probes are initiated.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      initialDelaySeconds?: pulumi.Input<number>
      /**
       * How often (in seconds) to perform the probe.
       */
      periodSeconds?: pulumi.Input<number>
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
       */
      successThreshold?: pulumi.Input<number>
      /**
       * TCPSocket specifies an action involving a TCP port.
       */
      tcpSocket?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeTcpSocketArgs>
      /**
       * Number of seconds after which the probe times out.
       * Defaults to 1 second. Minimum value is 1.
       * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
       */
      timeoutSeconds?: pulumi.Input<number>
    }

    /**
     * Exec specifies the action to take.
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeExecArgs {
      /**
       * Command is the command line to execute inside the container, the working directory for the
       * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
       * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
       * a shell, you need to explicitly call out to that shell.
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * GRPC specifies an action involving a GRPC port.
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeGrpcArgs {
      /**
       * Port number of the gRPC service. Number must be in the range 1 to 65535.
       */
      port: pulumi.Input<number>
      /**
       * Service is the name of the service to place in the gRPC HealthCheckRequest
       * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
       *
       *
       * If this is not specified, the default behavior is defined by gRPC.
       */
      service?: pulumi.Input<string>
    }

    /**
     * HTTPGet specifies the http request to perform.
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeHttpGetArgs {
      /**
       * Host name to connect to, defaults to the pod IP. You probably want to set
       * "Host" in httpHeaders instead.
       */
      host?: pulumi.Input<string>
      /**
       * Custom headers to set in the request. HTTP allows repeated headers.
       */
      httpHeaders?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeadersArgs>[]
      >
      /**
       * Path to access on the HTTP server.
       */
      path?: pulumi.Input<string>
      /**
       * Name or number of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
      /**
       * Scheme to use for connecting to the host.
       * Defaults to HTTP.
       */
      scheme?: pulumi.Input<string>
    }

    /**
     * HTTPHeader describes a custom header to be used in HTTP probes
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeadersArgs {
      /**
       * The header field name.
       * This will be canonicalized upon output, so case-variant names will be understood as the same header.
       */
      name: pulumi.Input<string>
      /**
       * The header field value
       */
      value: pulumi.Input<string>
    }

    /**
     * TCPSocket specifies an action involving a TCP port.
     */
    export interface ServiceSpecTemplateSpecContainersReadinessProbeTcpSocketArgs {
      /**
       * Optional: Host name to connect to, defaults to the pod IP.
       */
      host?: pulumi.Input<string>
      /**
       * Number or name of the port to access on the container.
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port?: pulumi.Input<number | string>
    }

    /**
     * Compute Resources required by this container.
     * Cannot be updated.
     * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
     */
    export interface ServiceSpecTemplateSpecContainersResourcesArgs {
      /**
       * Claims lists the names of resources, defined in spec.resourceClaims,
       * that are used by this container.
       *
       *
       * This is an alpha field and requires enabling the
       * DynamicResourceAllocation feature gate.
       *
       *
       * This field is immutable. It can only be set for containers.
       */
      claims?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersResourcesClaimsArgs>[]>
      /**
       * Limits describes the maximum amount of compute resources allowed.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      limits?: pulumi.Input<{ [key: string]: pulumi.Input<number | string> }>
      /**
       * Requests describes the minimum amount of compute resources required.
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value. Requests cannot exceed Limits.
       * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
       */
      requests?: pulumi.Input<{ [key: string]: pulumi.Input<number | string> }>
    }

    /**
     * ResourceClaim references one entry in PodSpec.ResourceClaims.
     */
    export interface ServiceSpecTemplateSpecContainersResourcesClaimsArgs {
      /**
       * Name must match the name of one entry in pod.spec.resourceClaims of
       * the Pod where this field is used. It makes that resource available
       * inside a container.
       */
      name: pulumi.Input<string>
    }

    /**
     * SecurityContext defines the security options the container should be run with.
     * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
     * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     */
    export interface ServiceSpecTemplateSpecContainersSecurityContextArgs {
      /**
       * AllowPrivilegeEscalation controls whether a process can gain more
       * privileges than its parent process. This bool directly controls if
       * the no_new_privs flag will be set on the container process.
       * AllowPrivilegeEscalation is true always when the container is:
       * 1) run as Privileged
       * 2) has CAP_SYS_ADMIN
       * Note that this field cannot be set when spec.os.name is windows.
       */
      allowPrivilegeEscalation?: pulumi.Input<boolean>
      /**
       * The capabilities to add/drop when running containers.
       * Defaults to the default set of capabilities granted by the container runtime.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      capabilities?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersSecurityContextCapabilitiesArgs>
      /**
       * Whether this container has a read-only root filesystem.
       * Default is false.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      readOnlyRootFilesystem?: pulumi.Input<boolean>
      /**
       * The GID to run the entrypoint of the container process.
       * Uses runtime default if unset.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsGroup?: pulumi.Input<number>
      /**
       * Indicates that the container must run as a non-root user.
       * If true, the Kubelet will validate the image at runtime to ensure that it
       * does not run as UID 0 (root) and fail to start the container if it does.
       * If unset or false, no such validation will be performed.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: pulumi.Input<boolean>
      /**
       * The UID to run the entrypoint of the container process.
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in PodSecurityContext.  If set in both SecurityContext and
       * PodSecurityContext, the value specified in SecurityContext takes precedence.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      runAsUser?: pulumi.Input<number>
      /**
       * The seccomp options to use by this container. If seccomp options are
       * provided at both the pod & container level, the container options
       * override the pod options.
       * Note that this field cannot be set when spec.os.name is windows.
       */
      seccompProfile?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecContainersSecurityContextSeccompProfileArgs>
    }

    /**
     * The capabilities to add/drop when running containers.
     * Defaults to the default set of capabilities granted by the container runtime.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface ServiceSpecTemplateSpecContainersSecurityContextCapabilitiesArgs {
      /**
       * This is accessible behind a feature flag - kubernetes.containerspec-addcapabilities
       */
      add?: pulumi.Input<pulumi.Input<string>[]>
      /**
       * Removed capabilities
       */
      drop?: pulumi.Input<pulumi.Input<string>[]>
    }

    /**
     * The seccomp options to use by this container. If seccomp options are
     * provided at both the pod & container level, the container options
     * override the pod options.
     * Note that this field cannot be set when spec.os.name is windows.
     */
    export interface ServiceSpecTemplateSpecContainersSecurityContextSeccompProfileArgs {
      /**
       * localhostProfile indicates a profile defined in a file on the node should be used.
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must be set if type is "Localhost". Must NOT be set for any other type.
       */
      localhostProfile?: pulumi.Input<string>
      /**
       * type indicates which kind of seccomp profile will be applied.
       * Valid options are:
       *
       *
       * Localhost - a profile defined in a file on the node should be used.
       * RuntimeDefault - the container runtime default profile should be used.
       * Unconfined - no profile should be applied.
       */
      type: pulumi.Input<string>
    }

    /**
     * VolumeMount describes a mounting of a Volume within a container.
     */
    export interface ServiceSpecTemplateSpecContainersVolumeMountsArgs {
      /**
       * Path within the container at which the volume should be mounted.  Must
       * not contain ':'.
       */
      mountPath: pulumi.Input<string>
      /**
       * This must match the Name of a Volume.
       */
      name: pulumi.Input<string>
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       * Defaults to false.
       */
      readOnly?: pulumi.Input<boolean>
      /**
       * Path within the volume from which the container's volume should be mounted.
       * Defaults to "" (volume's root).
       */
      subPath?: pulumi.Input<string>
    }

    /**
     * LocalObjectReference contains enough information to let you locate the
     * referenced object inside the same namespace.
     */
    export interface ServiceSpecTemplateSpecImagePullSecretsArgs {
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
    }

    /**
     * Volume represents a named volume in a pod that may be accessed by any container in the pod.
     */
    export interface ServiceSpecTemplateSpecVolumesArgs {
      /**
       * configMap represents a configMap that should populate this volume
       */
      configMap?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesConfigMapArgs>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-emptydir
       */
      emptyDir?: pulumi.Input<{ [key: string]: any }>
      /**
       * name of the volume.
       * Must be a DNS_LABEL and unique within the pod.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name: pulumi.Input<string>
      /**
       * This is accessible behind a feature flag - kubernetes.podspec-persistent-volume-claim
       */
      persistentVolumeClaim?: pulumi.Input<{ [key: string]: any }>
      /**
       * projected items for all in one resources secrets, configmaps, and downward API
       */
      projected?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedArgs>
      /**
       * secret represents a secret that should populate this volume.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secret?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesSecretArgs>
    }

    /**
     * configMap represents a configMap that should populate this volume
     */
    export interface ServiceSpecTemplateSpecVolumesConfigMapArgs {
      /**
       * defaultMode is optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesConfigMapItemsArgs>[]>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ServiceSpecTemplateSpecVolumesConfigMapItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * projected items for all in one resources secrets, configmaps, and downward API
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedArgs {
      /**
       * defaultMode are the mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * sources is the list of volume projections
       */
      sources?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesArgs>[]>
    }

    /**
     * Projection that may be projected along with other supported volume types
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesArgs {
      /**
       * configMap information about the configMap data to project
       */
      configMap?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesConfigMapArgs>
      /**
       * downwardAPI information about the downwardAPI data to project
       */
      downwardAPI?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiArgs>
      /**
       * secret information about the secret data to project
       */
      secret?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesSecretArgs>
      /**
       * serviceAccountToken is information about the serviceAccountToken data to project
       */
      serviceAccountToken?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesServiceAccountTokenArgs>
    }

    /**
     * configMap information about the configMap data to project
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesConfigMapArgs {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * ConfigMap will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the ConfigMap,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesConfigMapItemsArgs>[]
      >
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional specify whether the ConfigMap or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesConfigMapItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * downwardAPI information about the downwardAPI data to project
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiArgs {
      /**
       * Items is a list of DownwardAPIVolume file
       */
      items?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsArgs>[]
      >
    }

    /**
     * DownwardAPIVolumeFile represents information to create the file containing the pod field
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsArgs {
      /**
       * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
       */
      fieldRef?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRefArgs>
      /**
       * Optional: mode bits used to set permissions on this file, must be an octal value
       * between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
       */
      path: pulumi.Input<string>
      /**
       * Selects a resource of the container: only resources limits and requests
       * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
       */
      resourceFieldRef?: pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefArgs>
    }

    /**
     * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRefArgs {
      /**
       * Version of the schema the FieldPath is written in terms of, defaults to "v1".
       */
      apiVersion?: pulumi.Input<string>
      /**
       * Path of the field to select in the specified API version.
       */
      fieldPath: pulumi.Input<string>
    }

    /**
     * Selects a resource of the container: only resources limits and requests
     * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefArgs {
      /**
       * Container name: required for volumes, optional for env vars
       */
      containerName?: pulumi.Input<string>
      /**
       * Specifies the output format of the exposed resources, defaults to "1"
       */
      divisor?: pulumi.Input<number | string>
      /**
       * Required: resource to select
       */
      resource: pulumi.Input<string>
    }

    /**
     * secret information about the secret data to project
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesSecretArgs {
      /**
       * items if unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<
        pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesProjectedSourcesSecretItemsArgs>[]
      >
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       * TODO: Add other useful fields. apiVersion, kind, uid?
       */
      name?: pulumi.Input<string>
      /**
       * optional field specify whether the Secret or its key must be defined
       */
      optional?: pulumi.Input<boolean>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesSecretItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * serviceAccountToken is information about the serviceAccountToken data to project
     */
    export interface ServiceSpecTemplateSpecVolumesProjectedSourcesServiceAccountTokenArgs {
      /**
       * audience is the intended audience of the token. A recipient of a token
       * must identify itself with an identifier specified in the audience of the
       * token, and otherwise should reject the token. The audience defaults to the
       * identifier of the apiserver.
       */
      audience?: pulumi.Input<string>
      /**
       * expirationSeconds is the requested duration of validity of the service
       * account token. As the token approaches expiration, the kubelet volume
       * plugin will proactively rotate the service account token. The kubelet will
       * start trying to rotate the token if the token is older than 80 percent of
       * its time to live or if the token is older than 24 hours.Defaults to 1 hour
       * and must be at least 10 minutes.
       */
      expirationSeconds?: pulumi.Input<number>
      /**
       * path is the path relative to the mount point of the file to project the
       * token into.
       */
      path: pulumi.Input<string>
    }

    /**
     * secret represents a secret that should populate this volume.
     * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
     */
    export interface ServiceSpecTemplateSpecVolumesSecretArgs {
      /**
       * defaultMode is Optional: mode bits used to set permissions on created files by default.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values
       * for mode bits. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: pulumi.Input<number>
      /**
       * items If unspecified, each key-value pair in the Data field of the referenced
       * Secret will be projected into the volume as a file whose name is the
       * key and content is the value. If specified, the listed keys will be
       * projected into the specified paths, and unlisted keys will not be
       * present. If a key is specified which is not present in the Secret,
       * the volume setup will error unless it is marked optional. Paths must be
       * relative and may not contain the '..' path or start with '..'.
       */
      items?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceSpecTemplateSpecVolumesSecretItemsArgs>[]>
      /**
       * optional field specify whether the Secret or its keys must be defined
       */
      optional?: pulumi.Input<boolean>
      /**
       * secretName is the name of the secret in the pod's namespace to use.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
       */
      secretName?: pulumi.Input<string>
    }

    /**
     * Maps a string key to a path within a volume.
     */
    export interface ServiceSpecTemplateSpecVolumesSecretItemsArgs {
      /**
       * key is the key to project.
       */
      key: pulumi.Input<string>
      /**
       * mode is Optional: mode bits used to set permissions on this file.
       * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
       * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file
       * mode, like fsGroup, and the result can be other mode bits set.
       */
      mode?: pulumi.Input<number>
      /**
       * path is the relative path of the file to map the key to.
       * May not be an absolute path.
       * May not contain the path element '..'.
       * May not start with the string '..'.
       */
      path: pulumi.Input<string>
    }

    /**
     * TrafficTarget holds a single entry of the routing table for a Route.
     */
    export interface ServiceSpecTrafficArgs {
      /**
       * ConfigurationName of a configuration to whose latest revision we will send
       * this portion of traffic. When the "status.latestReadyRevisionName" of the
       * referenced configuration changes, we will automatically migrate traffic
       * from the prior "latest ready" revision to the new one.  This field is never
       * set in Route's status, only its spec.  This is mutually exclusive with
       * RevisionName.
       */
      configurationName?: pulumi.Input<string>
      /**
       * LatestRevision may be optionally provided to indicate that the latest
       * ready Revision of the Configuration should be used for this traffic
       * target.  When provided LatestRevision must be true if RevisionName is
       * empty; it must be false when RevisionName is non-empty.
       */
      latestRevision?: pulumi.Input<boolean>
      /**
       * Percent indicates that percentage based routing should be used and
       * the value indicates the percent of traffic that is be routed to this
       * Revision or Configuration. `0` (zero) mean no traffic, `100` means all
       * traffic.
       * When percentage based routing is being used the follow rules apply:
       * - the sum of all percent values must equal 100
       * - when not specified, the implied value for `percent` is zero for
       *   that particular Revision or Configuration
       */
      percent?: pulumi.Input<number>
      /**
       * RevisionName of a specific revision to which to send this portion of
       * traffic.  This is mutually exclusive with ConfigurationName.
       */
      revisionName?: pulumi.Input<string>
      /**
       * Tag is optionally used to expose a dedicated url for referencing
       * this target exclusively.
       */
      tag?: pulumi.Input<string>
      /**
       * URL displays the URL for accessing named traffic targets. URL is displayed in
       * status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
       * a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
       */
      url?: pulumi.Input<string>
    }

    /**
     * ServiceStatus represents the Status stanza of the Service resource.
     */
    export interface ServiceStatusArgs {
      /**
       * Address holds the information needed for a Route to be the target of an event.
       */
      address?: pulumi.Input<inputs.serving.v1.ServiceStatusAddressArgs>
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceStatusConditionsArgs>[]>
      /**
       * LatestCreatedRevisionName is the last revision that was created from this
       * Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
       */
      latestCreatedRevisionName?: pulumi.Input<string>
      /**
       * LatestReadyRevisionName holds the name of the latest Revision stamped out
       * from this Configuration that has had its "Ready" condition become "True".
       */
      latestReadyRevisionName?: pulumi.Input<string>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
      /**
       * Traffic holds the configured traffic distribution.
       * These entries will always contain RevisionName references.
       * When ConfigurationName appears in the spec, this will hold the
       * LatestReadyRevisionName that we last observed.
       */
      traffic?: pulumi.Input<pulumi.Input<inputs.serving.v1.ServiceStatusTrafficArgs>[]>
      /**
       * URL holds the url that will distribute traffic over the provided traffic targets.
       * It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
       */
      url?: pulumi.Input<string>
    }

    /**
     * Address holds the information needed for a Route to be the target of an event.
     */
    export interface ServiceStatusAddressArgs {
      /**
       * CACerts is the Certification Authority (CA) certificates in PEM format
       * according to https://www.rfc-editor.org/rfc/rfc7468.
       */
      CACerts?: pulumi.Input<string>
      /**
       * Audience is the OIDC audience for this address.
       */
      audience?: pulumi.Input<string>
      /**
       * Name is the name of the address.
       */
      name?: pulumi.Input<string>
      url?: pulumi.Input<string>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface ServiceStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }

    /**
     * TrafficTarget holds a single entry of the routing table for a Route.
     */
    export interface ServiceStatusTrafficArgs {
      /**
       * ConfigurationName of a configuration to whose latest revision we will send
       * this portion of traffic. When the "status.latestReadyRevisionName" of the
       * referenced configuration changes, we will automatically migrate traffic
       * from the prior "latest ready" revision to the new one.  This field is never
       * set in Route's status, only its spec.  This is mutually exclusive with
       * RevisionName.
       */
      configurationName?: pulumi.Input<string>
      /**
       * LatestRevision may be optionally provided to indicate that the latest
       * ready Revision of the Configuration should be used for this traffic
       * target.  When provided LatestRevision must be true if RevisionName is
       * empty; it must be false when RevisionName is non-empty.
       */
      latestRevision?: pulumi.Input<boolean>
      /**
       * Percent indicates that percentage based routing should be used and
       * the value indicates the percent of traffic that is be routed to this
       * Revision or Configuration. `0` (zero) mean no traffic, `100` means all
       * traffic.
       * When percentage based routing is being used the follow rules apply:
       * - the sum of all percent values must equal 100
       * - when not specified, the implied value for `percent` is zero for
       *   that particular Revision or Configuration
       */
      percent?: pulumi.Input<number>
      /**
       * RevisionName of a specific revision to which to send this portion of
       * traffic.  This is mutually exclusive with ConfigurationName.
       */
      revisionName?: pulumi.Input<string>
      /**
       * Tag is optionally used to expose a dedicated url for referencing
       * this target exclusively.
       */
      tag?: pulumi.Input<string>
      /**
       * URL displays the URL for accessing named traffic targets. URL is displayed in
       * status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
       * a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
       */
      url?: pulumi.Input<string>
    }
  }

  export namespace v1beta1 {
    /**
     * Spec is the desired state of the DomainMapping.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface DomainMappingSpecArgs {
      /**
       * Ref specifies the target of the Domain Mapping.
       *
       *
       * The object identified by the Ref must be an Addressable with a URL of the
       * form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain,
       * and `{name}` and `{namespace}` are the name and namespace of a Kubernetes
       * Service.
       *
       *
       * This contract is satisfied by Knative types such as Knative Services and
       * Knative Routes, and by Kubernetes Services.
       */
      ref: pulumi.Input<inputs.serving.v1beta1.DomainMappingSpecRefArgs>
      /**
       * TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
       */
      tls?: pulumi.Input<inputs.serving.v1beta1.DomainMappingSpecTlsArgs>
    }

    /**
     * Ref specifies the target of the Domain Mapping.
     *
     *
     * The object identified by the Ref must be an Addressable with a URL of the
     * form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain,
     * and `{name}` and `{namespace}` are the name and namespace of a Kubernetes
     * Service.
     *
     *
     * This contract is satisfied by Knative types such as Knative Services and
     * Knative Routes, and by Kubernetes Services.
     */
    export interface DomainMappingSpecRefArgs {
      /**
       * Address points to a specific Address Name.
       */
      address?: pulumi.Input<string>
      /**
       * API version of the referent.
       */
      apiVersion?: pulumi.Input<string>
      /**
       * Group of the API, without the version of the group. This can be used as an alternative to the APIVersion, and then resolved using ResolveGroup.
       * Note: This API is EXPERIMENTAL and might break anytime. For more details: https://github.com/knative/eventing/issues/5086
       */
      group?: pulumi.Input<string>
      /**
       * Kind of the referent.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       */
      kind: pulumi.Input<string>
      /**
       * Name of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
       */
      name: pulumi.Input<string>
      /**
       * Namespace of the referent.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
       * This is optional field, it gets defaulted to the object holding it if left out.
       */
      namespace?: pulumi.Input<string>
    }

    /**
     * TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
     */
    export interface DomainMappingSpecTlsArgs {
      /**
       * SecretName is the name of the existing secret used to terminate TLS traffic.
       */
      secretName: pulumi.Input<string>
    }

    /**
     * Status is the current state of the DomainMapping.
     * More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     */
    export interface DomainMappingStatusArgs {
      /**
       * Address holds the information needed for a DomainMapping to be the target of an event.
       */
      address?: pulumi.Input<inputs.serving.v1beta1.DomainMappingStatusAddressArgs>
      /**
       * Annotations is additional Status fields for the Resource to save some
       * additional State as well as convey more information to the user. This is
       * roughly akin to Annotations on any k8s resource, just the reconciler conveying
       * richer information outwards.
       */
      annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>
      /**
       * Conditions the latest available observations of a resource's current state.
       */
      conditions?: pulumi.Input<pulumi.Input<inputs.serving.v1beta1.DomainMappingStatusConditionsArgs>[]>
      /**
       * ObservedGeneration is the 'Generation' of the Service that
       * was last processed by the controller.
       */
      observedGeneration?: pulumi.Input<number>
      /**
       * URL is the URL of this DomainMapping.
       */
      url?: pulumi.Input<string>
    }

    /**
     * Address holds the information needed for a DomainMapping to be the target of an event.
     */
    export interface DomainMappingStatusAddressArgs {
      /**
       * CACerts is the Certification Authority (CA) certificates in PEM format
       * according to https://www.rfc-editor.org/rfc/rfc7468.
       */
      CACerts?: pulumi.Input<string>
      /**
       * Audience is the OIDC audience for this address.
       */
      audience?: pulumi.Input<string>
      /**
       * Name is the name of the address.
       */
      name?: pulumi.Input<string>
      url?: pulumi.Input<string>
    }

    /**
     * Condition defines a readiness condition for a Knative resource.
     * See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
     */
    export interface DomainMappingStatusConditionsArgs {
      /**
       * LastTransitionTime is the last time the condition transitioned from one status to another.
       * We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
       * differences (all other things held constant).
       */
      lastTransitionTime?: pulumi.Input<string>
      /**
       * A human readable message indicating details about the transition.
       */
      message?: pulumi.Input<string>
      /**
       * The reason for the condition's last transition.
       */
      reason?: pulumi.Input<string>
      /**
       * Severity with which to treat failures of this type of condition.
       * When this is not specified, it defaults to Error.
       */
      severity?: pulumi.Input<string>
      /**
       * Status of the condition, one of True, False, Unknown.
       */
      status: pulumi.Input<string>
      /**
       * Type of condition.
       */
      type: pulumi.Input<string>
    }
  }
}
